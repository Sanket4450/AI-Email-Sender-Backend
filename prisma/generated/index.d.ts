
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactEvent
 * 
 */
export type ContactEvent = $Result.DefaultSelection<Prisma.$ContactEventPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model EmailEvent
 * 
 */
export type EmailEvent = $Result.DefaultSelection<Prisma.$EmailEventPayload>
/**
 * Model FollowUp
 * 
 */
export type FollowUp = $Result.DefaultSelection<Prisma.$FollowUpPayload>
/**
 * Model FollowUpEvent
 * 
 */
export type FollowUpEvent = $Result.DefaultSelection<Prisma.$FollowUpEventPayload>
/**
 * Model Draft
 * 
 */
export type Draft = $Result.DefaultSelection<Prisma.$DraftPayload>
/**
 * Model DraftContact
 * 
 */
export type DraftContact = $Result.DefaultSelection<Prisma.$DraftContactPayload>
/**
 * Model LLMLog
 * 
 */
export type LLMLog = $Result.DefaultSelection<Prisma.$LLMLogPayload>
/**
 * Model WebhookLog
 * 
 */
export type WebhookLog = $Result.DefaultSelection<Prisma.$WebhookLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Sender
 * 
 */
export type Sender = $Result.DefaultSelection<Prisma.$SenderPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model CompanyTag
 * 
 */
export type CompanyTag = $Result.DefaultSelection<Prisma.$CompanyTagPayload>
/**
 * Model ContactTag
 * 
 */
export type ContactTag = $Result.DefaultSelection<Prisma.$ContactTagPayload>
/**
 * Model DraftTag
 * 
 */
export type DraftTag = $Result.DefaultSelection<Prisma.$DraftTagPayload>
/**
 * Model EmailTag
 * 
 */
export type EmailTag = $Result.DefaultSelection<Prisma.$EmailTagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContactEventType: {
  notContacted: 'notContacted',
  emailSent: 'emailSent',
  rejected: 'rejected',
  pending: 'pending',
  replied: 'replied'
};

export type ContactEventType = (typeof ContactEventType)[keyof typeof ContactEventType]


export const EmailEventType: {
  processed: 'processed',
  delivered: 'delivered',
  opened: 'opened',
  clicked: 'clicked'
};

export type EmailEventType = (typeof EmailEventType)[keyof typeof EmailEventType]


export const NotificationType: {
  reply: 'reply'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type ContactEventType = $Enums.ContactEventType

export const ContactEventType: typeof $Enums.ContactEventType

export type EmailEventType = $Enums.EmailEventType

export const EmailEventType: typeof $Enums.EmailEventType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactEvent`: Exposes CRUD operations for the **ContactEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactEvents
    * const contactEvents = await prisma.contactEvent.findMany()
    * ```
    */
  get contactEvent(): Prisma.ContactEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailEvent`: Exposes CRUD operations for the **EmailEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailEvents
    * const emailEvents = await prisma.emailEvent.findMany()
    * ```
    */
  get emailEvent(): Prisma.EmailEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followUp`: Exposes CRUD operations for the **FollowUp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowUps
    * const followUps = await prisma.followUp.findMany()
    * ```
    */
  get followUp(): Prisma.FollowUpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followUpEvent`: Exposes CRUD operations for the **FollowUpEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowUpEvents
    * const followUpEvents = await prisma.followUpEvent.findMany()
    * ```
    */
  get followUpEvent(): Prisma.FollowUpEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draft`: Exposes CRUD operations for the **Draft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drafts
    * const drafts = await prisma.draft.findMany()
    * ```
    */
  get draft(): Prisma.DraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draftContact`: Exposes CRUD operations for the **DraftContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DraftContacts
    * const draftContacts = await prisma.draftContact.findMany()
    * ```
    */
  get draftContact(): Prisma.DraftContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lLMLog`: Exposes CRUD operations for the **LLMLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LLMLogs
    * const lLMLogs = await prisma.lLMLog.findMany()
    * ```
    */
  get lLMLog(): Prisma.LLMLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **WebhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.WebhookLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sender`: Exposes CRUD operations for the **Sender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Senders
    * const senders = await prisma.sender.findMany()
    * ```
    */
  get sender(): Prisma.SenderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyTag`: Exposes CRUD operations for the **CompanyTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyTags
    * const companyTags = await prisma.companyTag.findMany()
    * ```
    */
  get companyTag(): Prisma.CompanyTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactTag`: Exposes CRUD operations for the **ContactTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTags
    * const contactTags = await prisma.contactTag.findMany()
    * ```
    */
  get contactTag(): Prisma.ContactTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.draftTag`: Exposes CRUD operations for the **DraftTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DraftTags
    * const draftTags = await prisma.draftTag.findMany()
    * ```
    */
  get draftTag(): Prisma.DraftTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailTag`: Exposes CRUD operations for the **EmailTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailTags
    * const emailTags = await prisma.emailTag.findMany()
    * ```
    */
  get emailTag(): Prisma.EmailTagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    Contact: 'Contact',
    ContactEvent: 'ContactEvent',
    Email: 'Email',
    EmailEvent: 'EmailEvent',
    FollowUp: 'FollowUp',
    FollowUpEvent: 'FollowUpEvent',
    Draft: 'Draft',
    DraftContact: 'DraftContact',
    LLMLog: 'LLMLog',
    WebhookLog: 'WebhookLog',
    Notification: 'Notification',
    Sender: 'Sender',
    Tag: 'Tag',
    CompanyTag: 'CompanyTag',
    ContactTag: 'ContactTag',
    DraftTag: 'DraftTag',
    EmailTag: 'EmailTag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "contact" | "contactEvent" | "email" | "emailEvent" | "followUp" | "followUpEvent" | "draft" | "draftContact" | "lLMLog" | "webhookLog" | "notification" | "sender" | "tag" | "companyTag" | "contactTag" | "draftTag" | "emailTag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactEvent: {
        payload: Prisma.$ContactEventPayload<ExtArgs>
        fields: Prisma.ContactEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          findFirst: {
            args: Prisma.ContactEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          findMany: {
            args: Prisma.ContactEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>[]
          }
          create: {
            args: Prisma.ContactEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          createMany: {
            args: Prisma.ContactEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>[]
          }
          delete: {
            args: Prisma.ContactEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          update: {
            args: Prisma.ContactEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          deleteMany: {
            args: Prisma.ContactEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>[]
          }
          upsert: {
            args: Prisma.ContactEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactEventPayload>
          }
          aggregate: {
            args: Prisma.ContactEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactEvent>
          }
          groupBy: {
            args: Prisma.ContactEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactEventCountArgs<ExtArgs>
            result: $Utils.Optional<ContactEventCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      EmailEvent: {
        payload: Prisma.$EmailEventPayload<ExtArgs>
        fields: Prisma.EmailEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          findFirst: {
            args: Prisma.EmailEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          findMany: {
            args: Prisma.EmailEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>[]
          }
          create: {
            args: Prisma.EmailEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          createMany: {
            args: Prisma.EmailEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>[]
          }
          delete: {
            args: Prisma.EmailEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          update: {
            args: Prisma.EmailEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          deleteMany: {
            args: Prisma.EmailEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>[]
          }
          upsert: {
            args: Prisma.EmailEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailEventPayload>
          }
          aggregate: {
            args: Prisma.EmailEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailEvent>
          }
          groupBy: {
            args: Prisma.EmailEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailEventCountArgs<ExtArgs>
            result: $Utils.Optional<EmailEventCountAggregateOutputType> | number
          }
        }
      }
      FollowUp: {
        payload: Prisma.$FollowUpPayload<ExtArgs>
        fields: Prisma.FollowUpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowUpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowUpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          findFirst: {
            args: Prisma.FollowUpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowUpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          findMany: {
            args: Prisma.FollowUpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          create: {
            args: Prisma.FollowUpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          createMany: {
            args: Prisma.FollowUpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowUpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          delete: {
            args: Prisma.FollowUpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          update: {
            args: Prisma.FollowUpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          deleteMany: {
            args: Prisma.FollowUpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          aggregate: {
            args: Prisma.FollowUpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowUp>
          }
          groupBy: {
            args: Prisma.FollowUpGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowUpGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowUpCountArgs<ExtArgs>
            result: $Utils.Optional<FollowUpCountAggregateOutputType> | number
          }
        }
      }
      FollowUpEvent: {
        payload: Prisma.$FollowUpEventPayload<ExtArgs>
        fields: Prisma.FollowUpEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowUpEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowUpEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          findFirst: {
            args: Prisma.FollowUpEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowUpEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          findMany: {
            args: Prisma.FollowUpEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>[]
          }
          create: {
            args: Prisma.FollowUpEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          createMany: {
            args: Prisma.FollowUpEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowUpEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>[]
          }
          delete: {
            args: Prisma.FollowUpEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          update: {
            args: Prisma.FollowUpEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          deleteMany: {
            args: Prisma.FollowUpEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpEventPayload>
          }
          aggregate: {
            args: Prisma.FollowUpEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowUpEvent>
          }
          groupBy: {
            args: Prisma.FollowUpEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowUpEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowUpEventCountArgs<ExtArgs>
            result: $Utils.Optional<FollowUpEventCountAggregateOutputType> | number
          }
        }
      }
      Draft: {
        payload: Prisma.$DraftPayload<ExtArgs>
        fields: Prisma.DraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findFirst: {
            args: Prisma.DraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          findMany: {
            args: Prisma.DraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          create: {
            args: Prisma.DraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          createMany: {
            args: Prisma.DraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          delete: {
            args: Prisma.DraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          update: {
            args: Prisma.DraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          deleteMany: {
            args: Prisma.DraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>[]
          }
          upsert: {
            args: Prisma.DraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftPayload>
          }
          aggregate: {
            args: Prisma.DraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraft>
          }
          groupBy: {
            args: Prisma.DraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftCountArgs<ExtArgs>
            result: $Utils.Optional<DraftCountAggregateOutputType> | number
          }
        }
      }
      DraftContact: {
        payload: Prisma.$DraftContactPayload<ExtArgs>
        fields: Prisma.DraftContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          findFirst: {
            args: Prisma.DraftContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          findMany: {
            args: Prisma.DraftContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>[]
          }
          create: {
            args: Prisma.DraftContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          createMany: {
            args: Prisma.DraftContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>[]
          }
          delete: {
            args: Prisma.DraftContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          update: {
            args: Prisma.DraftContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          deleteMany: {
            args: Prisma.DraftContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DraftContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>[]
          }
          upsert: {
            args: Prisma.DraftContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftContactPayload>
          }
          aggregate: {
            args: Prisma.DraftContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraftContact>
          }
          groupBy: {
            args: Prisma.DraftContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftContactCountArgs<ExtArgs>
            result: $Utils.Optional<DraftContactCountAggregateOutputType> | number
          }
        }
      }
      LLMLog: {
        payload: Prisma.$LLMLogPayload<ExtArgs>
        fields: Prisma.LLMLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LLMLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LLMLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          findFirst: {
            args: Prisma.LLMLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LLMLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          findMany: {
            args: Prisma.LLMLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>[]
          }
          create: {
            args: Prisma.LLMLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          createMany: {
            args: Prisma.LLMLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LLMLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>[]
          }
          delete: {
            args: Prisma.LLMLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          update: {
            args: Prisma.LLMLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          deleteMany: {
            args: Prisma.LLMLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LLMLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LLMLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>[]
          }
          upsert: {
            args: Prisma.LLMLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LLMLogPayload>
          }
          aggregate: {
            args: Prisma.LLMLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLLMLog>
          }
          groupBy: {
            args: Prisma.LLMLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LLMLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LLMLogCountArgs<ExtArgs>
            result: $Utils.Optional<LLMLogCountAggregateOutputType> | number
          }
        }
      }
      WebhookLog: {
        payload: Prisma.$WebhookLogPayload<ExtArgs>
        fields: Prisma.WebhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findFirst: {
            args: Prisma.WebhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          findMany: {
            args: Prisma.WebhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          create: {
            args: Prisma.WebhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          createMany: {
            args: Prisma.WebhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          delete: {
            args: Prisma.WebhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          update: {
            args: Prisma.WebhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          deleteMany: {
            args: Prisma.WebhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebhookLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>[]
          }
          upsert: {
            args: Prisma.WebhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.WebhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Sender: {
        payload: Prisma.$SenderPayload<ExtArgs>
        fields: Prisma.SenderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SenderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SenderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          findFirst: {
            args: Prisma.SenderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SenderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          findMany: {
            args: Prisma.SenderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>[]
          }
          create: {
            args: Prisma.SenderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          createMany: {
            args: Prisma.SenderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SenderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>[]
          }
          delete: {
            args: Prisma.SenderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          update: {
            args: Prisma.SenderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          deleteMany: {
            args: Prisma.SenderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SenderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SenderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>[]
          }
          upsert: {
            args: Prisma.SenderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SenderPayload>
          }
          aggregate: {
            args: Prisma.SenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSender>
          }
          groupBy: {
            args: Prisma.SenderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SenderCountArgs<ExtArgs>
            result: $Utils.Optional<SenderCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      CompanyTag: {
        payload: Prisma.$CompanyTagPayload<ExtArgs>
        fields: Prisma.CompanyTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          findFirst: {
            args: Prisma.CompanyTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          findMany: {
            args: Prisma.CompanyTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>[]
          }
          create: {
            args: Prisma.CompanyTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          createMany: {
            args: Prisma.CompanyTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>[]
          }
          delete: {
            args: Prisma.CompanyTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          update: {
            args: Prisma.CompanyTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          deleteMany: {
            args: Prisma.CompanyTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>[]
          }
          upsert: {
            args: Prisma.CompanyTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyTagPayload>
          }
          aggregate: {
            args: Prisma.CompanyTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyTag>
          }
          groupBy: {
            args: Prisma.CompanyTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyTagCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyTagCountAggregateOutputType> | number
          }
        }
      }
      ContactTag: {
        payload: Prisma.$ContactTagPayload<ExtArgs>
        fields: Prisma.ContactTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findFirst: {
            args: Prisma.ContactTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findMany: {
            args: Prisma.ContactTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          create: {
            args: Prisma.ContactTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          createMany: {
            args: Prisma.ContactTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          delete: {
            args: Prisma.ContactTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          update: {
            args: Prisma.ContactTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          deleteMany: {
            args: Prisma.ContactTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          upsert: {
            args: Prisma.ContactTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          aggregate: {
            args: Prisma.ContactTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactTag>
          }
          groupBy: {
            args: Prisma.ContactTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTagCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTagCountAggregateOutputType> | number
          }
        }
      }
      DraftTag: {
        payload: Prisma.$DraftTagPayload<ExtArgs>
        fields: Prisma.DraftTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DraftTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DraftTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          findFirst: {
            args: Prisma.DraftTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DraftTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          findMany: {
            args: Prisma.DraftTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>[]
          }
          create: {
            args: Prisma.DraftTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          createMany: {
            args: Prisma.DraftTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DraftTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>[]
          }
          delete: {
            args: Prisma.DraftTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          update: {
            args: Prisma.DraftTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          deleteMany: {
            args: Prisma.DraftTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DraftTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DraftTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>[]
          }
          upsert: {
            args: Prisma.DraftTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DraftTagPayload>
          }
          aggregate: {
            args: Prisma.DraftTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDraftTag>
          }
          groupBy: {
            args: Prisma.DraftTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DraftTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DraftTagCountArgs<ExtArgs>
            result: $Utils.Optional<DraftTagCountAggregateOutputType> | number
          }
        }
      }
      EmailTag: {
        payload: Prisma.$EmailTagPayload<ExtArgs>
        fields: Prisma.EmailTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          findFirst: {
            args: Prisma.EmailTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          findMany: {
            args: Prisma.EmailTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>[]
          }
          create: {
            args: Prisma.EmailTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          createMany: {
            args: Prisma.EmailTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>[]
          }
          delete: {
            args: Prisma.EmailTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          update: {
            args: Prisma.EmailTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          deleteMany: {
            args: Prisma.EmailTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>[]
          }
          upsert: {
            args: Prisma.EmailTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailTagPayload>
          }
          aggregate: {
            args: Prisma.EmailTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailTag>
          }
          groupBy: {
            args: Prisma.EmailTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailTagCountArgs<ExtArgs>
            result: $Utils.Optional<EmailTagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    contact?: ContactOmit
    contactEvent?: ContactEventOmit
    email?: EmailOmit
    emailEvent?: EmailEventOmit
    followUp?: FollowUpOmit
    followUpEvent?: FollowUpEventOmit
    draft?: DraftOmit
    draftContact?: DraftContactOmit
    lLMLog?: LLMLogOmit
    webhookLog?: WebhookLogOmit
    notification?: NotificationOmit
    sender?: SenderOmit
    tag?: TagOmit
    companyTag?: CompanyTagOmit
    contactTag?: ContactTagOmit
    draftTag?: DraftTagOmit
    emailTag?: EmailTagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    companyTags: number
    contacts: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyTags?: boolean | CompanyCountOutputTypeCountCompanyTagsArgs
    contacts?: boolean | CompanyCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountCompanyTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyTagWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    contactTags: number
    events: number
    contactDrafts: number
    emails: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactTags?: boolean | ContactCountOutputTypeCountContactTagsArgs
    events?: boolean | ContactCountOutputTypeCountEventsArgs
    contactDrafts?: boolean | ContactCountOutputTypeCountContactDraftsArgs
    emails?: boolean | ContactCountOutputTypeCountEmailsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactEventWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftContactWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * Count Type EmailCountOutputType
   */

  export type EmailCountOutputType = {
    emailTags: number
    events: number
    followUps: number
    notifications: number
  }

  export type EmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emailTags?: boolean | EmailCountOutputTypeCountEmailTagsArgs
    events?: boolean | EmailCountOutputTypeCountEventsArgs
    followUps?: boolean | EmailCountOutputTypeCountFollowUpsArgs
    notifications?: boolean | EmailCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCountOutputType
     */
    select?: EmailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountEmailTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTagWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEventWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountFollowUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpWhereInput
  }

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type FollowUpCountOutputType
   */

  export type FollowUpCountOutputType = {
    events: number
  }

  export type FollowUpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | FollowUpCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * FollowUpCountOutputType without action
   */
  export type FollowUpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpCountOutputType
     */
    select?: FollowUpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FollowUpCountOutputType without action
   */
  export type FollowUpCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpEventWhereInput
  }


  /**
   * Count Type DraftCountOutputType
   */

  export type DraftCountOutputType = {
    draftContacts: number
    draftTags: number
  }

  export type DraftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draftContacts?: boolean | DraftCountOutputTypeCountDraftContactsArgs
    draftTags?: boolean | DraftCountOutputTypeCountDraftTagsArgs
  }

  // Custom InputTypes
  /**
   * DraftCountOutputType without action
   */
  export type DraftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftCountOutputType
     */
    select?: DraftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DraftCountOutputType without action
   */
  export type DraftCountOutputTypeCountDraftContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftContactWhereInput
  }

  /**
   * DraftCountOutputType without action
   */
  export type DraftCountOutputTypeCountDraftTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftTagWhereInput
  }


  /**
   * Count Type SenderCountOutputType
   */

  export type SenderCountOutputType = {
    drafts: number
    emails: number
  }

  export type SenderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | SenderCountOutputTypeCountDraftsArgs
    emails?: boolean | SenderCountOutputTypeCountEmailsArgs
  }

  // Custom InputTypes
  /**
   * SenderCountOutputType without action
   */
  export type SenderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SenderCountOutputType
     */
    select?: SenderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SenderCountOutputType without action
   */
  export type SenderCountOutputTypeCountDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
  }

  /**
   * SenderCountOutputType without action
   */
  export type SenderCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    tagCompanies: number
    tagContacts: number
    DraftTag: number
    EmailTag: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagCompanies?: boolean | TagCountOutputTypeCountTagCompaniesArgs
    tagContacts?: boolean | TagCountOutputTypeCountTagContactsArgs
    DraftTag?: boolean | TagCountOutputTypeCountDraftTagArgs
    EmailTag?: boolean | TagCountOutputTypeCountEmailTagArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTagCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTagContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountDraftTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountEmailTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    location: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    location: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    location?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    title: string
    description: string | null
    location: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyTags?: boolean | Company$companyTagsArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    location?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "location" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyTags?: boolean | Company$companyTagsArgs<ExtArgs>
    contacts?: boolean | Company$contactsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      companyTags: Prisma.$CompanyTagPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      location: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companyTags<T extends Company$companyTagsArgs<ExtArgs> = {}>(args?: Subset<T, Company$companyTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Company$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Company$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly title: FieldRef<"Company", 'String'>
    readonly description: FieldRef<"Company", 'String'>
    readonly location: FieldRef<"Company", 'String'>
    readonly isDeleted: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.companyTags
   */
  export type Company$companyTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    where?: CompanyTagWhereInput
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    cursor?: CompanyTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyTagScalarFieldEnum | CompanyTagScalarFieldEnum[]
  }

  /**
   * Company.contacts
   */
  export type Company$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    position: string | null
    email: string | null
    phone: string | null
    linkedInUrl: string | null
    location: string | null
    companyId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    position: string | null
    email: string | null
    phone: string | null
    linkedInUrl: string | null
    location: string | null
    companyId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    position: number
    email: number
    phone: number
    linkedInUrl: number
    location: number
    companyId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    position?: true
    email?: true
    phone?: true
    linkedInUrl?: true
    location?: true
    companyId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    position?: true
    email?: true
    phone?: true
    linkedInUrl?: true
    location?: true
    companyId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    position?: true
    email?: true
    phone?: true
    linkedInUrl?: true
    location?: true
    companyId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    position: string
    email: string
    phone: string | null
    linkedInUrl: string | null
    location: string | null
    companyId: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    linkedInUrl?: boolean
    location?: boolean
    companyId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactTags?: boolean | Contact$contactTagsArgs<ExtArgs>
    events?: boolean | Contact$eventsArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    contactDrafts?: boolean | Contact$contactDraftsArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    linkedInUrl?: boolean
    location?: boolean
    companyId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | Contact$companyArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    linkedInUrl?: boolean
    location?: boolean
    companyId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | Contact$companyArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    linkedInUrl?: boolean
    location?: boolean
    companyId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "position" | "email" | "phone" | "linkedInUrl" | "location" | "companyId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactTags?: boolean | Contact$contactTagsArgs<ExtArgs>
    events?: boolean | Contact$eventsArgs<ExtArgs>
    company?: boolean | Contact$companyArgs<ExtArgs>
    contactDrafts?: boolean | Contact$contactDraftsArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Contact$companyArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | Contact$companyArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      contactTags: Prisma.$ContactTagPayload<ExtArgs>[]
      events: Prisma.$ContactEventPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs> | null
      contactDrafts: Prisma.$DraftContactPayload<ExtArgs>[]
      emails: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      position: string
      email: string
      phone: string | null
      linkedInUrl: string | null
      location: string | null
      companyId: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactTags<T extends Contact$contactTagsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$contactTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Contact$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends Contact$companyArgs<ExtArgs> = {}>(args?: Subset<T, Contact$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contactDrafts<T extends Contact$contactDraftsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$contactDraftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends Contact$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly position: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly linkedInUrl: FieldRef<"Contact", 'String'>
    readonly location: FieldRef<"Contact", 'String'>
    readonly companyId: FieldRef<"Contact", 'String'>
    readonly isDeleted: FieldRef<"Contact", 'Boolean'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.contactTags
   */
  export type Contact$contactTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Contact.events
   */
  export type Contact$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    where?: ContactEventWhereInput
    orderBy?: ContactEventOrderByWithRelationInput | ContactEventOrderByWithRelationInput[]
    cursor?: ContactEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactEventScalarFieldEnum | ContactEventScalarFieldEnum[]
  }

  /**
   * Contact.company
   */
  export type Contact$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Contact.contactDrafts
   */
  export type Contact$contactDraftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    where?: DraftContactWhereInput
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    cursor?: DraftContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftContactScalarFieldEnum | DraftContactScalarFieldEnum[]
  }

  /**
   * Contact.emails
   */
  export type Contact$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactEvent
   */

  export type AggregateContactEvent = {
    _count: ContactEventCountAggregateOutputType | null
    _min: ContactEventMinAggregateOutputType | null
    _max: ContactEventMaxAggregateOutputType | null
  }

  export type ContactEventMinAggregateOutputType = {
    id: string | null
    contactId: string | null
    eventType: $Enums.ContactEventType | null
    createdAt: Date | null
  }

  export type ContactEventMaxAggregateOutputType = {
    id: string | null
    contactId: string | null
    eventType: $Enums.ContactEventType | null
    createdAt: Date | null
  }

  export type ContactEventCountAggregateOutputType = {
    id: number
    contactId: number
    eventType: number
    createdAt: number
    _all: number
  }


  export type ContactEventMinAggregateInputType = {
    id?: true
    contactId?: true
    eventType?: true
    createdAt?: true
  }

  export type ContactEventMaxAggregateInputType = {
    id?: true
    contactId?: true
    eventType?: true
    createdAt?: true
  }

  export type ContactEventCountAggregateInputType = {
    id?: true
    contactId?: true
    eventType?: true
    createdAt?: true
    _all?: true
  }

  export type ContactEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactEvent to aggregate.
     */
    where?: ContactEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEvents to fetch.
     */
    orderBy?: ContactEventOrderByWithRelationInput | ContactEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactEvents
    **/
    _count?: true | ContactEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactEventMaxAggregateInputType
  }

  export type GetContactEventAggregateType<T extends ContactEventAggregateArgs> = {
        [P in keyof T & keyof AggregateContactEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactEvent[P]>
      : GetScalarType<T[P], AggregateContactEvent[P]>
  }




  export type ContactEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactEventWhereInput
    orderBy?: ContactEventOrderByWithAggregationInput | ContactEventOrderByWithAggregationInput[]
    by: ContactEventScalarFieldEnum[] | ContactEventScalarFieldEnum
    having?: ContactEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactEventCountAggregateInputType | true
    _min?: ContactEventMinAggregateInputType
    _max?: ContactEventMaxAggregateInputType
  }

  export type ContactEventGroupByOutputType = {
    id: string
    contactId: string
    eventType: $Enums.ContactEventType
    createdAt: Date
    _count: ContactEventCountAggregateOutputType | null
    _min: ContactEventMinAggregateOutputType | null
    _max: ContactEventMaxAggregateOutputType | null
  }

  type GetContactEventGroupByPayload<T extends ContactEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactEventGroupByOutputType[P]>
            : GetScalarType<T[P], ContactEventGroupByOutputType[P]>
        }
      >
    >


  export type ContactEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    eventType?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEvent"]>

  export type ContactEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    eventType?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEvent"]>

  export type ContactEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    eventType?: boolean
    createdAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactEvent"]>

  export type ContactEventSelectScalar = {
    id?: boolean
    contactId?: boolean
    eventType?: boolean
    createdAt?: boolean
  }

  export type ContactEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "eventType" | "createdAt", ExtArgs["result"]["contactEvent"]>
  export type ContactEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type ContactEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactEvent"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contactId: string
      eventType: $Enums.ContactEventType
      createdAt: Date
    }, ExtArgs["result"]["contactEvent"]>
    composites: {}
  }

  type ContactEventGetPayload<S extends boolean | null | undefined | ContactEventDefaultArgs> = $Result.GetResult<Prisma.$ContactEventPayload, S>

  type ContactEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactEventCountAggregateInputType | true
    }

  export interface ContactEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactEvent'], meta: { name: 'ContactEvent' } }
    /**
     * Find zero or one ContactEvent that matches the filter.
     * @param {ContactEventFindUniqueArgs} args - Arguments to find a ContactEvent
     * @example
     * // Get one ContactEvent
     * const contactEvent = await prisma.contactEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactEventFindUniqueArgs>(args: SelectSubset<T, ContactEventFindUniqueArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactEventFindUniqueOrThrowArgs} args - Arguments to find a ContactEvent
     * @example
     * // Get one ContactEvent
     * const contactEvent = await prisma.contactEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventFindFirstArgs} args - Arguments to find a ContactEvent
     * @example
     * // Get one ContactEvent
     * const contactEvent = await prisma.contactEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactEventFindFirstArgs>(args?: SelectSubset<T, ContactEventFindFirstArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventFindFirstOrThrowArgs} args - Arguments to find a ContactEvent
     * @example
     * // Get one ContactEvent
     * const contactEvent = await prisma.contactEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactEvents
     * const contactEvents = await prisma.contactEvent.findMany()
     * 
     * // Get first 10 ContactEvents
     * const contactEvents = await prisma.contactEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactEventWithIdOnly = await prisma.contactEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactEventFindManyArgs>(args?: SelectSubset<T, ContactEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactEvent.
     * @param {ContactEventCreateArgs} args - Arguments to create a ContactEvent.
     * @example
     * // Create one ContactEvent
     * const ContactEvent = await prisma.contactEvent.create({
     *   data: {
     *     // ... data to create a ContactEvent
     *   }
     * })
     * 
     */
    create<T extends ContactEventCreateArgs>(args: SelectSubset<T, ContactEventCreateArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactEvents.
     * @param {ContactEventCreateManyArgs} args - Arguments to create many ContactEvents.
     * @example
     * // Create many ContactEvents
     * const contactEvent = await prisma.contactEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactEventCreateManyArgs>(args?: SelectSubset<T, ContactEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactEvents and returns the data saved in the database.
     * @param {ContactEventCreateManyAndReturnArgs} args - Arguments to create many ContactEvents.
     * @example
     * // Create many ContactEvents
     * const contactEvent = await prisma.contactEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactEvents and only return the `id`
     * const contactEventWithIdOnly = await prisma.contactEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactEventCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactEvent.
     * @param {ContactEventDeleteArgs} args - Arguments to delete one ContactEvent.
     * @example
     * // Delete one ContactEvent
     * const ContactEvent = await prisma.contactEvent.delete({
     *   where: {
     *     // ... filter to delete one ContactEvent
     *   }
     * })
     * 
     */
    delete<T extends ContactEventDeleteArgs>(args: SelectSubset<T, ContactEventDeleteArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactEvent.
     * @param {ContactEventUpdateArgs} args - Arguments to update one ContactEvent.
     * @example
     * // Update one ContactEvent
     * const contactEvent = await prisma.contactEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactEventUpdateArgs>(args: SelectSubset<T, ContactEventUpdateArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactEvents.
     * @param {ContactEventDeleteManyArgs} args - Arguments to filter ContactEvents to delete.
     * @example
     * // Delete a few ContactEvents
     * const { count } = await prisma.contactEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactEventDeleteManyArgs>(args?: SelectSubset<T, ContactEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactEvents
     * const contactEvent = await prisma.contactEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactEventUpdateManyArgs>(args: SelectSubset<T, ContactEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactEvents and returns the data updated in the database.
     * @param {ContactEventUpdateManyAndReturnArgs} args - Arguments to update many ContactEvents.
     * @example
     * // Update many ContactEvents
     * const contactEvent = await prisma.contactEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactEvents and only return the `id`
     * const contactEventWithIdOnly = await prisma.contactEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactEventUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactEvent.
     * @param {ContactEventUpsertArgs} args - Arguments to update or create a ContactEvent.
     * @example
     * // Update or create a ContactEvent
     * const contactEvent = await prisma.contactEvent.upsert({
     *   create: {
     *     // ... data to create a ContactEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactEvent we want to update
     *   }
     * })
     */
    upsert<T extends ContactEventUpsertArgs>(args: SelectSubset<T, ContactEventUpsertArgs<ExtArgs>>): Prisma__ContactEventClient<$Result.GetResult<Prisma.$ContactEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventCountArgs} args - Arguments to filter ContactEvents to count.
     * @example
     * // Count the number of ContactEvents
     * const count = await prisma.contactEvent.count({
     *   where: {
     *     // ... the filter for the ContactEvents we want to count
     *   }
     * })
    **/
    count<T extends ContactEventCountArgs>(
      args?: Subset<T, ContactEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactEventAggregateArgs>(args: Subset<T, ContactEventAggregateArgs>): Prisma.PrismaPromise<GetContactEventAggregateType<T>>

    /**
     * Group by ContactEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactEventGroupByArgs['orderBy'] }
        : { orderBy?: ContactEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactEvent model
   */
  readonly fields: ContactEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactEvent model
   */
  interface ContactEventFieldRefs {
    readonly id: FieldRef<"ContactEvent", 'String'>
    readonly contactId: FieldRef<"ContactEvent", 'String'>
    readonly eventType: FieldRef<"ContactEvent", 'ContactEventType'>
    readonly createdAt: FieldRef<"ContactEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactEvent findUnique
   */
  export type ContactEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactEvent to fetch.
     */
    where: ContactEventWhereUniqueInput
  }

  /**
   * ContactEvent findUniqueOrThrow
   */
  export type ContactEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactEvent to fetch.
     */
    where: ContactEventWhereUniqueInput
  }

  /**
   * ContactEvent findFirst
   */
  export type ContactEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactEvent to fetch.
     */
    where?: ContactEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEvents to fetch.
     */
    orderBy?: ContactEventOrderByWithRelationInput | ContactEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactEvents.
     */
    cursor?: ContactEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactEvents.
     */
    distinct?: ContactEventScalarFieldEnum | ContactEventScalarFieldEnum[]
  }

  /**
   * ContactEvent findFirstOrThrow
   */
  export type ContactEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactEvent to fetch.
     */
    where?: ContactEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEvents to fetch.
     */
    orderBy?: ContactEventOrderByWithRelationInput | ContactEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactEvents.
     */
    cursor?: ContactEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactEvents.
     */
    distinct?: ContactEventScalarFieldEnum | ContactEventScalarFieldEnum[]
  }

  /**
   * ContactEvent findMany
   */
  export type ContactEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter, which ContactEvents to fetch.
     */
    where?: ContactEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactEvents to fetch.
     */
    orderBy?: ContactEventOrderByWithRelationInput | ContactEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactEvents.
     */
    cursor?: ContactEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactEvents.
     */
    skip?: number
    distinct?: ContactEventScalarFieldEnum | ContactEventScalarFieldEnum[]
  }

  /**
   * ContactEvent create
   */
  export type ContactEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactEvent.
     */
    data: XOR<ContactEventCreateInput, ContactEventUncheckedCreateInput>
  }

  /**
   * ContactEvent createMany
   */
  export type ContactEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactEvents.
     */
    data: ContactEventCreateManyInput | ContactEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactEvent createManyAndReturn
   */
  export type ContactEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * The data used to create many ContactEvents.
     */
    data: ContactEventCreateManyInput | ContactEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactEvent update
   */
  export type ContactEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactEvent.
     */
    data: XOR<ContactEventUpdateInput, ContactEventUncheckedUpdateInput>
    /**
     * Choose, which ContactEvent to update.
     */
    where: ContactEventWhereUniqueInput
  }

  /**
   * ContactEvent updateMany
   */
  export type ContactEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactEvents.
     */
    data: XOR<ContactEventUpdateManyMutationInput, ContactEventUncheckedUpdateManyInput>
    /**
     * Filter which ContactEvents to update
     */
    where?: ContactEventWhereInput
    /**
     * Limit how many ContactEvents to update.
     */
    limit?: number
  }

  /**
   * ContactEvent updateManyAndReturn
   */
  export type ContactEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * The data used to update ContactEvents.
     */
    data: XOR<ContactEventUpdateManyMutationInput, ContactEventUncheckedUpdateManyInput>
    /**
     * Filter which ContactEvents to update
     */
    where?: ContactEventWhereInput
    /**
     * Limit how many ContactEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactEvent upsert
   */
  export type ContactEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactEvent to update in case it exists.
     */
    where: ContactEventWhereUniqueInput
    /**
     * In case the ContactEvent found by the `where` argument doesn't exist, create a new ContactEvent with this data.
     */
    create: XOR<ContactEventCreateInput, ContactEventUncheckedCreateInput>
    /**
     * In case the ContactEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactEventUpdateInput, ContactEventUncheckedUpdateInput>
  }

  /**
   * ContactEvent delete
   */
  export type ContactEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
    /**
     * Filter which ContactEvent to delete.
     */
    where: ContactEventWhereUniqueInput
  }

  /**
   * ContactEvent deleteMany
   */
  export type ContactEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactEvents to delete
     */
    where?: ContactEventWhereInput
    /**
     * Limit how many ContactEvents to delete.
     */
    limit?: number
  }

  /**
   * ContactEvent without action
   */
  export type ContactEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactEvent
     */
    select?: ContactEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactEvent
     */
    omit?: ContactEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactEventInclude<ExtArgs> | null
  }


  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailMinAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    messageId: string | null
    contactId: string | null
    isBounced: boolean | null
    isSpamReported: boolean | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    messageId: string | null
    contactId: string | null
    isBounced: boolean | null
    isSpamReported: boolean | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    subject: number
    body: number
    messageId: number
    contactId: number
    isBounced: number
    isSpamReported: number
    senderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailMinAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    messageId?: true
    contactId?: true
    isBounced?: true
    isSpamReported?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    messageId?: true
    contactId?: true
    isBounced?: true
    isSpamReported?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    messageId?: true
    contactId?: true
    isBounced?: true
    isSpamReported?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: string
    subject: string
    body: string
    messageId: string | null
    contactId: string
    isBounced: boolean
    isSpamReported: boolean
    senderId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    messageId?: boolean
    contactId?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
    emailTags?: boolean | Email$emailTagsArgs<ExtArgs>
    events?: boolean | Email$eventsArgs<ExtArgs>
    followUps?: boolean | Email$followUpsArgs<ExtArgs>
    notifications?: boolean | Email$notificationsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    messageId?: boolean
    contactId?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    messageId?: boolean
    contactId?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectScalar = {
    id?: boolean
    subject?: boolean
    body?: boolean
    messageId?: boolean
    contactId?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "body" | "messageId" | "contactId" | "isBounced" | "isSpamReported" | "senderId" | "createdAt" | "updatedAt", ExtArgs["result"]["email"]>
  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
    emailTags?: boolean | Email$emailTagsArgs<ExtArgs>
    events?: boolean | Email$eventsArgs<ExtArgs>
    followUps?: boolean | Email$followUpsArgs<ExtArgs>
    notifications?: boolean | Email$notificationsArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
  }
  export type EmailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    sender?: boolean | SenderDefaultArgs<ExtArgs>
  }

  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      sender: Prisma.$SenderPayload<ExtArgs>
      emailTags: Prisma.$EmailTagPayload<ExtArgs>[]
      events: Prisma.$EmailEventPayload<ExtArgs>[]
      followUps: Prisma.$FollowUpPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      body: string
      messageId: string | null
      contactId: string
      isBounced: boolean
      isSpamReported: boolean
      senderId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["email"]>
    composites: {}
  }

  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailFindUniqueArgs>(args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailFindFirstArgs>(args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailFindManyArgs>(args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
     */
    create<T extends EmailCreateArgs>(args: SelectSubset<T, EmailCreateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emails.
     * @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailCreateManyArgs>(args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emails and returns the data saved in the database.
     * @param {EmailCreateManyAndReturnArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
     */
    delete<T extends EmailDeleteArgs>(args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailUpdateArgs>(args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailDeleteManyArgs>(args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailUpdateManyArgs>(args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails and returns the data updated in the database.
     * @param {EmailUpdateManyAndReturnArgs} args - Arguments to update many Emails.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emails and only return the `id`
     * const emailWithIdOnly = await prisma.email.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends EmailUpsertArgs>(args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends SenderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SenderDefaultArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    emailTags<T extends Email$emailTagsArgs<ExtArgs> = {}>(args?: Subset<T, Email$emailTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Email$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Email$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followUps<T extends Email$followUpsArgs<ExtArgs> = {}>(args?: Subset<T, Email$followUpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Email$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Email$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Email model
   */
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'String'>
    readonly subject: FieldRef<"Email", 'String'>
    readonly body: FieldRef<"Email", 'String'>
    readonly messageId: FieldRef<"Email", 'String'>
    readonly contactId: FieldRef<"Email", 'String'>
    readonly isBounced: FieldRef<"Email", 'Boolean'>
    readonly isSpamReported: FieldRef<"Email", 'Boolean'>
    readonly senderId: FieldRef<"Email", 'String'>
    readonly createdAt: FieldRef<"Email", 'DateTime'>
    readonly updatedAt: FieldRef<"Email", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }

  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Email createManyAndReturn
   */
  export type EmailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to update.
     */
    limit?: number
  }

  /**
   * Email updateManyAndReturn
   */
  export type EmailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }

  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }

  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
    /**
     * Limit how many Emails to delete.
     */
    limit?: number
  }

  /**
   * Email.emailTags
   */
  export type Email$emailTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    where?: EmailTagWhereInput
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    cursor?: EmailTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTagScalarFieldEnum | EmailTagScalarFieldEnum[]
  }

  /**
   * Email.events
   */
  export type Email$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    where?: EmailEventWhereInput
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    cursor?: EmailEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }

  /**
   * Email.followUps
   */
  export type Email$followUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    where?: FollowUpWhereInput
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    cursor?: FollowUpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * Email.notifications
   */
  export type Email$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
  }


  /**
   * Model EmailEvent
   */

  export type AggregateEmailEvent = {
    _count: EmailEventCountAggregateOutputType | null
    _min: EmailEventMinAggregateOutputType | null
    _max: EmailEventMaxAggregateOutputType | null
  }

  export type EmailEventMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    eventType: $Enums.EmailEventType | null
    createdAt: Date | null
  }

  export type EmailEventMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    eventType: $Enums.EmailEventType | null
    createdAt: Date | null
  }

  export type EmailEventCountAggregateOutputType = {
    id: number
    emailId: number
    eventType: number
    createdAt: number
    _all: number
  }


  export type EmailEventMinAggregateInputType = {
    id?: true
    emailId?: true
    eventType?: true
    createdAt?: true
  }

  export type EmailEventMaxAggregateInputType = {
    id?: true
    emailId?: true
    eventType?: true
    createdAt?: true
  }

  export type EmailEventCountAggregateInputType = {
    id?: true
    emailId?: true
    eventType?: true
    createdAt?: true
    _all?: true
  }

  export type EmailEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEvent to aggregate.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailEvents
    **/
    _count?: true | EmailEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailEventMaxAggregateInputType
  }

  export type GetEmailEventAggregateType<T extends EmailEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailEvent[P]>
      : GetScalarType<T[P], AggregateEmailEvent[P]>
  }




  export type EmailEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailEventWhereInput
    orderBy?: EmailEventOrderByWithAggregationInput | EmailEventOrderByWithAggregationInput[]
    by: EmailEventScalarFieldEnum[] | EmailEventScalarFieldEnum
    having?: EmailEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailEventCountAggregateInputType | true
    _min?: EmailEventMinAggregateInputType
    _max?: EmailEventMaxAggregateInputType
  }

  export type EmailEventGroupByOutputType = {
    id: string
    emailId: string
    eventType: $Enums.EmailEventType
    createdAt: Date
    _count: EmailEventCountAggregateOutputType | null
    _min: EmailEventMinAggregateOutputType | null
    _max: EmailEventMaxAggregateOutputType | null
  }

  type GetEmailEventGroupByPayload<T extends EmailEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailEventGroupByOutputType[P]>
            : GetScalarType<T[P], EmailEventGroupByOutputType[P]>
        }
      >
    >


  export type EmailEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    eventType?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailEvent"]>

  export type EmailEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    eventType?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailEvent"]>

  export type EmailEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    eventType?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailEvent"]>

  export type EmailEventSelectScalar = {
    id?: boolean
    emailId?: boolean
    eventType?: boolean
    createdAt?: boolean
  }

  export type EmailEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "eventType" | "createdAt", ExtArgs["result"]["emailEvent"]>
  export type EmailEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type EmailEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $EmailEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailEvent"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      eventType: $Enums.EmailEventType
      createdAt: Date
    }, ExtArgs["result"]["emailEvent"]>
    composites: {}
  }

  type EmailEventGetPayload<S extends boolean | null | undefined | EmailEventDefaultArgs> = $Result.GetResult<Prisma.$EmailEventPayload, S>

  type EmailEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailEventCountAggregateInputType | true
    }

  export interface EmailEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailEvent'], meta: { name: 'EmailEvent' } }
    /**
     * Find zero or one EmailEvent that matches the filter.
     * @param {EmailEventFindUniqueArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailEventFindUniqueArgs>(args: SelectSubset<T, EmailEventFindUniqueArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailEventFindUniqueOrThrowArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailEventFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindFirstArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailEventFindFirstArgs>(args?: SelectSubset<T, EmailEventFindFirstArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindFirstOrThrowArgs} args - Arguments to find a EmailEvent
     * @example
     * // Get one EmailEvent
     * const emailEvent = await prisma.emailEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailEventFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailEvents
     * const emailEvents = await prisma.emailEvent.findMany()
     * 
     * // Get first 10 EmailEvents
     * const emailEvents = await prisma.emailEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailEventWithIdOnly = await prisma.emailEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailEventFindManyArgs>(args?: SelectSubset<T, EmailEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailEvent.
     * @param {EmailEventCreateArgs} args - Arguments to create a EmailEvent.
     * @example
     * // Create one EmailEvent
     * const EmailEvent = await prisma.emailEvent.create({
     *   data: {
     *     // ... data to create a EmailEvent
     *   }
     * })
     * 
     */
    create<T extends EmailEventCreateArgs>(args: SelectSubset<T, EmailEventCreateArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailEvents.
     * @param {EmailEventCreateManyArgs} args - Arguments to create many EmailEvents.
     * @example
     * // Create many EmailEvents
     * const emailEvent = await prisma.emailEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailEventCreateManyArgs>(args?: SelectSubset<T, EmailEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailEvents and returns the data saved in the database.
     * @param {EmailEventCreateManyAndReturnArgs} args - Arguments to create many EmailEvents.
     * @example
     * // Create many EmailEvents
     * const emailEvent = await prisma.emailEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailEvents and only return the `id`
     * const emailEventWithIdOnly = await prisma.emailEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailEventCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailEvent.
     * @param {EmailEventDeleteArgs} args - Arguments to delete one EmailEvent.
     * @example
     * // Delete one EmailEvent
     * const EmailEvent = await prisma.emailEvent.delete({
     *   where: {
     *     // ... filter to delete one EmailEvent
     *   }
     * })
     * 
     */
    delete<T extends EmailEventDeleteArgs>(args: SelectSubset<T, EmailEventDeleteArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailEvent.
     * @param {EmailEventUpdateArgs} args - Arguments to update one EmailEvent.
     * @example
     * // Update one EmailEvent
     * const emailEvent = await prisma.emailEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailEventUpdateArgs>(args: SelectSubset<T, EmailEventUpdateArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailEvents.
     * @param {EmailEventDeleteManyArgs} args - Arguments to filter EmailEvents to delete.
     * @example
     * // Delete a few EmailEvents
     * const { count } = await prisma.emailEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailEventDeleteManyArgs>(args?: SelectSubset<T, EmailEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailEvents
     * const emailEvent = await prisma.emailEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailEventUpdateManyArgs>(args: SelectSubset<T, EmailEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailEvents and returns the data updated in the database.
     * @param {EmailEventUpdateManyAndReturnArgs} args - Arguments to update many EmailEvents.
     * @example
     * // Update many EmailEvents
     * const emailEvent = await prisma.emailEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailEvents and only return the `id`
     * const emailEventWithIdOnly = await prisma.emailEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailEventUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailEvent.
     * @param {EmailEventUpsertArgs} args - Arguments to update or create a EmailEvent.
     * @example
     * // Update or create a EmailEvent
     * const emailEvent = await prisma.emailEvent.upsert({
     *   create: {
     *     // ... data to create a EmailEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailEvent we want to update
     *   }
     * })
     */
    upsert<T extends EmailEventUpsertArgs>(args: SelectSubset<T, EmailEventUpsertArgs<ExtArgs>>): Prisma__EmailEventClient<$Result.GetResult<Prisma.$EmailEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventCountArgs} args - Arguments to filter EmailEvents to count.
     * @example
     * // Count the number of EmailEvents
     * const count = await prisma.emailEvent.count({
     *   where: {
     *     // ... the filter for the EmailEvents we want to count
     *   }
     * })
    **/
    count<T extends EmailEventCountArgs>(
      args?: Subset<T, EmailEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailEventAggregateArgs>(args: Subset<T, EmailEventAggregateArgs>): Prisma.PrismaPromise<GetEmailEventAggregateType<T>>

    /**
     * Group by EmailEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailEventGroupByArgs['orderBy'] }
        : { orderBy?: EmailEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailEvent model
   */
  readonly fields: EmailEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailEvent model
   */
  interface EmailEventFieldRefs {
    readonly id: FieldRef<"EmailEvent", 'String'>
    readonly emailId: FieldRef<"EmailEvent", 'String'>
    readonly eventType: FieldRef<"EmailEvent", 'EmailEventType'>
    readonly createdAt: FieldRef<"EmailEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailEvent findUnique
   */
  export type EmailEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where: EmailEventWhereUniqueInput
  }

  /**
   * EmailEvent findUniqueOrThrow
   */
  export type EmailEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where: EmailEventWhereUniqueInput
  }

  /**
   * EmailEvent findFirst
   */
  export type EmailEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEvents.
     */
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }

  /**
   * EmailEvent findFirstOrThrow
   */
  export type EmailEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvent to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailEvents.
     */
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }

  /**
   * EmailEvent findMany
   */
  export type EmailEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter, which EmailEvents to fetch.
     */
    where?: EmailEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailEvents to fetch.
     */
    orderBy?: EmailEventOrderByWithRelationInput | EmailEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailEvents.
     */
    cursor?: EmailEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailEvents.
     */
    skip?: number
    distinct?: EmailEventScalarFieldEnum | EmailEventScalarFieldEnum[]
  }

  /**
   * EmailEvent create
   */
  export type EmailEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailEvent.
     */
    data: XOR<EmailEventCreateInput, EmailEventUncheckedCreateInput>
  }

  /**
   * EmailEvent createMany
   */
  export type EmailEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailEvents.
     */
    data: EmailEventCreateManyInput | EmailEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailEvent createManyAndReturn
   */
  export type EmailEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * The data used to create many EmailEvents.
     */
    data: EmailEventCreateManyInput | EmailEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailEvent update
   */
  export type EmailEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailEvent.
     */
    data: XOR<EmailEventUpdateInput, EmailEventUncheckedUpdateInput>
    /**
     * Choose, which EmailEvent to update.
     */
    where: EmailEventWhereUniqueInput
  }

  /**
   * EmailEvent updateMany
   */
  export type EmailEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailEvents.
     */
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyInput>
    /**
     * Filter which EmailEvents to update
     */
    where?: EmailEventWhereInput
    /**
     * Limit how many EmailEvents to update.
     */
    limit?: number
  }

  /**
   * EmailEvent updateManyAndReturn
   */
  export type EmailEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * The data used to update EmailEvents.
     */
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyInput>
    /**
     * Filter which EmailEvents to update
     */
    where?: EmailEventWhereInput
    /**
     * Limit how many EmailEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailEvent upsert
   */
  export type EmailEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailEvent to update in case it exists.
     */
    where: EmailEventWhereUniqueInput
    /**
     * In case the EmailEvent found by the `where` argument doesn't exist, create a new EmailEvent with this data.
     */
    create: XOR<EmailEventCreateInput, EmailEventUncheckedCreateInput>
    /**
     * In case the EmailEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailEventUpdateInput, EmailEventUncheckedUpdateInput>
  }

  /**
   * EmailEvent delete
   */
  export type EmailEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
    /**
     * Filter which EmailEvent to delete.
     */
    where: EmailEventWhereUniqueInput
  }

  /**
   * EmailEvent deleteMany
   */
  export type EmailEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailEvents to delete
     */
    where?: EmailEventWhereInput
    /**
     * Limit how many EmailEvents to delete.
     */
    limit?: number
  }

  /**
   * EmailEvent without action
   */
  export type EmailEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailEvent
     */
    select?: EmailEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailEvent
     */
    omit?: EmailEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailEventInclude<ExtArgs> | null
  }


  /**
   * Model FollowUp
   */

  export type AggregateFollowUp = {
    _count: FollowUpCountAggregateOutputType | null
    _min: FollowUpMinAggregateOutputType | null
    _max: FollowUpMaxAggregateOutputType | null
  }

  export type FollowUpMinAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    emailId: string | null
    scheduledAt: Date | null
    isBounced: boolean | null
    isSpamReported: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowUpMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    emailId: string | null
    scheduledAt: Date | null
    isBounced: boolean | null
    isSpamReported: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FollowUpCountAggregateOutputType = {
    id: number
    subject: number
    body: number
    emailId: number
    scheduledAt: number
    isBounced: number
    isSpamReported: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FollowUpMinAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    emailId?: true
    scheduledAt?: true
    isBounced?: true
    isSpamReported?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowUpMaxAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    emailId?: true
    scheduledAt?: true
    isBounced?: true
    isSpamReported?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FollowUpCountAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    emailId?: true
    scheduledAt?: true
    isBounced?: true
    isSpamReported?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FollowUpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUp to aggregate.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowUps
    **/
    _count?: true | FollowUpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowUpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowUpMaxAggregateInputType
  }

  export type GetFollowUpAggregateType<T extends FollowUpAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowUp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowUp[P]>
      : GetScalarType<T[P], AggregateFollowUp[P]>
  }




  export type FollowUpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpWhereInput
    orderBy?: FollowUpOrderByWithAggregationInput | FollowUpOrderByWithAggregationInput[]
    by: FollowUpScalarFieldEnum[] | FollowUpScalarFieldEnum
    having?: FollowUpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowUpCountAggregateInputType | true
    _min?: FollowUpMinAggregateInputType
    _max?: FollowUpMaxAggregateInputType
  }

  export type FollowUpGroupByOutputType = {
    id: string
    subject: string
    body: string
    emailId: string
    scheduledAt: Date | null
    isBounced: boolean
    isSpamReported: boolean
    createdAt: Date
    updatedAt: Date
    _count: FollowUpCountAggregateOutputType | null
    _min: FollowUpMinAggregateOutputType | null
    _max: FollowUpMaxAggregateOutputType | null
  }

  type GetFollowUpGroupByPayload<T extends FollowUpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowUpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowUpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowUpGroupByOutputType[P]>
            : GetScalarType<T[P], FollowUpGroupByOutputType[P]>
        }
      >
    >


  export type FollowUpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    emailId?: boolean
    scheduledAt?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
    events?: boolean | FollowUp$eventsArgs<ExtArgs>
    _count?: boolean | FollowUpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    emailId?: boolean
    scheduledAt?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    emailId?: boolean
    scheduledAt?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectScalar = {
    id?: boolean
    subject?: boolean
    body?: boolean
    emailId?: boolean
    scheduledAt?: boolean
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FollowUpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "body" | "emailId" | "scheduledAt" | "isBounced" | "isSpamReported" | "createdAt" | "updatedAt", ExtArgs["result"]["followUp"]>
  export type FollowUpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
    events?: boolean | FollowUp$eventsArgs<ExtArgs>
    _count?: boolean | FollowUpCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FollowUpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type FollowUpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $FollowUpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowUp"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
      events: Prisma.$FollowUpEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string
      body: string
      emailId: string
      scheduledAt: Date | null
      isBounced: boolean
      isSpamReported: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["followUp"]>
    composites: {}
  }

  type FollowUpGetPayload<S extends boolean | null | undefined | FollowUpDefaultArgs> = $Result.GetResult<Prisma.$FollowUpPayload, S>

  type FollowUpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowUpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowUpCountAggregateInputType | true
    }

  export interface FollowUpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowUp'], meta: { name: 'FollowUp' } }
    /**
     * Find zero or one FollowUp that matches the filter.
     * @param {FollowUpFindUniqueArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowUpFindUniqueArgs>(args: SelectSubset<T, FollowUpFindUniqueArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowUp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowUpFindUniqueOrThrowArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowUpFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowUpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindFirstArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowUpFindFirstArgs>(args?: SelectSubset<T, FollowUpFindFirstArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindFirstOrThrowArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowUpFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowUpFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowUps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowUps
     * const followUps = await prisma.followUp.findMany()
     * 
     * // Get first 10 FollowUps
     * const followUps = await prisma.followUp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followUpWithIdOnly = await prisma.followUp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowUpFindManyArgs>(args?: SelectSubset<T, FollowUpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowUp.
     * @param {FollowUpCreateArgs} args - Arguments to create a FollowUp.
     * @example
     * // Create one FollowUp
     * const FollowUp = await prisma.followUp.create({
     *   data: {
     *     // ... data to create a FollowUp
     *   }
     * })
     * 
     */
    create<T extends FollowUpCreateArgs>(args: SelectSubset<T, FollowUpCreateArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowUps.
     * @param {FollowUpCreateManyArgs} args - Arguments to create many FollowUps.
     * @example
     * // Create many FollowUps
     * const followUp = await prisma.followUp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowUpCreateManyArgs>(args?: SelectSubset<T, FollowUpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowUps and returns the data saved in the database.
     * @param {FollowUpCreateManyAndReturnArgs} args - Arguments to create many FollowUps.
     * @example
     * // Create many FollowUps
     * const followUp = await prisma.followUp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowUps and only return the `id`
     * const followUpWithIdOnly = await prisma.followUp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowUpCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowUpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowUp.
     * @param {FollowUpDeleteArgs} args - Arguments to delete one FollowUp.
     * @example
     * // Delete one FollowUp
     * const FollowUp = await prisma.followUp.delete({
     *   where: {
     *     // ... filter to delete one FollowUp
     *   }
     * })
     * 
     */
    delete<T extends FollowUpDeleteArgs>(args: SelectSubset<T, FollowUpDeleteArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowUp.
     * @param {FollowUpUpdateArgs} args - Arguments to update one FollowUp.
     * @example
     * // Update one FollowUp
     * const followUp = await prisma.followUp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpUpdateArgs>(args: SelectSubset<T, FollowUpUpdateArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowUps.
     * @param {FollowUpDeleteManyArgs} args - Arguments to filter FollowUps to delete.
     * @example
     * // Delete a few FollowUps
     * const { count } = await prisma.followUp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowUpDeleteManyArgs>(args?: SelectSubset<T, FollowUpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowUps
     * const followUp = await prisma.followUp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpUpdateManyArgs>(args: SelectSubset<T, FollowUpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUps and returns the data updated in the database.
     * @param {FollowUpUpdateManyAndReturnArgs} args - Arguments to update many FollowUps.
     * @example
     * // Update many FollowUps
     * const followUp = await prisma.followUp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowUps and only return the `id`
     * const followUpWithIdOnly = await prisma.followUp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowUp.
     * @param {FollowUpUpsertArgs} args - Arguments to update or create a FollowUp.
     * @example
     * // Update or create a FollowUp
     * const followUp = await prisma.followUp.upsert({
     *   create: {
     *     // ... data to create a FollowUp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowUp we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpUpsertArgs>(args: SelectSubset<T, FollowUpUpsertArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpCountArgs} args - Arguments to filter FollowUps to count.
     * @example
     * // Count the number of FollowUps
     * const count = await prisma.followUp.count({
     *   where: {
     *     // ... the filter for the FollowUps we want to count
     *   }
     * })
    **/
    count<T extends FollowUpCountArgs>(
      args?: Subset<T, FollowUpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowUpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowUpAggregateArgs>(args: Subset<T, FollowUpAggregateArgs>): Prisma.PrismaPromise<GetFollowUpAggregateType<T>>

    /**
     * Group by FollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowUpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowUpGroupByArgs['orderBy'] }
        : { orderBy?: FollowUpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowUpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowUpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowUp model
   */
  readonly fields: FollowUpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowUp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowUpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    events<T extends FollowUp$eventsArgs<ExtArgs> = {}>(args?: Subset<T, FollowUp$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowUp model
   */
  interface FollowUpFieldRefs {
    readonly id: FieldRef<"FollowUp", 'String'>
    readonly subject: FieldRef<"FollowUp", 'String'>
    readonly body: FieldRef<"FollowUp", 'String'>
    readonly emailId: FieldRef<"FollowUp", 'String'>
    readonly scheduledAt: FieldRef<"FollowUp", 'DateTime'>
    readonly isBounced: FieldRef<"FollowUp", 'Boolean'>
    readonly isSpamReported: FieldRef<"FollowUp", 'Boolean'>
    readonly createdAt: FieldRef<"FollowUp", 'DateTime'>
    readonly updatedAt: FieldRef<"FollowUp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FollowUp findUnique
   */
  export type FollowUpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp findUniqueOrThrow
   */
  export type FollowUpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp findFirst
   */
  export type FollowUpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUps.
     */
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp findFirstOrThrow
   */
  export type FollowUpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUps.
     */
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp findMany
   */
  export type FollowUpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUps to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp create
   */
  export type FollowUpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowUp.
     */
    data: XOR<FollowUpCreateInput, FollowUpUncheckedCreateInput>
  }

  /**
   * FollowUp createMany
   */
  export type FollowUpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowUps.
     */
    data: FollowUpCreateManyInput | FollowUpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowUp createManyAndReturn
   */
  export type FollowUpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * The data used to create many FollowUps.
     */
    data: FollowUpCreateManyInput | FollowUpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUp update
   */
  export type FollowUpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowUp.
     */
    data: XOR<FollowUpUpdateInput, FollowUpUncheckedUpdateInput>
    /**
     * Choose, which FollowUp to update.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp updateMany
   */
  export type FollowUpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowUps.
     */
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyInput>
    /**
     * Filter which FollowUps to update
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to update.
     */
    limit?: number
  }

  /**
   * FollowUp updateManyAndReturn
   */
  export type FollowUpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * The data used to update FollowUps.
     */
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyInput>
    /**
     * Filter which FollowUps to update
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUp upsert
   */
  export type FollowUpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowUp to update in case it exists.
     */
    where: FollowUpWhereUniqueInput
    /**
     * In case the FollowUp found by the `where` argument doesn't exist, create a new FollowUp with this data.
     */
    create: XOR<FollowUpCreateInput, FollowUpUncheckedCreateInput>
    /**
     * In case the FollowUp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpUpdateInput, FollowUpUncheckedUpdateInput>
  }

  /**
   * FollowUp delete
   */
  export type FollowUpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter which FollowUp to delete.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp deleteMany
   */
  export type FollowUpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUps to delete
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to delete.
     */
    limit?: number
  }

  /**
   * FollowUp.events
   */
  export type FollowUp$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    where?: FollowUpEventWhereInput
    orderBy?: FollowUpEventOrderByWithRelationInput | FollowUpEventOrderByWithRelationInput[]
    cursor?: FollowUpEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowUpEventScalarFieldEnum | FollowUpEventScalarFieldEnum[]
  }

  /**
   * FollowUp without action
   */
  export type FollowUpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
  }


  /**
   * Model FollowUpEvent
   */

  export type AggregateFollowUpEvent = {
    _count: FollowUpEventCountAggregateOutputType | null
    _min: FollowUpEventMinAggregateOutputType | null
    _max: FollowUpEventMaxAggregateOutputType | null
  }

  export type FollowUpEventMinAggregateOutputType = {
    id: string | null
    followUpId: string | null
    eventType: $Enums.EmailEventType | null
    createdAt: Date | null
  }

  export type FollowUpEventMaxAggregateOutputType = {
    id: string | null
    followUpId: string | null
    eventType: $Enums.EmailEventType | null
    createdAt: Date | null
  }

  export type FollowUpEventCountAggregateOutputType = {
    id: number
    followUpId: number
    eventType: number
    createdAt: number
    _all: number
  }


  export type FollowUpEventMinAggregateInputType = {
    id?: true
    followUpId?: true
    eventType?: true
    createdAt?: true
  }

  export type FollowUpEventMaxAggregateInputType = {
    id?: true
    followUpId?: true
    eventType?: true
    createdAt?: true
  }

  export type FollowUpEventCountAggregateInputType = {
    id?: true
    followUpId?: true
    eventType?: true
    createdAt?: true
    _all?: true
  }

  export type FollowUpEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpEvent to aggregate.
     */
    where?: FollowUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEvents to fetch.
     */
    orderBy?: FollowUpEventOrderByWithRelationInput | FollowUpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowUpEvents
    **/
    _count?: true | FollowUpEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowUpEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowUpEventMaxAggregateInputType
  }

  export type GetFollowUpEventAggregateType<T extends FollowUpEventAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowUpEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowUpEvent[P]>
      : GetScalarType<T[P], AggregateFollowUpEvent[P]>
  }




  export type FollowUpEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpEventWhereInput
    orderBy?: FollowUpEventOrderByWithAggregationInput | FollowUpEventOrderByWithAggregationInput[]
    by: FollowUpEventScalarFieldEnum[] | FollowUpEventScalarFieldEnum
    having?: FollowUpEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowUpEventCountAggregateInputType | true
    _min?: FollowUpEventMinAggregateInputType
    _max?: FollowUpEventMaxAggregateInputType
  }

  export type FollowUpEventGroupByOutputType = {
    id: string
    followUpId: string
    eventType: $Enums.EmailEventType
    createdAt: Date
    _count: FollowUpEventCountAggregateOutputType | null
    _min: FollowUpEventMinAggregateOutputType | null
    _max: FollowUpEventMaxAggregateOutputType | null
  }

  type GetFollowUpEventGroupByPayload<T extends FollowUpEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowUpEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowUpEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowUpEventGroupByOutputType[P]>
            : GetScalarType<T[P], FollowUpEventGroupByOutputType[P]>
        }
      >
    >


  export type FollowUpEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followUpId?: boolean
    eventType?: boolean
    createdAt?: boolean
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpEvent"]>

  export type FollowUpEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followUpId?: boolean
    eventType?: boolean
    createdAt?: boolean
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpEvent"]>

  export type FollowUpEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followUpId?: boolean
    eventType?: boolean
    createdAt?: boolean
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUpEvent"]>

  export type FollowUpEventSelectScalar = {
    id?: boolean
    followUpId?: boolean
    eventType?: boolean
    createdAt?: boolean
  }

  export type FollowUpEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followUpId" | "eventType" | "createdAt", ExtArgs["result"]["followUpEvent"]>
  export type FollowUpEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }
  export type FollowUpEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }
  export type FollowUpEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FollowUp?: boolean | FollowUpDefaultArgs<ExtArgs>
  }

  export type $FollowUpEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowUpEvent"
    objects: {
      FollowUp: Prisma.$FollowUpPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followUpId: string
      eventType: $Enums.EmailEventType
      createdAt: Date
    }, ExtArgs["result"]["followUpEvent"]>
    composites: {}
  }

  type FollowUpEventGetPayload<S extends boolean | null | undefined | FollowUpEventDefaultArgs> = $Result.GetResult<Prisma.$FollowUpEventPayload, S>

  type FollowUpEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowUpEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowUpEventCountAggregateInputType | true
    }

  export interface FollowUpEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowUpEvent'], meta: { name: 'FollowUpEvent' } }
    /**
     * Find zero or one FollowUpEvent that matches the filter.
     * @param {FollowUpEventFindUniqueArgs} args - Arguments to find a FollowUpEvent
     * @example
     * // Get one FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowUpEventFindUniqueArgs>(args: SelectSubset<T, FollowUpEventFindUniqueArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowUpEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowUpEventFindUniqueOrThrowArgs} args - Arguments to find a FollowUpEvent
     * @example
     * // Get one FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowUpEventFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowUpEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUpEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventFindFirstArgs} args - Arguments to find a FollowUpEvent
     * @example
     * // Get one FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowUpEventFindFirstArgs>(args?: SelectSubset<T, FollowUpEventFindFirstArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUpEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventFindFirstOrThrowArgs} args - Arguments to find a FollowUpEvent
     * @example
     * // Get one FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowUpEventFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowUpEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowUpEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowUpEvents
     * const followUpEvents = await prisma.followUpEvent.findMany()
     * 
     * // Get first 10 FollowUpEvents
     * const followUpEvents = await prisma.followUpEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followUpEventWithIdOnly = await prisma.followUpEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowUpEventFindManyArgs>(args?: SelectSubset<T, FollowUpEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowUpEvent.
     * @param {FollowUpEventCreateArgs} args - Arguments to create a FollowUpEvent.
     * @example
     * // Create one FollowUpEvent
     * const FollowUpEvent = await prisma.followUpEvent.create({
     *   data: {
     *     // ... data to create a FollowUpEvent
     *   }
     * })
     * 
     */
    create<T extends FollowUpEventCreateArgs>(args: SelectSubset<T, FollowUpEventCreateArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowUpEvents.
     * @param {FollowUpEventCreateManyArgs} args - Arguments to create many FollowUpEvents.
     * @example
     * // Create many FollowUpEvents
     * const followUpEvent = await prisma.followUpEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowUpEventCreateManyArgs>(args?: SelectSubset<T, FollowUpEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowUpEvents and returns the data saved in the database.
     * @param {FollowUpEventCreateManyAndReturnArgs} args - Arguments to create many FollowUpEvents.
     * @example
     * // Create many FollowUpEvents
     * const followUpEvent = await prisma.followUpEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowUpEvents and only return the `id`
     * const followUpEventWithIdOnly = await prisma.followUpEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowUpEventCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowUpEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowUpEvent.
     * @param {FollowUpEventDeleteArgs} args - Arguments to delete one FollowUpEvent.
     * @example
     * // Delete one FollowUpEvent
     * const FollowUpEvent = await prisma.followUpEvent.delete({
     *   where: {
     *     // ... filter to delete one FollowUpEvent
     *   }
     * })
     * 
     */
    delete<T extends FollowUpEventDeleteArgs>(args: SelectSubset<T, FollowUpEventDeleteArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowUpEvent.
     * @param {FollowUpEventUpdateArgs} args - Arguments to update one FollowUpEvent.
     * @example
     * // Update one FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpEventUpdateArgs>(args: SelectSubset<T, FollowUpEventUpdateArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowUpEvents.
     * @param {FollowUpEventDeleteManyArgs} args - Arguments to filter FollowUpEvents to delete.
     * @example
     * // Delete a few FollowUpEvents
     * const { count } = await prisma.followUpEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowUpEventDeleteManyArgs>(args?: SelectSubset<T, FollowUpEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowUpEvents
     * const followUpEvent = await prisma.followUpEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpEventUpdateManyArgs>(args: SelectSubset<T, FollowUpEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUpEvents and returns the data updated in the database.
     * @param {FollowUpEventUpdateManyAndReturnArgs} args - Arguments to update many FollowUpEvents.
     * @example
     * // Update many FollowUpEvents
     * const followUpEvent = await prisma.followUpEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowUpEvents and only return the `id`
     * const followUpEventWithIdOnly = await prisma.followUpEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpEventUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowUpEvent.
     * @param {FollowUpEventUpsertArgs} args - Arguments to update or create a FollowUpEvent.
     * @example
     * // Update or create a FollowUpEvent
     * const followUpEvent = await prisma.followUpEvent.upsert({
     *   create: {
     *     // ... data to create a FollowUpEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowUpEvent we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpEventUpsertArgs>(args: SelectSubset<T, FollowUpEventUpsertArgs<ExtArgs>>): Prisma__FollowUpEventClient<$Result.GetResult<Prisma.$FollowUpEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowUpEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventCountArgs} args - Arguments to filter FollowUpEvents to count.
     * @example
     * // Count the number of FollowUpEvents
     * const count = await prisma.followUpEvent.count({
     *   where: {
     *     // ... the filter for the FollowUpEvents we want to count
     *   }
     * })
    **/
    count<T extends FollowUpEventCountArgs>(
      args?: Subset<T, FollowUpEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowUpEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowUpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowUpEventAggregateArgs>(args: Subset<T, FollowUpEventAggregateArgs>): Prisma.PrismaPromise<GetFollowUpEventAggregateType<T>>

    /**
     * Group by FollowUpEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowUpEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowUpEventGroupByArgs['orderBy'] }
        : { orderBy?: FollowUpEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowUpEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowUpEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowUpEvent model
   */
  readonly fields: FollowUpEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowUpEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowUpEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FollowUp<T extends FollowUpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FollowUpDefaultArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowUpEvent model
   */
  interface FollowUpEventFieldRefs {
    readonly id: FieldRef<"FollowUpEvent", 'String'>
    readonly followUpId: FieldRef<"FollowUpEvent", 'String'>
    readonly eventType: FieldRef<"FollowUpEvent", 'EmailEventType'>
    readonly createdAt: FieldRef<"FollowUpEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FollowUpEvent findUnique
   */
  export type FollowUpEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEvent to fetch.
     */
    where: FollowUpEventWhereUniqueInput
  }

  /**
   * FollowUpEvent findUniqueOrThrow
   */
  export type FollowUpEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEvent to fetch.
     */
    where: FollowUpEventWhereUniqueInput
  }

  /**
   * FollowUpEvent findFirst
   */
  export type FollowUpEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEvent to fetch.
     */
    where?: FollowUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEvents to fetch.
     */
    orderBy?: FollowUpEventOrderByWithRelationInput | FollowUpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpEvents.
     */
    cursor?: FollowUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpEvents.
     */
    distinct?: FollowUpEventScalarFieldEnum | FollowUpEventScalarFieldEnum[]
  }

  /**
   * FollowUpEvent findFirstOrThrow
   */
  export type FollowUpEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEvent to fetch.
     */
    where?: FollowUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEvents to fetch.
     */
    orderBy?: FollowUpEventOrderByWithRelationInput | FollowUpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUpEvents.
     */
    cursor?: FollowUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUpEvents.
     */
    distinct?: FollowUpEventScalarFieldEnum | FollowUpEventScalarFieldEnum[]
  }

  /**
   * FollowUpEvent findMany
   */
  export type FollowUpEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter, which FollowUpEvents to fetch.
     */
    where?: FollowUpEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUpEvents to fetch.
     */
    orderBy?: FollowUpEventOrderByWithRelationInput | FollowUpEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowUpEvents.
     */
    cursor?: FollowUpEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUpEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUpEvents.
     */
    skip?: number
    distinct?: FollowUpEventScalarFieldEnum | FollowUpEventScalarFieldEnum[]
  }

  /**
   * FollowUpEvent create
   */
  export type FollowUpEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowUpEvent.
     */
    data: XOR<FollowUpEventCreateInput, FollowUpEventUncheckedCreateInput>
  }

  /**
   * FollowUpEvent createMany
   */
  export type FollowUpEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowUpEvents.
     */
    data: FollowUpEventCreateManyInput | FollowUpEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowUpEvent createManyAndReturn
   */
  export type FollowUpEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * The data used to create many FollowUpEvents.
     */
    data: FollowUpEventCreateManyInput | FollowUpEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUpEvent update
   */
  export type FollowUpEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowUpEvent.
     */
    data: XOR<FollowUpEventUpdateInput, FollowUpEventUncheckedUpdateInput>
    /**
     * Choose, which FollowUpEvent to update.
     */
    where: FollowUpEventWhereUniqueInput
  }

  /**
   * FollowUpEvent updateMany
   */
  export type FollowUpEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowUpEvents.
     */
    data: XOR<FollowUpEventUpdateManyMutationInput, FollowUpEventUncheckedUpdateManyInput>
    /**
     * Filter which FollowUpEvents to update
     */
    where?: FollowUpEventWhereInput
    /**
     * Limit how many FollowUpEvents to update.
     */
    limit?: number
  }

  /**
   * FollowUpEvent updateManyAndReturn
   */
  export type FollowUpEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * The data used to update FollowUpEvents.
     */
    data: XOR<FollowUpEventUpdateManyMutationInput, FollowUpEventUncheckedUpdateManyInput>
    /**
     * Filter which FollowUpEvents to update
     */
    where?: FollowUpEventWhereInput
    /**
     * Limit how many FollowUpEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUpEvent upsert
   */
  export type FollowUpEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowUpEvent to update in case it exists.
     */
    where: FollowUpEventWhereUniqueInput
    /**
     * In case the FollowUpEvent found by the `where` argument doesn't exist, create a new FollowUpEvent with this data.
     */
    create: XOR<FollowUpEventCreateInput, FollowUpEventUncheckedCreateInput>
    /**
     * In case the FollowUpEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpEventUpdateInput, FollowUpEventUncheckedUpdateInput>
  }

  /**
   * FollowUpEvent delete
   */
  export type FollowUpEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
    /**
     * Filter which FollowUpEvent to delete.
     */
    where: FollowUpEventWhereUniqueInput
  }

  /**
   * FollowUpEvent deleteMany
   */
  export type FollowUpEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUpEvents to delete
     */
    where?: FollowUpEventWhereInput
    /**
     * Limit how many FollowUpEvents to delete.
     */
    limit?: number
  }

  /**
   * FollowUpEvent without action
   */
  export type FollowUpEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUpEvent
     */
    select?: FollowUpEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUpEvent
     */
    omit?: FollowUpEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpEventInclude<ExtArgs> | null
  }


  /**
   * Model Draft
   */

  export type AggregateDraft = {
    _count: DraftCountAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  export type DraftMinAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    scheduledAt: Date | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DraftMaxAggregateOutputType = {
    id: string | null
    subject: string | null
    body: string | null
    scheduledAt: Date | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DraftCountAggregateOutputType = {
    id: number
    subject: number
    body: number
    scheduledAt: number
    senderId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DraftMinAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    scheduledAt?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DraftMaxAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    scheduledAt?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DraftCountAggregateInputType = {
    id?: true
    subject?: true
    body?: true
    scheduledAt?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Draft to aggregate.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drafts
    **/
    _count?: true | DraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftMaxAggregateInputType
  }

  export type GetDraftAggregateType<T extends DraftAggregateArgs> = {
        [P in keyof T & keyof AggregateDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraft[P]>
      : GetScalarType<T[P], AggregateDraft[P]>
  }




  export type DraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithAggregationInput | DraftOrderByWithAggregationInput[]
    by: DraftScalarFieldEnum[] | DraftScalarFieldEnum
    having?: DraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftCountAggregateInputType | true
    _min?: DraftMinAggregateInputType
    _max?: DraftMaxAggregateInputType
  }

  export type DraftGroupByOutputType = {
    id: string
    subject: string | null
    body: string | null
    scheduledAt: Date | null
    senderId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DraftCountAggregateOutputType | null
    _min: DraftMinAggregateOutputType | null
    _max: DraftMaxAggregateOutputType | null
  }

  type GetDraftGroupByPayload<T extends DraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftGroupByOutputType[P]>
            : GetScalarType<T[P], DraftGroupByOutputType[P]>
        }
      >
    >


  export type DraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | Draft$senderArgs<ExtArgs>
    draftContacts?: boolean | Draft$draftContactsArgs<ExtArgs>
    draftTags?: boolean | Draft$draftTagsArgs<ExtArgs>
    _count?: boolean | DraftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | Draft$senderArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | Draft$senderArgs<ExtArgs>
  }, ExtArgs["result"]["draft"]>

  export type DraftSelectScalar = {
    id?: boolean
    subject?: boolean
    body?: boolean
    scheduledAt?: boolean
    senderId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subject" | "body" | "scheduledAt" | "senderId" | "createdAt" | "updatedAt", ExtArgs["result"]["draft"]>
  export type DraftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Draft$senderArgs<ExtArgs>
    draftContacts?: boolean | Draft$draftContactsArgs<ExtArgs>
    draftTags?: boolean | Draft$draftTagsArgs<ExtArgs>
    _count?: boolean | DraftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DraftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Draft$senderArgs<ExtArgs>
  }
  export type DraftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Draft$senderArgs<ExtArgs>
  }

  export type $DraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Draft"
    objects: {
      sender: Prisma.$SenderPayload<ExtArgs> | null
      draftContacts: Prisma.$DraftContactPayload<ExtArgs>[]
      draftTags: Prisma.$DraftTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subject: string | null
      body: string | null
      scheduledAt: Date | null
      senderId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["draft"]>
    composites: {}
  }

  type DraftGetPayload<S extends boolean | null | undefined | DraftDefaultArgs> = $Result.GetResult<Prisma.$DraftPayload, S>

  type DraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DraftCountAggregateInputType | true
    }

  export interface DraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Draft'], meta: { name: 'Draft' } }
    /**
     * Find zero or one Draft that matches the filter.
     * @param {DraftFindUniqueArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftFindUniqueArgs>(args: SelectSubset<T, DraftFindUniqueArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Draft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftFindUniqueOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Draft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftFindFirstArgs>(args?: SelectSubset<T, DraftFindFirstArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Draft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindFirstOrThrowArgs} args - Arguments to find a Draft
     * @example
     * // Get one Draft
     * const draft = await prisma.draft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drafts
     * const drafts = await prisma.draft.findMany()
     * 
     * // Get first 10 Drafts
     * const drafts = await prisma.draft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const draftWithIdOnly = await prisma.draft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DraftFindManyArgs>(args?: SelectSubset<T, DraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Draft.
     * @param {DraftCreateArgs} args - Arguments to create a Draft.
     * @example
     * // Create one Draft
     * const Draft = await prisma.draft.create({
     *   data: {
     *     // ... data to create a Draft
     *   }
     * })
     * 
     */
    create<T extends DraftCreateArgs>(args: SelectSubset<T, DraftCreateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drafts.
     * @param {DraftCreateManyArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftCreateManyArgs>(args?: SelectSubset<T, DraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drafts and returns the data saved in the database.
     * @param {DraftCreateManyAndReturnArgs} args - Arguments to create many Drafts.
     * @example
     * // Create many Drafts
     * const draft = await prisma.draft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drafts and only return the `id`
     * const draftWithIdOnly = await prisma.draft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Draft.
     * @param {DraftDeleteArgs} args - Arguments to delete one Draft.
     * @example
     * // Delete one Draft
     * const Draft = await prisma.draft.delete({
     *   where: {
     *     // ... filter to delete one Draft
     *   }
     * })
     * 
     */
    delete<T extends DraftDeleteArgs>(args: SelectSubset<T, DraftDeleteArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Draft.
     * @param {DraftUpdateArgs} args - Arguments to update one Draft.
     * @example
     * // Update one Draft
     * const draft = await prisma.draft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftUpdateArgs>(args: SelectSubset<T, DraftUpdateArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drafts.
     * @param {DraftDeleteManyArgs} args - Arguments to filter Drafts to delete.
     * @example
     * // Delete a few Drafts
     * const { count } = await prisma.draft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftDeleteManyArgs>(args?: SelectSubset<T, DraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drafts
     * const draft = await prisma.draft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftUpdateManyArgs>(args: SelectSubset<T, DraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drafts and returns the data updated in the database.
     * @param {DraftUpdateManyAndReturnArgs} args - Arguments to update many Drafts.
     * @example
     * // Update many Drafts
     * const draft = await prisma.draft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drafts and only return the `id`
     * const draftWithIdOnly = await prisma.draft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DraftUpdateManyAndReturnArgs>(args: SelectSubset<T, DraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Draft.
     * @param {DraftUpsertArgs} args - Arguments to update or create a Draft.
     * @example
     * // Update or create a Draft
     * const draft = await prisma.draft.upsert({
     *   create: {
     *     // ... data to create a Draft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Draft we want to update
     *   }
     * })
     */
    upsert<T extends DraftUpsertArgs>(args: SelectSubset<T, DraftUpsertArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftCountArgs} args - Arguments to filter Drafts to count.
     * @example
     * // Count the number of Drafts
     * const count = await prisma.draft.count({
     *   where: {
     *     // ... the filter for the Drafts we want to count
     *   }
     * })
    **/
    count<T extends DraftCountArgs>(
      args?: Subset<T, DraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftAggregateArgs>(args: Subset<T, DraftAggregateArgs>): Prisma.PrismaPromise<GetDraftAggregateType<T>>

    /**
     * Group by Draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftGroupByArgs['orderBy'] }
        : { orderBy?: DraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Draft model
   */
  readonly fields: DraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Draft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends Draft$senderArgs<ExtArgs> = {}>(args?: Subset<T, Draft$senderArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    draftContacts<T extends Draft$draftContactsArgs<ExtArgs> = {}>(args?: Subset<T, Draft$draftContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    draftTags<T extends Draft$draftTagsArgs<ExtArgs> = {}>(args?: Subset<T, Draft$draftTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Draft model
   */
  interface DraftFieldRefs {
    readonly id: FieldRef<"Draft", 'String'>
    readonly subject: FieldRef<"Draft", 'String'>
    readonly body: FieldRef<"Draft", 'String'>
    readonly scheduledAt: FieldRef<"Draft", 'DateTime'>
    readonly senderId: FieldRef<"Draft", 'String'>
    readonly createdAt: FieldRef<"Draft", 'DateTime'>
    readonly updatedAt: FieldRef<"Draft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Draft findUnique
   */
  export type DraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findUniqueOrThrow
   */
  export type DraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft findFirst
   */
  export type DraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findFirstOrThrow
   */
  export type DraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Draft to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drafts.
     */
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft findMany
   */
  export type DraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter, which Drafts to fetch.
     */
    where?: DraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drafts to fetch.
     */
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drafts.
     */
    cursor?: DraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drafts.
     */
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Draft create
   */
  export type DraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to create a Draft.
     */
    data: XOR<DraftCreateInput, DraftUncheckedCreateInput>
  }

  /**
   * Draft createMany
   */
  export type DraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Draft createManyAndReturn
   */
  export type DraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * The data used to create many Drafts.
     */
    data: DraftCreateManyInput | DraftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Draft update
   */
  export type DraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The data needed to update a Draft.
     */
    data: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
    /**
     * Choose, which Draft to update.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft updateMany
   */
  export type DraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drafts.
     */
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyInput>
    /**
     * Filter which Drafts to update
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to update.
     */
    limit?: number
  }

  /**
   * Draft updateManyAndReturn
   */
  export type DraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * The data used to update Drafts.
     */
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyInput>
    /**
     * Filter which Drafts to update
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Draft upsert
   */
  export type DraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * The filter to search for the Draft to update in case it exists.
     */
    where: DraftWhereUniqueInput
    /**
     * In case the Draft found by the `where` argument doesn't exist, create a new Draft with this data.
     */
    create: XOR<DraftCreateInput, DraftUncheckedCreateInput>
    /**
     * In case the Draft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftUpdateInput, DraftUncheckedUpdateInput>
  }

  /**
   * Draft delete
   */
  export type DraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    /**
     * Filter which Draft to delete.
     */
    where: DraftWhereUniqueInput
  }

  /**
   * Draft deleteMany
   */
  export type DraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drafts to delete
     */
    where?: DraftWhereInput
    /**
     * Limit how many Drafts to delete.
     */
    limit?: number
  }

  /**
   * Draft.sender
   */
  export type Draft$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    where?: SenderWhereInput
  }

  /**
   * Draft.draftContacts
   */
  export type Draft$draftContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    where?: DraftContactWhereInput
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    cursor?: DraftContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftContactScalarFieldEnum | DraftContactScalarFieldEnum[]
  }

  /**
   * Draft.draftTags
   */
  export type Draft$draftTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    where?: DraftTagWhereInput
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    cursor?: DraftTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftTagScalarFieldEnum | DraftTagScalarFieldEnum[]
  }

  /**
   * Draft without action
   */
  export type DraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
  }


  /**
   * Model DraftContact
   */

  export type AggregateDraftContact = {
    _count: DraftContactCountAggregateOutputType | null
    _min: DraftContactMinAggregateOutputType | null
    _max: DraftContactMaxAggregateOutputType | null
  }

  export type DraftContactMinAggregateOutputType = {
    draftId: string | null
    contactId: string | null
  }

  export type DraftContactMaxAggregateOutputType = {
    draftId: string | null
    contactId: string | null
  }

  export type DraftContactCountAggregateOutputType = {
    draftId: number
    contactId: number
    _all: number
  }


  export type DraftContactMinAggregateInputType = {
    draftId?: true
    contactId?: true
  }

  export type DraftContactMaxAggregateInputType = {
    draftId?: true
    contactId?: true
  }

  export type DraftContactCountAggregateInputType = {
    draftId?: true
    contactId?: true
    _all?: true
  }

  export type DraftContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftContact to aggregate.
     */
    where?: DraftContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftContacts to fetch.
     */
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DraftContacts
    **/
    _count?: true | DraftContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftContactMaxAggregateInputType
  }

  export type GetDraftContactAggregateType<T extends DraftContactAggregateArgs> = {
        [P in keyof T & keyof AggregateDraftContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraftContact[P]>
      : GetScalarType<T[P], AggregateDraftContact[P]>
  }




  export type DraftContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftContactWhereInput
    orderBy?: DraftContactOrderByWithAggregationInput | DraftContactOrderByWithAggregationInput[]
    by: DraftContactScalarFieldEnum[] | DraftContactScalarFieldEnum
    having?: DraftContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftContactCountAggregateInputType | true
    _min?: DraftContactMinAggregateInputType
    _max?: DraftContactMaxAggregateInputType
  }

  export type DraftContactGroupByOutputType = {
    draftId: string
    contactId: string
    _count: DraftContactCountAggregateOutputType | null
    _min: DraftContactMinAggregateOutputType | null
    _max: DraftContactMaxAggregateOutputType | null
  }

  type GetDraftContactGroupByPayload<T extends DraftContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftContactGroupByOutputType[P]>
            : GetScalarType<T[P], DraftContactGroupByOutputType[P]>
        }
      >
    >


  export type DraftContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    contactId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftContact"]>

  export type DraftContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    contactId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftContact"]>

  export type DraftContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    contactId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftContact"]>

  export type DraftContactSelectScalar = {
    draftId?: boolean
    contactId?: boolean
  }

  export type DraftContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"draftId" | "contactId", ExtArgs["result"]["draftContact"]>
  export type DraftContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type DraftContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }
  export type DraftContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $DraftContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DraftContact"
    objects: {
      draft: Prisma.$DraftPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      draftId: string
      contactId: string
    }, ExtArgs["result"]["draftContact"]>
    composites: {}
  }

  type DraftContactGetPayload<S extends boolean | null | undefined | DraftContactDefaultArgs> = $Result.GetResult<Prisma.$DraftContactPayload, S>

  type DraftContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DraftContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DraftContactCountAggregateInputType | true
    }

  export interface DraftContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DraftContact'], meta: { name: 'DraftContact' } }
    /**
     * Find zero or one DraftContact that matches the filter.
     * @param {DraftContactFindUniqueArgs} args - Arguments to find a DraftContact
     * @example
     * // Get one DraftContact
     * const draftContact = await prisma.draftContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftContactFindUniqueArgs>(args: SelectSubset<T, DraftContactFindUniqueArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DraftContact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftContactFindUniqueOrThrowArgs} args - Arguments to find a DraftContact
     * @example
     * // Get one DraftContact
     * const draftContact = await prisma.draftContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftContactFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactFindFirstArgs} args - Arguments to find a DraftContact
     * @example
     * // Get one DraftContact
     * const draftContact = await prisma.draftContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftContactFindFirstArgs>(args?: SelectSubset<T, DraftContactFindFirstArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactFindFirstOrThrowArgs} args - Arguments to find a DraftContact
     * @example
     * // Get one DraftContact
     * const draftContact = await prisma.draftContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftContactFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DraftContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DraftContacts
     * const draftContacts = await prisma.draftContact.findMany()
     * 
     * // Get first 10 DraftContacts
     * const draftContacts = await prisma.draftContact.findMany({ take: 10 })
     * 
     * // Only select the `draftId`
     * const draftContactWithDraftIdOnly = await prisma.draftContact.findMany({ select: { draftId: true } })
     * 
     */
    findMany<T extends DraftContactFindManyArgs>(args?: SelectSubset<T, DraftContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DraftContact.
     * @param {DraftContactCreateArgs} args - Arguments to create a DraftContact.
     * @example
     * // Create one DraftContact
     * const DraftContact = await prisma.draftContact.create({
     *   data: {
     *     // ... data to create a DraftContact
     *   }
     * })
     * 
     */
    create<T extends DraftContactCreateArgs>(args: SelectSubset<T, DraftContactCreateArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DraftContacts.
     * @param {DraftContactCreateManyArgs} args - Arguments to create many DraftContacts.
     * @example
     * // Create many DraftContacts
     * const draftContact = await prisma.draftContact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftContactCreateManyArgs>(args?: SelectSubset<T, DraftContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DraftContacts and returns the data saved in the database.
     * @param {DraftContactCreateManyAndReturnArgs} args - Arguments to create many DraftContacts.
     * @example
     * // Create many DraftContacts
     * const draftContact = await prisma.draftContact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DraftContacts and only return the `draftId`
     * const draftContactWithDraftIdOnly = await prisma.draftContact.createManyAndReturn({
     *   select: { draftId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftContactCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DraftContact.
     * @param {DraftContactDeleteArgs} args - Arguments to delete one DraftContact.
     * @example
     * // Delete one DraftContact
     * const DraftContact = await prisma.draftContact.delete({
     *   where: {
     *     // ... filter to delete one DraftContact
     *   }
     * })
     * 
     */
    delete<T extends DraftContactDeleteArgs>(args: SelectSubset<T, DraftContactDeleteArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DraftContact.
     * @param {DraftContactUpdateArgs} args - Arguments to update one DraftContact.
     * @example
     * // Update one DraftContact
     * const draftContact = await prisma.draftContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftContactUpdateArgs>(args: SelectSubset<T, DraftContactUpdateArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DraftContacts.
     * @param {DraftContactDeleteManyArgs} args - Arguments to filter DraftContacts to delete.
     * @example
     * // Delete a few DraftContacts
     * const { count } = await prisma.draftContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftContactDeleteManyArgs>(args?: SelectSubset<T, DraftContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DraftContacts
     * const draftContact = await prisma.draftContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftContactUpdateManyArgs>(args: SelectSubset<T, DraftContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftContacts and returns the data updated in the database.
     * @param {DraftContactUpdateManyAndReturnArgs} args - Arguments to update many DraftContacts.
     * @example
     * // Update many DraftContacts
     * const draftContact = await prisma.draftContact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DraftContacts and only return the `draftId`
     * const draftContactWithDraftIdOnly = await prisma.draftContact.updateManyAndReturn({
     *   select: { draftId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DraftContactUpdateManyAndReturnArgs>(args: SelectSubset<T, DraftContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DraftContact.
     * @param {DraftContactUpsertArgs} args - Arguments to update or create a DraftContact.
     * @example
     * // Update or create a DraftContact
     * const draftContact = await prisma.draftContact.upsert({
     *   create: {
     *     // ... data to create a DraftContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DraftContact we want to update
     *   }
     * })
     */
    upsert<T extends DraftContactUpsertArgs>(args: SelectSubset<T, DraftContactUpsertArgs<ExtArgs>>): Prisma__DraftContactClient<$Result.GetResult<Prisma.$DraftContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DraftContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactCountArgs} args - Arguments to filter DraftContacts to count.
     * @example
     * // Count the number of DraftContacts
     * const count = await prisma.draftContact.count({
     *   where: {
     *     // ... the filter for the DraftContacts we want to count
     *   }
     * })
    **/
    count<T extends DraftContactCountArgs>(
      args?: Subset<T, DraftContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DraftContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftContactAggregateArgs>(args: Subset<T, DraftContactAggregateArgs>): Prisma.PrismaPromise<GetDraftContactAggregateType<T>>

    /**
     * Group by DraftContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftContactGroupByArgs['orderBy'] }
        : { orderBy?: DraftContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DraftContact model
   */
  readonly fields: DraftContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DraftContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends DraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DraftDefaultArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DraftContact model
   */
  interface DraftContactFieldRefs {
    readonly draftId: FieldRef<"DraftContact", 'String'>
    readonly contactId: FieldRef<"DraftContact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DraftContact findUnique
   */
  export type DraftContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter, which DraftContact to fetch.
     */
    where: DraftContactWhereUniqueInput
  }

  /**
   * DraftContact findUniqueOrThrow
   */
  export type DraftContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter, which DraftContact to fetch.
     */
    where: DraftContactWhereUniqueInput
  }

  /**
   * DraftContact findFirst
   */
  export type DraftContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter, which DraftContact to fetch.
     */
    where?: DraftContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftContacts to fetch.
     */
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftContacts.
     */
    cursor?: DraftContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftContacts.
     */
    distinct?: DraftContactScalarFieldEnum | DraftContactScalarFieldEnum[]
  }

  /**
   * DraftContact findFirstOrThrow
   */
  export type DraftContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter, which DraftContact to fetch.
     */
    where?: DraftContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftContacts to fetch.
     */
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftContacts.
     */
    cursor?: DraftContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftContacts.
     */
    distinct?: DraftContactScalarFieldEnum | DraftContactScalarFieldEnum[]
  }

  /**
   * DraftContact findMany
   */
  export type DraftContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter, which DraftContacts to fetch.
     */
    where?: DraftContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftContacts to fetch.
     */
    orderBy?: DraftContactOrderByWithRelationInput | DraftContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DraftContacts.
     */
    cursor?: DraftContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftContacts.
     */
    skip?: number
    distinct?: DraftContactScalarFieldEnum | DraftContactScalarFieldEnum[]
  }

  /**
   * DraftContact create
   */
  export type DraftContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * The data needed to create a DraftContact.
     */
    data: XOR<DraftContactCreateInput, DraftContactUncheckedCreateInput>
  }

  /**
   * DraftContact createMany
   */
  export type DraftContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DraftContacts.
     */
    data: DraftContactCreateManyInput | DraftContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DraftContact createManyAndReturn
   */
  export type DraftContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * The data used to create many DraftContacts.
     */
    data: DraftContactCreateManyInput | DraftContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftContact update
   */
  export type DraftContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * The data needed to update a DraftContact.
     */
    data: XOR<DraftContactUpdateInput, DraftContactUncheckedUpdateInput>
    /**
     * Choose, which DraftContact to update.
     */
    where: DraftContactWhereUniqueInput
  }

  /**
   * DraftContact updateMany
   */
  export type DraftContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DraftContacts.
     */
    data: XOR<DraftContactUpdateManyMutationInput, DraftContactUncheckedUpdateManyInput>
    /**
     * Filter which DraftContacts to update
     */
    where?: DraftContactWhereInput
    /**
     * Limit how many DraftContacts to update.
     */
    limit?: number
  }

  /**
   * DraftContact updateManyAndReturn
   */
  export type DraftContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * The data used to update DraftContacts.
     */
    data: XOR<DraftContactUpdateManyMutationInput, DraftContactUncheckedUpdateManyInput>
    /**
     * Filter which DraftContacts to update
     */
    where?: DraftContactWhereInput
    /**
     * Limit how many DraftContacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftContact upsert
   */
  export type DraftContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * The filter to search for the DraftContact to update in case it exists.
     */
    where: DraftContactWhereUniqueInput
    /**
     * In case the DraftContact found by the `where` argument doesn't exist, create a new DraftContact with this data.
     */
    create: XOR<DraftContactCreateInput, DraftContactUncheckedCreateInput>
    /**
     * In case the DraftContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftContactUpdateInput, DraftContactUncheckedUpdateInput>
  }

  /**
   * DraftContact delete
   */
  export type DraftContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
    /**
     * Filter which DraftContact to delete.
     */
    where: DraftContactWhereUniqueInput
  }

  /**
   * DraftContact deleteMany
   */
  export type DraftContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftContacts to delete
     */
    where?: DraftContactWhereInput
    /**
     * Limit how many DraftContacts to delete.
     */
    limit?: number
  }

  /**
   * DraftContact without action
   */
  export type DraftContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftContact
     */
    select?: DraftContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftContact
     */
    omit?: DraftContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftContactInclude<ExtArgs> | null
  }


  /**
   * Model LLMLog
   */

  export type AggregateLLMLog = {
    _count: LLMLogCountAggregateOutputType | null
    _min: LLMLogMinAggregateOutputType | null
    _max: LLMLogMaxAggregateOutputType | null
  }

  export type LLMLogMinAggregateOutputType = {
    id: string | null
    prompt: string | null
    response: string | null
    isError: boolean | null
    createdAt: Date | null
  }

  export type LLMLogMaxAggregateOutputType = {
    id: string | null
    prompt: string | null
    response: string | null
    isError: boolean | null
    createdAt: Date | null
  }

  export type LLMLogCountAggregateOutputType = {
    id: number
    prompt: number
    response: number
    isError: number
    createdAt: number
    _all: number
  }


  export type LLMLogMinAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    isError?: true
    createdAt?: true
  }

  export type LLMLogMaxAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    isError?: true
    createdAt?: true
  }

  export type LLMLogCountAggregateInputType = {
    id?: true
    prompt?: true
    response?: true
    isError?: true
    createdAt?: true
    _all?: true
  }

  export type LLMLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LLMLog to aggregate.
     */
    where?: LLMLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LLMLogs to fetch.
     */
    orderBy?: LLMLogOrderByWithRelationInput | LLMLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LLMLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LLMLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LLMLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LLMLogs
    **/
    _count?: true | LLMLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LLMLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LLMLogMaxAggregateInputType
  }

  export type GetLLMLogAggregateType<T extends LLMLogAggregateArgs> = {
        [P in keyof T & keyof AggregateLLMLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLLMLog[P]>
      : GetScalarType<T[P], AggregateLLMLog[P]>
  }




  export type LLMLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LLMLogWhereInput
    orderBy?: LLMLogOrderByWithAggregationInput | LLMLogOrderByWithAggregationInput[]
    by: LLMLogScalarFieldEnum[] | LLMLogScalarFieldEnum
    having?: LLMLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LLMLogCountAggregateInputType | true
    _min?: LLMLogMinAggregateInputType
    _max?: LLMLogMaxAggregateInputType
  }

  export type LLMLogGroupByOutputType = {
    id: string
    prompt: string
    response: string | null
    isError: boolean
    createdAt: Date
    _count: LLMLogCountAggregateOutputType | null
    _min: LLMLogMinAggregateOutputType | null
    _max: LLMLogMaxAggregateOutputType | null
  }

  type GetLLMLogGroupByPayload<T extends LLMLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LLMLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LLMLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LLMLogGroupByOutputType[P]>
            : GetScalarType<T[P], LLMLogGroupByOutputType[P]>
        }
      >
    >


  export type LLMLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    isError?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lLMLog"]>

  export type LLMLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    isError?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lLMLog"]>

  export type LLMLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prompt?: boolean
    response?: boolean
    isError?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lLMLog"]>

  export type LLMLogSelectScalar = {
    id?: boolean
    prompt?: boolean
    response?: boolean
    isError?: boolean
    createdAt?: boolean
  }

  export type LLMLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prompt" | "response" | "isError" | "createdAt", ExtArgs["result"]["lLMLog"]>

  export type $LLMLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LLMLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prompt: string
      response: string | null
      isError: boolean
      createdAt: Date
    }, ExtArgs["result"]["lLMLog"]>
    composites: {}
  }

  type LLMLogGetPayload<S extends boolean | null | undefined | LLMLogDefaultArgs> = $Result.GetResult<Prisma.$LLMLogPayload, S>

  type LLMLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LLMLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LLMLogCountAggregateInputType | true
    }

  export interface LLMLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LLMLog'], meta: { name: 'LLMLog' } }
    /**
     * Find zero or one LLMLog that matches the filter.
     * @param {LLMLogFindUniqueArgs} args - Arguments to find a LLMLog
     * @example
     * // Get one LLMLog
     * const lLMLog = await prisma.lLMLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LLMLogFindUniqueArgs>(args: SelectSubset<T, LLMLogFindUniqueArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LLMLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LLMLogFindUniqueOrThrowArgs} args - Arguments to find a LLMLog
     * @example
     * // Get one LLMLog
     * const lLMLog = await prisma.lLMLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LLMLogFindUniqueOrThrowArgs>(args: SelectSubset<T, LLMLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LLMLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogFindFirstArgs} args - Arguments to find a LLMLog
     * @example
     * // Get one LLMLog
     * const lLMLog = await prisma.lLMLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LLMLogFindFirstArgs>(args?: SelectSubset<T, LLMLogFindFirstArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LLMLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogFindFirstOrThrowArgs} args - Arguments to find a LLMLog
     * @example
     * // Get one LLMLog
     * const lLMLog = await prisma.lLMLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LLMLogFindFirstOrThrowArgs>(args?: SelectSubset<T, LLMLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LLMLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LLMLogs
     * const lLMLogs = await prisma.lLMLog.findMany()
     * 
     * // Get first 10 LLMLogs
     * const lLMLogs = await prisma.lLMLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lLMLogWithIdOnly = await prisma.lLMLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LLMLogFindManyArgs>(args?: SelectSubset<T, LLMLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LLMLog.
     * @param {LLMLogCreateArgs} args - Arguments to create a LLMLog.
     * @example
     * // Create one LLMLog
     * const LLMLog = await prisma.lLMLog.create({
     *   data: {
     *     // ... data to create a LLMLog
     *   }
     * })
     * 
     */
    create<T extends LLMLogCreateArgs>(args: SelectSubset<T, LLMLogCreateArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LLMLogs.
     * @param {LLMLogCreateManyArgs} args - Arguments to create many LLMLogs.
     * @example
     * // Create many LLMLogs
     * const lLMLog = await prisma.lLMLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LLMLogCreateManyArgs>(args?: SelectSubset<T, LLMLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LLMLogs and returns the data saved in the database.
     * @param {LLMLogCreateManyAndReturnArgs} args - Arguments to create many LLMLogs.
     * @example
     * // Create many LLMLogs
     * const lLMLog = await prisma.lLMLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LLMLogs and only return the `id`
     * const lLMLogWithIdOnly = await prisma.lLMLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LLMLogCreateManyAndReturnArgs>(args?: SelectSubset<T, LLMLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LLMLog.
     * @param {LLMLogDeleteArgs} args - Arguments to delete one LLMLog.
     * @example
     * // Delete one LLMLog
     * const LLMLog = await prisma.lLMLog.delete({
     *   where: {
     *     // ... filter to delete one LLMLog
     *   }
     * })
     * 
     */
    delete<T extends LLMLogDeleteArgs>(args: SelectSubset<T, LLMLogDeleteArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LLMLog.
     * @param {LLMLogUpdateArgs} args - Arguments to update one LLMLog.
     * @example
     * // Update one LLMLog
     * const lLMLog = await prisma.lLMLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LLMLogUpdateArgs>(args: SelectSubset<T, LLMLogUpdateArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LLMLogs.
     * @param {LLMLogDeleteManyArgs} args - Arguments to filter LLMLogs to delete.
     * @example
     * // Delete a few LLMLogs
     * const { count } = await prisma.lLMLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LLMLogDeleteManyArgs>(args?: SelectSubset<T, LLMLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LLMLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LLMLogs
     * const lLMLog = await prisma.lLMLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LLMLogUpdateManyArgs>(args: SelectSubset<T, LLMLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LLMLogs and returns the data updated in the database.
     * @param {LLMLogUpdateManyAndReturnArgs} args - Arguments to update many LLMLogs.
     * @example
     * // Update many LLMLogs
     * const lLMLog = await prisma.lLMLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LLMLogs and only return the `id`
     * const lLMLogWithIdOnly = await prisma.lLMLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LLMLogUpdateManyAndReturnArgs>(args: SelectSubset<T, LLMLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LLMLog.
     * @param {LLMLogUpsertArgs} args - Arguments to update or create a LLMLog.
     * @example
     * // Update or create a LLMLog
     * const lLMLog = await prisma.lLMLog.upsert({
     *   create: {
     *     // ... data to create a LLMLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LLMLog we want to update
     *   }
     * })
     */
    upsert<T extends LLMLogUpsertArgs>(args: SelectSubset<T, LLMLogUpsertArgs<ExtArgs>>): Prisma__LLMLogClient<$Result.GetResult<Prisma.$LLMLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LLMLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogCountArgs} args - Arguments to filter LLMLogs to count.
     * @example
     * // Count the number of LLMLogs
     * const count = await prisma.lLMLog.count({
     *   where: {
     *     // ... the filter for the LLMLogs we want to count
     *   }
     * })
    **/
    count<T extends LLMLogCountArgs>(
      args?: Subset<T, LLMLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LLMLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LLMLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LLMLogAggregateArgs>(args: Subset<T, LLMLogAggregateArgs>): Prisma.PrismaPromise<GetLLMLogAggregateType<T>>

    /**
     * Group by LLMLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LLMLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LLMLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LLMLogGroupByArgs['orderBy'] }
        : { orderBy?: LLMLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LLMLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLLMLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LLMLog model
   */
  readonly fields: LLMLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LLMLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LLMLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LLMLog model
   */
  interface LLMLogFieldRefs {
    readonly id: FieldRef<"LLMLog", 'String'>
    readonly prompt: FieldRef<"LLMLog", 'String'>
    readonly response: FieldRef<"LLMLog", 'String'>
    readonly isError: FieldRef<"LLMLog", 'Boolean'>
    readonly createdAt: FieldRef<"LLMLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LLMLog findUnique
   */
  export type LLMLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter, which LLMLog to fetch.
     */
    where: LLMLogWhereUniqueInput
  }

  /**
   * LLMLog findUniqueOrThrow
   */
  export type LLMLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter, which LLMLog to fetch.
     */
    where: LLMLogWhereUniqueInput
  }

  /**
   * LLMLog findFirst
   */
  export type LLMLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter, which LLMLog to fetch.
     */
    where?: LLMLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LLMLogs to fetch.
     */
    orderBy?: LLMLogOrderByWithRelationInput | LLMLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LLMLogs.
     */
    cursor?: LLMLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LLMLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LLMLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LLMLogs.
     */
    distinct?: LLMLogScalarFieldEnum | LLMLogScalarFieldEnum[]
  }

  /**
   * LLMLog findFirstOrThrow
   */
  export type LLMLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter, which LLMLog to fetch.
     */
    where?: LLMLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LLMLogs to fetch.
     */
    orderBy?: LLMLogOrderByWithRelationInput | LLMLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LLMLogs.
     */
    cursor?: LLMLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LLMLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LLMLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LLMLogs.
     */
    distinct?: LLMLogScalarFieldEnum | LLMLogScalarFieldEnum[]
  }

  /**
   * LLMLog findMany
   */
  export type LLMLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter, which LLMLogs to fetch.
     */
    where?: LLMLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LLMLogs to fetch.
     */
    orderBy?: LLMLogOrderByWithRelationInput | LLMLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LLMLogs.
     */
    cursor?: LLMLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LLMLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LLMLogs.
     */
    skip?: number
    distinct?: LLMLogScalarFieldEnum | LLMLogScalarFieldEnum[]
  }

  /**
   * LLMLog create
   */
  export type LLMLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * The data needed to create a LLMLog.
     */
    data: XOR<LLMLogCreateInput, LLMLogUncheckedCreateInput>
  }

  /**
   * LLMLog createMany
   */
  export type LLMLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LLMLogs.
     */
    data: LLMLogCreateManyInput | LLMLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LLMLog createManyAndReturn
   */
  export type LLMLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * The data used to create many LLMLogs.
     */
    data: LLMLogCreateManyInput | LLMLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LLMLog update
   */
  export type LLMLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * The data needed to update a LLMLog.
     */
    data: XOR<LLMLogUpdateInput, LLMLogUncheckedUpdateInput>
    /**
     * Choose, which LLMLog to update.
     */
    where: LLMLogWhereUniqueInput
  }

  /**
   * LLMLog updateMany
   */
  export type LLMLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LLMLogs.
     */
    data: XOR<LLMLogUpdateManyMutationInput, LLMLogUncheckedUpdateManyInput>
    /**
     * Filter which LLMLogs to update
     */
    where?: LLMLogWhereInput
    /**
     * Limit how many LLMLogs to update.
     */
    limit?: number
  }

  /**
   * LLMLog updateManyAndReturn
   */
  export type LLMLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * The data used to update LLMLogs.
     */
    data: XOR<LLMLogUpdateManyMutationInput, LLMLogUncheckedUpdateManyInput>
    /**
     * Filter which LLMLogs to update
     */
    where?: LLMLogWhereInput
    /**
     * Limit how many LLMLogs to update.
     */
    limit?: number
  }

  /**
   * LLMLog upsert
   */
  export type LLMLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * The filter to search for the LLMLog to update in case it exists.
     */
    where: LLMLogWhereUniqueInput
    /**
     * In case the LLMLog found by the `where` argument doesn't exist, create a new LLMLog with this data.
     */
    create: XOR<LLMLogCreateInput, LLMLogUncheckedCreateInput>
    /**
     * In case the LLMLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LLMLogUpdateInput, LLMLogUncheckedUpdateInput>
  }

  /**
   * LLMLog delete
   */
  export type LLMLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
    /**
     * Filter which LLMLog to delete.
     */
    where: LLMLogWhereUniqueInput
  }

  /**
   * LLMLog deleteMany
   */
  export type LLMLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LLMLogs to delete
     */
    where?: LLMLogWhereInput
    /**
     * Limit how many LLMLogs to delete.
     */
    limit?: number
  }

  /**
   * LLMLog without action
   */
  export type LLMLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LLMLog
     */
    select?: LLMLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LLMLog
     */
    omit?: LLMLogOmit<ExtArgs> | null
  }


  /**
   * Model WebhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: string | null
    platform: string | null
    body: string | null
    createdAt: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: string | null
    platform: string | null
    body: string | null
    createdAt: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    platform: number
    body: number
    createdAt: number
    _all: number
  }


  export type WebhookLogMinAggregateInputType = {
    id?: true
    platform?: true
    body?: true
    createdAt?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    platform?: true
    body?: true
    createdAt?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    platform?: true
    body?: true
    createdAt?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLog to aggregate.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type WebhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookLogWhereInput
    orderBy?: WebhookLogOrderByWithAggregationInput | WebhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: WebhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: string
    platform: string
    body: string | null
    createdAt: Date
    _count: WebhookLogCountAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends WebhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type WebhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    body?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    body?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platform?: boolean
    body?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["webhookLog"]>

  export type WebhookLogSelectScalar = {
    id?: boolean
    platform?: boolean
    body?: boolean
    createdAt?: boolean
  }

  export type WebhookLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platform" | "body" | "createdAt", ExtArgs["result"]["webhookLog"]>

  export type $WebhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platform: string
      body: string | null
      createdAt: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type WebhookLogGetPayload<S extends boolean | null | undefined | WebhookLogDefaultArgs> = $Result.GetResult<Prisma.$WebhookLogPayload, S>

  type WebhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebhookLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface WebhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookLog'], meta: { name: 'WebhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {WebhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookLogFindUniqueArgs>(args: SelectSubset<T, WebhookLogFindUniqueArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookLogFindFirstArgs>(args?: SelectSubset<T, WebhookLogFindFirstArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookLogFindManyArgs>(args?: SelectSubset<T, WebhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebhookLog.
     * @param {WebhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends WebhookLogCreateArgs>(args: SelectSubset<T, WebhookLogCreateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebhookLogs.
     * @param {WebhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookLogCreateManyArgs>(args?: SelectSubset<T, WebhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookLogs and returns the data saved in the database.
     * @param {WebhookLogCreateManyAndReturnArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookLogCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebhookLog.
     * @param {WebhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends WebhookLogDeleteArgs>(args: SelectSubset<T, WebhookLogDeleteArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebhookLog.
     * @param {WebhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookLogUpdateArgs>(args: SelectSubset<T, WebhookLogUpdateArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebhookLogs.
     * @param {WebhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookLogDeleteManyArgs>(args?: SelectSubset<T, WebhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookLogUpdateManyArgs>(args: SelectSubset<T, WebhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs and returns the data updated in the database.
     * @param {WebhookLogUpdateManyAndReturnArgs} args - Arguments to update many WebhookLogs.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebhookLogs and only return the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebhookLogUpdateManyAndReturnArgs>(args: SelectSubset<T, WebhookLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebhookLog.
     * @param {WebhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends WebhookLogUpsertArgs>(args: SelectSubset<T, WebhookLogUpsertArgs<ExtArgs>>): Prisma__WebhookLogClient<$Result.GetResult<Prisma.$WebhookLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends WebhookLogCountArgs>(
      args?: Subset<T, WebhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookLogGroupByArgs['orderBy'] }
        : { orderBy?: WebhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookLog model
   */
  readonly fields: WebhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookLog model
   */
  interface WebhookLogFieldRefs {
    readonly id: FieldRef<"WebhookLog", 'String'>
    readonly platform: FieldRef<"WebhookLog", 'String'>
    readonly body: FieldRef<"WebhookLog", 'String'>
    readonly createdAt: FieldRef<"WebhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookLog findUnique
   */
  export type WebhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findUniqueOrThrow
   */
  export type WebhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog findFirst
   */
  export type WebhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findFirstOrThrow
   */
  export type WebhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLog to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog findMany
   */
  export type WebhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter, which WebhookLogs to fetch.
     */
    where?: WebhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookLogs to fetch.
     */
    orderBy?: WebhookLogOrderByWithRelationInput | WebhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookLogs.
     */
    cursor?: WebhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * WebhookLog create
   */
  export type WebhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to create a WebhookLog.
     */
    data: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
  }

  /**
   * WebhookLog createMany
   */
  export type WebhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog createManyAndReturn
   */
  export type WebhookLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to create many WebhookLogs.
     */
    data: WebhookLogCreateManyInput | WebhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebhookLog update
   */
  export type WebhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data needed to update a WebhookLog.
     */
    data: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
    /**
     * Choose, which WebhookLog to update.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog updateMany
   */
  export type WebhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog updateManyAndReturn
   */
  export type WebhookLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The data used to update WebhookLogs.
     */
    data: XOR<WebhookLogUpdateManyMutationInput, WebhookLogUncheckedUpdateManyInput>
    /**
     * Filter which WebhookLogs to update
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to update.
     */
    limit?: number
  }

  /**
   * WebhookLog upsert
   */
  export type WebhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * The filter to search for the WebhookLog to update in case it exists.
     */
    where: WebhookLogWhereUniqueInput
    /**
     * In case the WebhookLog found by the `where` argument doesn't exist, create a new WebhookLog with this data.
     */
    create: XOR<WebhookLogCreateInput, WebhookLogUncheckedCreateInput>
    /**
     * In case the WebhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookLogUpdateInput, WebhookLogUncheckedUpdateInput>
  }

  /**
   * WebhookLog delete
   */
  export type WebhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
    /**
     * Filter which WebhookLog to delete.
     */
    where: WebhookLogWhereUniqueInput
  }

  /**
   * WebhookLog deleteMany
   */
  export type WebhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookLogs to delete
     */
    where?: WebhookLogWhereInput
    /**
     * Limit how many WebhookLogs to delete.
     */
    limit?: number
  }

  /**
   * WebhookLog without action
   */
  export type WebhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookLog
     */
    select?: WebhookLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebhookLog
     */
    omit?: WebhookLogOmit<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    emailId: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    emailId: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    emailId: number
    type: number
    isRead: number
    isDeleted: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    emailId?: true
    type?: true
    isRead?: true
    isDeleted?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    emailId?: true
    type?: true
    isRead?: true
    isDeleted?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    emailId?: true
    type?: true
    isRead?: true
    isDeleted?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    emailId: string
    type: $Enums.NotificationType
    isRead: boolean
    isDeleted: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    type?: boolean
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    type?: boolean
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailId?: boolean
    type?: boolean
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    emailId?: boolean
    type?: boolean
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailId" | "type" | "isRead" | "isDeleted" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailId: string
      type: $Enums.NotificationType
      isRead: boolean
      isDeleted: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly emailId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly isDeleted: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Sender
   */

  export type AggregateSender = {
    _count: SenderCountAggregateOutputType | null
    _avg: SenderAvgAggregateOutputType | null
    _sum: SenderSumAggregateOutputType | null
    _min: SenderMinAggregateOutputType | null
    _max: SenderMaxAggregateOutputType | null
  }

  export type SenderAvgAggregateOutputType = {
    priority: number | null
    target: number | null
    sentCount: number | null
  }

  export type SenderSumAggregateOutputType = {
    priority: number | null
    target: number | null
    sentCount: number | null
  }

  export type SenderMinAggregateOutputType = {
    id: string | null
    displayName: string | null
    name: string | null
    email: string | null
    apiKey: string | null
    esp: string | null
    priority: number | null
    target: number | null
    sentCount: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SenderMaxAggregateOutputType = {
    id: string | null
    displayName: string | null
    name: string | null
    email: string | null
    apiKey: string | null
    esp: string | null
    priority: number | null
    target: number | null
    sentCount: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SenderCountAggregateOutputType = {
    id: number
    displayName: number
    name: number
    email: number
    apiKey: number
    esp: number
    priority: number
    target: number
    sentCount: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SenderAvgAggregateInputType = {
    priority?: true
    target?: true
    sentCount?: true
  }

  export type SenderSumAggregateInputType = {
    priority?: true
    target?: true
    sentCount?: true
  }

  export type SenderMinAggregateInputType = {
    id?: true
    displayName?: true
    name?: true
    email?: true
    apiKey?: true
    esp?: true
    priority?: true
    target?: true
    sentCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SenderMaxAggregateInputType = {
    id?: true
    displayName?: true
    name?: true
    email?: true
    apiKey?: true
    esp?: true
    priority?: true
    target?: true
    sentCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SenderCountAggregateInputType = {
    id?: true
    displayName?: true
    name?: true
    email?: true
    apiKey?: true
    esp?: true
    priority?: true
    target?: true
    sentCount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sender to aggregate.
     */
    where?: SenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senders to fetch.
     */
    orderBy?: SenderOrderByWithRelationInput | SenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Senders
    **/
    _count?: true | SenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SenderMaxAggregateInputType
  }

  export type GetSenderAggregateType<T extends SenderAggregateArgs> = {
        [P in keyof T & keyof AggregateSender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSender[P]>
      : GetScalarType<T[P], AggregateSender[P]>
  }




  export type SenderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SenderWhereInput
    orderBy?: SenderOrderByWithAggregationInput | SenderOrderByWithAggregationInput[]
    by: SenderScalarFieldEnum[] | SenderScalarFieldEnum
    having?: SenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SenderCountAggregateInputType | true
    _avg?: SenderAvgAggregateInputType
    _sum?: SenderSumAggregateInputType
    _min?: SenderMinAggregateInputType
    _max?: SenderMaxAggregateInputType
  }

  export type SenderGroupByOutputType = {
    id: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority: number
    target: number
    sentCount: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SenderCountAggregateOutputType | null
    _avg: SenderAvgAggregateOutputType | null
    _sum: SenderSumAggregateOutputType | null
    _min: SenderMinAggregateOutputType | null
    _max: SenderMaxAggregateOutputType | null
  }

  type GetSenderGroupByPayload<T extends SenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SenderGroupByOutputType[P]>
            : GetScalarType<T[P], SenderGroupByOutputType[P]>
        }
      >
    >


  export type SenderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    name?: boolean
    email?: boolean
    apiKey?: boolean
    esp?: boolean
    priority?: boolean
    target?: boolean
    sentCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    drafts?: boolean | Sender$draftsArgs<ExtArgs>
    emails?: boolean | Sender$emailsArgs<ExtArgs>
    _count?: boolean | SenderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sender"]>

  export type SenderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    name?: boolean
    email?: boolean
    apiKey?: boolean
    esp?: boolean
    priority?: boolean
    target?: boolean
    sentCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sender"]>

  export type SenderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    name?: boolean
    email?: boolean
    apiKey?: boolean
    esp?: boolean
    priority?: boolean
    target?: boolean
    sentCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sender"]>

  export type SenderSelectScalar = {
    id?: boolean
    displayName?: boolean
    name?: boolean
    email?: boolean
    apiKey?: boolean
    esp?: boolean
    priority?: boolean
    target?: boolean
    sentCount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SenderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "displayName" | "name" | "email" | "apiKey" | "esp" | "priority" | "target" | "sentCount" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["sender"]>
  export type SenderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drafts?: boolean | Sender$draftsArgs<ExtArgs>
    emails?: boolean | Sender$emailsArgs<ExtArgs>
    _count?: boolean | SenderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SenderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SenderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SenderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sender"
    objects: {
      drafts: Prisma.$DraftPayload<ExtArgs>[]
      emails: Prisma.$EmailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      displayName: string
      name: string
      email: string
      apiKey: string
      esp: string
      priority: number
      target: number
      sentCount: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sender"]>
    composites: {}
  }

  type SenderGetPayload<S extends boolean | null | undefined | SenderDefaultArgs> = $Result.GetResult<Prisma.$SenderPayload, S>

  type SenderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SenderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SenderCountAggregateInputType | true
    }

  export interface SenderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sender'], meta: { name: 'Sender' } }
    /**
     * Find zero or one Sender that matches the filter.
     * @param {SenderFindUniqueArgs} args - Arguments to find a Sender
     * @example
     * // Get one Sender
     * const sender = await prisma.sender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SenderFindUniqueArgs>(args: SelectSubset<T, SenderFindUniqueArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sender that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SenderFindUniqueOrThrowArgs} args - Arguments to find a Sender
     * @example
     * // Get one Sender
     * const sender = await prisma.sender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SenderFindUniqueOrThrowArgs>(args: SelectSubset<T, SenderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderFindFirstArgs} args - Arguments to find a Sender
     * @example
     * // Get one Sender
     * const sender = await prisma.sender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SenderFindFirstArgs>(args?: SelectSubset<T, SenderFindFirstArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderFindFirstOrThrowArgs} args - Arguments to find a Sender
     * @example
     * // Get one Sender
     * const sender = await prisma.sender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SenderFindFirstOrThrowArgs>(args?: SelectSubset<T, SenderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Senders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Senders
     * const senders = await prisma.sender.findMany()
     * 
     * // Get first 10 Senders
     * const senders = await prisma.sender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const senderWithIdOnly = await prisma.sender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SenderFindManyArgs>(args?: SelectSubset<T, SenderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sender.
     * @param {SenderCreateArgs} args - Arguments to create a Sender.
     * @example
     * // Create one Sender
     * const Sender = await prisma.sender.create({
     *   data: {
     *     // ... data to create a Sender
     *   }
     * })
     * 
     */
    create<T extends SenderCreateArgs>(args: SelectSubset<T, SenderCreateArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Senders.
     * @param {SenderCreateManyArgs} args - Arguments to create many Senders.
     * @example
     * // Create many Senders
     * const sender = await prisma.sender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SenderCreateManyArgs>(args?: SelectSubset<T, SenderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Senders and returns the data saved in the database.
     * @param {SenderCreateManyAndReturnArgs} args - Arguments to create many Senders.
     * @example
     * // Create many Senders
     * const sender = await prisma.sender.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Senders and only return the `id`
     * const senderWithIdOnly = await prisma.sender.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SenderCreateManyAndReturnArgs>(args?: SelectSubset<T, SenderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sender.
     * @param {SenderDeleteArgs} args - Arguments to delete one Sender.
     * @example
     * // Delete one Sender
     * const Sender = await prisma.sender.delete({
     *   where: {
     *     // ... filter to delete one Sender
     *   }
     * })
     * 
     */
    delete<T extends SenderDeleteArgs>(args: SelectSubset<T, SenderDeleteArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sender.
     * @param {SenderUpdateArgs} args - Arguments to update one Sender.
     * @example
     * // Update one Sender
     * const sender = await prisma.sender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SenderUpdateArgs>(args: SelectSubset<T, SenderUpdateArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Senders.
     * @param {SenderDeleteManyArgs} args - Arguments to filter Senders to delete.
     * @example
     * // Delete a few Senders
     * const { count } = await prisma.sender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SenderDeleteManyArgs>(args?: SelectSubset<T, SenderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Senders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Senders
     * const sender = await prisma.sender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SenderUpdateManyArgs>(args: SelectSubset<T, SenderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Senders and returns the data updated in the database.
     * @param {SenderUpdateManyAndReturnArgs} args - Arguments to update many Senders.
     * @example
     * // Update many Senders
     * const sender = await prisma.sender.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Senders and only return the `id`
     * const senderWithIdOnly = await prisma.sender.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SenderUpdateManyAndReturnArgs>(args: SelectSubset<T, SenderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sender.
     * @param {SenderUpsertArgs} args - Arguments to update or create a Sender.
     * @example
     * // Update or create a Sender
     * const sender = await prisma.sender.upsert({
     *   create: {
     *     // ... data to create a Sender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sender we want to update
     *   }
     * })
     */
    upsert<T extends SenderUpsertArgs>(args: SelectSubset<T, SenderUpsertArgs<ExtArgs>>): Prisma__SenderClient<$Result.GetResult<Prisma.$SenderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Senders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderCountArgs} args - Arguments to filter Senders to count.
     * @example
     * // Count the number of Senders
     * const count = await prisma.sender.count({
     *   where: {
     *     // ... the filter for the Senders we want to count
     *   }
     * })
    **/
    count<T extends SenderCountArgs>(
      args?: Subset<T, SenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SenderAggregateArgs>(args: Subset<T, SenderAggregateArgs>): Prisma.PrismaPromise<GetSenderAggregateType<T>>

    /**
     * Group by Sender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SenderGroupByArgs['orderBy'] }
        : { orderBy?: SenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sender model
   */
  readonly fields: SenderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SenderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    drafts<T extends Sender$draftsArgs<ExtArgs> = {}>(args?: Subset<T, Sender$draftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emails<T extends Sender$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Sender$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sender model
   */
  interface SenderFieldRefs {
    readonly id: FieldRef<"Sender", 'String'>
    readonly displayName: FieldRef<"Sender", 'String'>
    readonly name: FieldRef<"Sender", 'String'>
    readonly email: FieldRef<"Sender", 'String'>
    readonly apiKey: FieldRef<"Sender", 'String'>
    readonly esp: FieldRef<"Sender", 'String'>
    readonly priority: FieldRef<"Sender", 'Int'>
    readonly target: FieldRef<"Sender", 'Int'>
    readonly sentCount: FieldRef<"Sender", 'Int'>
    readonly isDeleted: FieldRef<"Sender", 'Boolean'>
    readonly createdAt: FieldRef<"Sender", 'DateTime'>
    readonly updatedAt: FieldRef<"Sender", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sender findUnique
   */
  export type SenderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter, which Sender to fetch.
     */
    where: SenderWhereUniqueInput
  }

  /**
   * Sender findUniqueOrThrow
   */
  export type SenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter, which Sender to fetch.
     */
    where: SenderWhereUniqueInput
  }

  /**
   * Sender findFirst
   */
  export type SenderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter, which Sender to fetch.
     */
    where?: SenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senders to fetch.
     */
    orderBy?: SenderOrderByWithRelationInput | SenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Senders.
     */
    cursor?: SenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Senders.
     */
    distinct?: SenderScalarFieldEnum | SenderScalarFieldEnum[]
  }

  /**
   * Sender findFirstOrThrow
   */
  export type SenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter, which Sender to fetch.
     */
    where?: SenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senders to fetch.
     */
    orderBy?: SenderOrderByWithRelationInput | SenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Senders.
     */
    cursor?: SenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Senders.
     */
    distinct?: SenderScalarFieldEnum | SenderScalarFieldEnum[]
  }

  /**
   * Sender findMany
   */
  export type SenderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter, which Senders to fetch.
     */
    where?: SenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senders to fetch.
     */
    orderBy?: SenderOrderByWithRelationInput | SenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Senders.
     */
    cursor?: SenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senders.
     */
    skip?: number
    distinct?: SenderScalarFieldEnum | SenderScalarFieldEnum[]
  }

  /**
   * Sender create
   */
  export type SenderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * The data needed to create a Sender.
     */
    data: XOR<SenderCreateInput, SenderUncheckedCreateInput>
  }

  /**
   * Sender createMany
   */
  export type SenderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Senders.
     */
    data: SenderCreateManyInput | SenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sender createManyAndReturn
   */
  export type SenderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * The data used to create many Senders.
     */
    data: SenderCreateManyInput | SenderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sender update
   */
  export type SenderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * The data needed to update a Sender.
     */
    data: XOR<SenderUpdateInput, SenderUncheckedUpdateInput>
    /**
     * Choose, which Sender to update.
     */
    where: SenderWhereUniqueInput
  }

  /**
   * Sender updateMany
   */
  export type SenderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Senders.
     */
    data: XOR<SenderUpdateManyMutationInput, SenderUncheckedUpdateManyInput>
    /**
     * Filter which Senders to update
     */
    where?: SenderWhereInput
    /**
     * Limit how many Senders to update.
     */
    limit?: number
  }

  /**
   * Sender updateManyAndReturn
   */
  export type SenderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * The data used to update Senders.
     */
    data: XOR<SenderUpdateManyMutationInput, SenderUncheckedUpdateManyInput>
    /**
     * Filter which Senders to update
     */
    where?: SenderWhereInput
    /**
     * Limit how many Senders to update.
     */
    limit?: number
  }

  /**
   * Sender upsert
   */
  export type SenderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * The filter to search for the Sender to update in case it exists.
     */
    where: SenderWhereUniqueInput
    /**
     * In case the Sender found by the `where` argument doesn't exist, create a new Sender with this data.
     */
    create: XOR<SenderCreateInput, SenderUncheckedCreateInput>
    /**
     * In case the Sender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SenderUpdateInput, SenderUncheckedUpdateInput>
  }

  /**
   * Sender delete
   */
  export type SenderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
    /**
     * Filter which Sender to delete.
     */
    where: SenderWhereUniqueInput
  }

  /**
   * Sender deleteMany
   */
  export type SenderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Senders to delete
     */
    where?: SenderWhereInput
    /**
     * Limit how many Senders to delete.
     */
    limit?: number
  }

  /**
   * Sender.drafts
   */
  export type Sender$draftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Draft
     */
    select?: DraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Draft
     */
    omit?: DraftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftInclude<ExtArgs> | null
    where?: DraftWhereInput
    orderBy?: DraftOrderByWithRelationInput | DraftOrderByWithRelationInput[]
    cursor?: DraftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftScalarFieldEnum | DraftScalarFieldEnum[]
  }

  /**
   * Sender.emails
   */
  export type Sender$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Email
     */
    omit?: EmailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }

  /**
   * Sender without action
   */
  export type SenderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sender
     */
    select?: SenderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sender
     */
    omit?: SenderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SenderInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    title: string | null
    isDeleted: boolean | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    title: string | null
    isDeleted: boolean | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    title: number
    isDeleted: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    title?: true
    isDeleted?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    title?: true
    isDeleted?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    title?: true
    isDeleted?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    title: string
    isDeleted: boolean
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isDeleted?: boolean
    tagCompanies?: boolean | Tag$tagCompaniesArgs<ExtArgs>
    tagContacts?: boolean | Tag$tagContactsArgs<ExtArgs>
    DraftTag?: boolean | Tag$DraftTagArgs<ExtArgs>
    EmailTag?: boolean | Tag$EmailTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    isDeleted?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    title?: boolean
    isDeleted?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "isDeleted", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagCompanies?: boolean | Tag$tagCompaniesArgs<ExtArgs>
    tagContacts?: boolean | Tag$tagContactsArgs<ExtArgs>
    DraftTag?: boolean | Tag$DraftTagArgs<ExtArgs>
    EmailTag?: boolean | Tag$EmailTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      tagCompanies: Prisma.$CompanyTagPayload<ExtArgs>[]
      tagContacts: Prisma.$ContactTagPayload<ExtArgs>[]
      DraftTag: Prisma.$DraftTagPayload<ExtArgs>[]
      EmailTag: Prisma.$EmailTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      isDeleted: boolean
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tagCompanies<T extends Tag$tagCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$tagCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tagContacts<T extends Tag$tagContactsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$tagContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DraftTag<T extends Tag$DraftTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$DraftTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailTag<T extends Tag$EmailTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$EmailTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly title: FieldRef<"Tag", 'String'>
    readonly isDeleted: FieldRef<"Tag", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.tagCompanies
   */
  export type Tag$tagCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    where?: CompanyTagWhereInput
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    cursor?: CompanyTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyTagScalarFieldEnum | CompanyTagScalarFieldEnum[]
  }

  /**
   * Tag.tagContacts
   */
  export type Tag$tagContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Tag.DraftTag
   */
  export type Tag$DraftTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    where?: DraftTagWhereInput
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    cursor?: DraftTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DraftTagScalarFieldEnum | DraftTagScalarFieldEnum[]
  }

  /**
   * Tag.EmailTag
   */
  export type Tag$EmailTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    where?: EmailTagWhereInput
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    cursor?: EmailTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailTagScalarFieldEnum | EmailTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model CompanyTag
   */

  export type AggregateCompanyTag = {
    _count: CompanyTagCountAggregateOutputType | null
    _min: CompanyTagMinAggregateOutputType | null
    _max: CompanyTagMaxAggregateOutputType | null
  }

  export type CompanyTagMinAggregateOutputType = {
    companyId: string | null
    tagId: string | null
  }

  export type CompanyTagMaxAggregateOutputType = {
    companyId: string | null
    tagId: string | null
  }

  export type CompanyTagCountAggregateOutputType = {
    companyId: number
    tagId: number
    _all: number
  }


  export type CompanyTagMinAggregateInputType = {
    companyId?: true
    tagId?: true
  }

  export type CompanyTagMaxAggregateInputType = {
    companyId?: true
    tagId?: true
  }

  export type CompanyTagCountAggregateInputType = {
    companyId?: true
    tagId?: true
    _all?: true
  }

  export type CompanyTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyTag to aggregate.
     */
    where?: CompanyTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTags to fetch.
     */
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyTags
    **/
    _count?: true | CompanyTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyTagMaxAggregateInputType
  }

  export type GetCompanyTagAggregateType<T extends CompanyTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyTag[P]>
      : GetScalarType<T[P], AggregateCompanyTag[P]>
  }




  export type CompanyTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyTagWhereInput
    orderBy?: CompanyTagOrderByWithAggregationInput | CompanyTagOrderByWithAggregationInput[]
    by: CompanyTagScalarFieldEnum[] | CompanyTagScalarFieldEnum
    having?: CompanyTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyTagCountAggregateInputType | true
    _min?: CompanyTagMinAggregateInputType
    _max?: CompanyTagMaxAggregateInputType
  }

  export type CompanyTagGroupByOutputType = {
    companyId: string
    tagId: string
    _count: CompanyTagCountAggregateOutputType | null
    _min: CompanyTagMinAggregateOutputType | null
    _max: CompanyTagMaxAggregateOutputType | null
  }

  type GetCompanyTagGroupByPayload<T extends CompanyTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyTagGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyTagGroupByOutputType[P]>
        }
      >
    >


  export type CompanyTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    tagId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyTag"]>

  export type CompanyTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    tagId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyTag"]>

  export type CompanyTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    companyId?: boolean
    tagId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyTag"]>

  export type CompanyTagSelectScalar = {
    companyId?: boolean
    tagId?: boolean
  }

  export type CompanyTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"companyId" | "tagId", ExtArgs["result"]["companyTag"]>
  export type CompanyTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CompanyTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type CompanyTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $CompanyTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyTag"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      companyId: string
      tagId: string
    }, ExtArgs["result"]["companyTag"]>
    composites: {}
  }

  type CompanyTagGetPayload<S extends boolean | null | undefined | CompanyTagDefaultArgs> = $Result.GetResult<Prisma.$CompanyTagPayload, S>

  type CompanyTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyTagCountAggregateInputType | true
    }

  export interface CompanyTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyTag'], meta: { name: 'CompanyTag' } }
    /**
     * Find zero or one CompanyTag that matches the filter.
     * @param {CompanyTagFindUniqueArgs} args - Arguments to find a CompanyTag
     * @example
     * // Get one CompanyTag
     * const companyTag = await prisma.companyTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyTagFindUniqueArgs>(args: SelectSubset<T, CompanyTagFindUniqueArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyTagFindUniqueOrThrowArgs} args - Arguments to find a CompanyTag
     * @example
     * // Get one CompanyTag
     * const companyTag = await prisma.companyTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagFindFirstArgs} args - Arguments to find a CompanyTag
     * @example
     * // Get one CompanyTag
     * const companyTag = await prisma.companyTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyTagFindFirstArgs>(args?: SelectSubset<T, CompanyTagFindFirstArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagFindFirstOrThrowArgs} args - Arguments to find a CompanyTag
     * @example
     * // Get one CompanyTag
     * const companyTag = await prisma.companyTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyTags
     * const companyTags = await prisma.companyTag.findMany()
     * 
     * // Get first 10 CompanyTags
     * const companyTags = await prisma.companyTag.findMany({ take: 10 })
     * 
     * // Only select the `companyId`
     * const companyTagWithCompanyIdOnly = await prisma.companyTag.findMany({ select: { companyId: true } })
     * 
     */
    findMany<T extends CompanyTagFindManyArgs>(args?: SelectSubset<T, CompanyTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyTag.
     * @param {CompanyTagCreateArgs} args - Arguments to create a CompanyTag.
     * @example
     * // Create one CompanyTag
     * const CompanyTag = await prisma.companyTag.create({
     *   data: {
     *     // ... data to create a CompanyTag
     *   }
     * })
     * 
     */
    create<T extends CompanyTagCreateArgs>(args: SelectSubset<T, CompanyTagCreateArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyTags.
     * @param {CompanyTagCreateManyArgs} args - Arguments to create many CompanyTags.
     * @example
     * // Create many CompanyTags
     * const companyTag = await prisma.companyTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyTagCreateManyArgs>(args?: SelectSubset<T, CompanyTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyTags and returns the data saved in the database.
     * @param {CompanyTagCreateManyAndReturnArgs} args - Arguments to create many CompanyTags.
     * @example
     * // Create many CompanyTags
     * const companyTag = await prisma.companyTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyTags and only return the `companyId`
     * const companyTagWithCompanyIdOnly = await prisma.companyTag.createManyAndReturn({
     *   select: { companyId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyTag.
     * @param {CompanyTagDeleteArgs} args - Arguments to delete one CompanyTag.
     * @example
     * // Delete one CompanyTag
     * const CompanyTag = await prisma.companyTag.delete({
     *   where: {
     *     // ... filter to delete one CompanyTag
     *   }
     * })
     * 
     */
    delete<T extends CompanyTagDeleteArgs>(args: SelectSubset<T, CompanyTagDeleteArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyTag.
     * @param {CompanyTagUpdateArgs} args - Arguments to update one CompanyTag.
     * @example
     * // Update one CompanyTag
     * const companyTag = await prisma.companyTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyTagUpdateArgs>(args: SelectSubset<T, CompanyTagUpdateArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyTags.
     * @param {CompanyTagDeleteManyArgs} args - Arguments to filter CompanyTags to delete.
     * @example
     * // Delete a few CompanyTags
     * const { count } = await prisma.companyTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyTagDeleteManyArgs>(args?: SelectSubset<T, CompanyTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyTags
     * const companyTag = await prisma.companyTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyTagUpdateManyArgs>(args: SelectSubset<T, CompanyTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyTags and returns the data updated in the database.
     * @param {CompanyTagUpdateManyAndReturnArgs} args - Arguments to update many CompanyTags.
     * @example
     * // Update many CompanyTags
     * const companyTag = await prisma.companyTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyTags and only return the `companyId`
     * const companyTagWithCompanyIdOnly = await prisma.companyTag.updateManyAndReturn({
     *   select: { companyId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyTagUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyTag.
     * @param {CompanyTagUpsertArgs} args - Arguments to update or create a CompanyTag.
     * @example
     * // Update or create a CompanyTag
     * const companyTag = await prisma.companyTag.upsert({
     *   create: {
     *     // ... data to create a CompanyTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyTag we want to update
     *   }
     * })
     */
    upsert<T extends CompanyTagUpsertArgs>(args: SelectSubset<T, CompanyTagUpsertArgs<ExtArgs>>): Prisma__CompanyTagClient<$Result.GetResult<Prisma.$CompanyTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagCountArgs} args - Arguments to filter CompanyTags to count.
     * @example
     * // Count the number of CompanyTags
     * const count = await prisma.companyTag.count({
     *   where: {
     *     // ... the filter for the CompanyTags we want to count
     *   }
     * })
    **/
    count<T extends CompanyTagCountArgs>(
      args?: Subset<T, CompanyTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyTagAggregateArgs>(args: Subset<T, CompanyTagAggregateArgs>): Prisma.PrismaPromise<GetCompanyTagAggregateType<T>>

    /**
     * Group by CompanyTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyTagGroupByArgs['orderBy'] }
        : { orderBy?: CompanyTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyTag model
   */
  readonly fields: CompanyTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyTag model
   */
  interface CompanyTagFieldRefs {
    readonly companyId: FieldRef<"CompanyTag", 'String'>
    readonly tagId: FieldRef<"CompanyTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CompanyTag findUnique
   */
  export type CompanyTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTag to fetch.
     */
    where: CompanyTagWhereUniqueInput
  }

  /**
   * CompanyTag findUniqueOrThrow
   */
  export type CompanyTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTag to fetch.
     */
    where: CompanyTagWhereUniqueInput
  }

  /**
   * CompanyTag findFirst
   */
  export type CompanyTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTag to fetch.
     */
    where?: CompanyTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTags to fetch.
     */
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyTags.
     */
    cursor?: CompanyTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyTags.
     */
    distinct?: CompanyTagScalarFieldEnum | CompanyTagScalarFieldEnum[]
  }

  /**
   * CompanyTag findFirstOrThrow
   */
  export type CompanyTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTag to fetch.
     */
    where?: CompanyTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTags to fetch.
     */
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyTags.
     */
    cursor?: CompanyTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyTags.
     */
    distinct?: CompanyTagScalarFieldEnum | CompanyTagScalarFieldEnum[]
  }

  /**
   * CompanyTag findMany
   */
  export type CompanyTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter, which CompanyTags to fetch.
     */
    where?: CompanyTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyTags to fetch.
     */
    orderBy?: CompanyTagOrderByWithRelationInput | CompanyTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyTags.
     */
    cursor?: CompanyTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyTags.
     */
    skip?: number
    distinct?: CompanyTagScalarFieldEnum | CompanyTagScalarFieldEnum[]
  }

  /**
   * CompanyTag create
   */
  export type CompanyTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyTag.
     */
    data: XOR<CompanyTagCreateInput, CompanyTagUncheckedCreateInput>
  }

  /**
   * CompanyTag createMany
   */
  export type CompanyTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyTags.
     */
    data: CompanyTagCreateManyInput | CompanyTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyTag createManyAndReturn
   */
  export type CompanyTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyTags.
     */
    data: CompanyTagCreateManyInput | CompanyTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyTag update
   */
  export type CompanyTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyTag.
     */
    data: XOR<CompanyTagUpdateInput, CompanyTagUncheckedUpdateInput>
    /**
     * Choose, which CompanyTag to update.
     */
    where: CompanyTagWhereUniqueInput
  }

  /**
   * CompanyTag updateMany
   */
  export type CompanyTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyTags.
     */
    data: XOR<CompanyTagUpdateManyMutationInput, CompanyTagUncheckedUpdateManyInput>
    /**
     * Filter which CompanyTags to update
     */
    where?: CompanyTagWhereInput
    /**
     * Limit how many CompanyTags to update.
     */
    limit?: number
  }

  /**
   * CompanyTag updateManyAndReturn
   */
  export type CompanyTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * The data used to update CompanyTags.
     */
    data: XOR<CompanyTagUpdateManyMutationInput, CompanyTagUncheckedUpdateManyInput>
    /**
     * Filter which CompanyTags to update
     */
    where?: CompanyTagWhereInput
    /**
     * Limit how many CompanyTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyTag upsert
   */
  export type CompanyTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyTag to update in case it exists.
     */
    where: CompanyTagWhereUniqueInput
    /**
     * In case the CompanyTag found by the `where` argument doesn't exist, create a new CompanyTag with this data.
     */
    create: XOR<CompanyTagCreateInput, CompanyTagUncheckedCreateInput>
    /**
     * In case the CompanyTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyTagUpdateInput, CompanyTagUncheckedUpdateInput>
  }

  /**
   * CompanyTag delete
   */
  export type CompanyTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
    /**
     * Filter which CompanyTag to delete.
     */
    where: CompanyTagWhereUniqueInput
  }

  /**
   * CompanyTag deleteMany
   */
  export type CompanyTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyTags to delete
     */
    where?: CompanyTagWhereInput
    /**
     * Limit how many CompanyTags to delete.
     */
    limit?: number
  }

  /**
   * CompanyTag without action
   */
  export type CompanyTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyTag
     */
    select?: CompanyTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyTag
     */
    omit?: CompanyTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyTagInclude<ExtArgs> | null
  }


  /**
   * Model ContactTag
   */

  export type AggregateContactTag = {
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  export type ContactTagMinAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagMaxAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagCountAggregateOutputType = {
    contactId: number
    tagId: number
    _all: number
  }


  export type ContactTagMinAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagMaxAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagCountAggregateInputType = {
    contactId?: true
    tagId?: true
    _all?: true
  }

  export type ContactTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTag to aggregate.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTags
    **/
    _count?: true | ContactTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTagMaxAggregateInputType
  }

  export type GetContactTagAggregateType<T extends ContactTagAggregateArgs> = {
        [P in keyof T & keyof AggregateContactTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactTag[P]>
      : GetScalarType<T[P], AggregateContactTag[P]>
  }




  export type ContactTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithAggregationInput | ContactTagOrderByWithAggregationInput[]
    by: ContactTagScalarFieldEnum[] | ContactTagScalarFieldEnum
    having?: ContactTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTagCountAggregateInputType | true
    _min?: ContactTagMinAggregateInputType
    _max?: ContactTagMaxAggregateInputType
  }

  export type ContactTagGroupByOutputType = {
    contactId: string
    tagId: string
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  type GetContactTagGroupByPayload<T extends ContactTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
        }
      >
    >


  export type ContactTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectScalar = {
    contactId?: boolean
    tagId?: boolean
  }

  export type ContactTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactId" | "tagId", ExtArgs["result"]["contactTag"]>
  export type ContactTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ContactTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactTag"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      tagId: string
    }, ExtArgs["result"]["contactTag"]>
    composites: {}
  }

  type ContactTagGetPayload<S extends boolean | null | undefined | ContactTagDefaultArgs> = $Result.GetResult<Prisma.$ContactTagPayload, S>

  type ContactTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactTagCountAggregateInputType | true
    }

  export interface ContactTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactTag'], meta: { name: 'ContactTag' } }
    /**
     * Find zero or one ContactTag that matches the filter.
     * @param {ContactTagFindUniqueArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTagFindUniqueArgs>(args: SelectSubset<T, ContactTagFindUniqueArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTagFindUniqueOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTagFindFirstArgs>(args?: SelectSubset<T, ContactTagFindFirstArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTags
     * const contactTags = await prisma.contactTag.findMany()
     * 
     * // Get first 10 ContactTags
     * const contactTags = await prisma.contactTag.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends ContactTagFindManyArgs>(args?: SelectSubset<T, ContactTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactTag.
     * @param {ContactTagCreateArgs} args - Arguments to create a ContactTag.
     * @example
     * // Create one ContactTag
     * const ContactTag = await prisma.contactTag.create({
     *   data: {
     *     // ... data to create a ContactTag
     *   }
     * })
     * 
     */
    create<T extends ContactTagCreateArgs>(args: SelectSubset<T, ContactTagCreateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactTags.
     * @param {ContactTagCreateManyArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTagCreateManyArgs>(args?: SelectSubset<T, ContactTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactTags and returns the data saved in the database.
     * @param {ContactTagCreateManyAndReturnArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.createManyAndReturn({
     *   select: { contactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactTag.
     * @param {ContactTagDeleteArgs} args - Arguments to delete one ContactTag.
     * @example
     * // Delete one ContactTag
     * const ContactTag = await prisma.contactTag.delete({
     *   where: {
     *     // ... filter to delete one ContactTag
     *   }
     * })
     * 
     */
    delete<T extends ContactTagDeleteArgs>(args: SelectSubset<T, ContactTagDeleteArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactTag.
     * @param {ContactTagUpdateArgs} args - Arguments to update one ContactTag.
     * @example
     * // Update one ContactTag
     * const contactTag = await prisma.contactTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTagUpdateArgs>(args: SelectSubset<T, ContactTagUpdateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactTags.
     * @param {ContactTagDeleteManyArgs} args - Arguments to filter ContactTags to delete.
     * @example
     * // Delete a few ContactTags
     * const { count } = await prisma.contactTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTagDeleteManyArgs>(args?: SelectSubset<T, ContactTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTagUpdateManyArgs>(args: SelectSubset<T, ContactTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags and returns the data updated in the database.
     * @param {ContactTagUpdateManyAndReturnArgs} args - Arguments to update many ContactTags.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.updateManyAndReturn({
     *   select: { contactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactTag.
     * @param {ContactTagUpsertArgs} args - Arguments to update or create a ContactTag.
     * @example
     * // Update or create a ContactTag
     * const contactTag = await prisma.contactTag.upsert({
     *   create: {
     *     // ... data to create a ContactTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactTag we want to update
     *   }
     * })
     */
    upsert<T extends ContactTagUpsertArgs>(args: SelectSubset<T, ContactTagUpsertArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagCountArgs} args - Arguments to filter ContactTags to count.
     * @example
     * // Count the number of ContactTags
     * const count = await prisma.contactTag.count({
     *   where: {
     *     // ... the filter for the ContactTags we want to count
     *   }
     * })
    **/
    count<T extends ContactTagCountArgs>(
      args?: Subset<T, ContactTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTagAggregateArgs>(args: Subset<T, ContactTagAggregateArgs>): Prisma.PrismaPromise<GetContactTagAggregateType<T>>

    /**
     * Group by ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTagGroupByArgs['orderBy'] }
        : { orderBy?: ContactTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactTag model
   */
  readonly fields: ContactTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactTag model
   */
  interface ContactTagFieldRefs {
    readonly contactId: FieldRef<"ContactTag", 'String'>
    readonly tagId: FieldRef<"ContactTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactTag findUnique
   */
  export type ContactTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findUniqueOrThrow
   */
  export type ContactTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findFirst
   */
  export type ContactTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findFirstOrThrow
   */
  export type ContactTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findMany
   */
  export type ContactTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTags to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag create
   */
  export type ContactTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactTag.
     */
    data: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
  }

  /**
   * ContactTag createMany
   */
  export type ContactTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactTag createManyAndReturn
   */
  export type ContactTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag update
   */
  export type ContactTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactTag.
     */
    data: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
    /**
     * Choose, which ContactTag to update.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag updateMany
   */
  export type ContactTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
  }

  /**
   * ContactTag updateManyAndReturn
   */
  export type ContactTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag upsert
   */
  export type ContactTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactTag to update in case it exists.
     */
    where: ContactTagWhereUniqueInput
    /**
     * In case the ContactTag found by the `where` argument doesn't exist, create a new ContactTag with this data.
     */
    create: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
    /**
     * In case the ContactTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
  }

  /**
   * ContactTag delete
   */
  export type ContactTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter which ContactTag to delete.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag deleteMany
   */
  export type ContactTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTags to delete
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to delete.
     */
    limit?: number
  }

  /**
   * ContactTag without action
   */
  export type ContactTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
  }


  /**
   * Model DraftTag
   */

  export type AggregateDraftTag = {
    _count: DraftTagCountAggregateOutputType | null
    _min: DraftTagMinAggregateOutputType | null
    _max: DraftTagMaxAggregateOutputType | null
  }

  export type DraftTagMinAggregateOutputType = {
    draftId: string | null
    tagId: string | null
  }

  export type DraftTagMaxAggregateOutputType = {
    draftId: string | null
    tagId: string | null
  }

  export type DraftTagCountAggregateOutputType = {
    draftId: number
    tagId: number
    _all: number
  }


  export type DraftTagMinAggregateInputType = {
    draftId?: true
    tagId?: true
  }

  export type DraftTagMaxAggregateInputType = {
    draftId?: true
    tagId?: true
  }

  export type DraftTagCountAggregateInputType = {
    draftId?: true
    tagId?: true
    _all?: true
  }

  export type DraftTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftTag to aggregate.
     */
    where?: DraftTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftTags to fetch.
     */
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DraftTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DraftTags
    **/
    _count?: true | DraftTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DraftTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DraftTagMaxAggregateInputType
  }

  export type GetDraftTagAggregateType<T extends DraftTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDraftTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDraftTag[P]>
      : GetScalarType<T[P], AggregateDraftTag[P]>
  }




  export type DraftTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DraftTagWhereInput
    orderBy?: DraftTagOrderByWithAggregationInput | DraftTagOrderByWithAggregationInput[]
    by: DraftTagScalarFieldEnum[] | DraftTagScalarFieldEnum
    having?: DraftTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DraftTagCountAggregateInputType | true
    _min?: DraftTagMinAggregateInputType
    _max?: DraftTagMaxAggregateInputType
  }

  export type DraftTagGroupByOutputType = {
    draftId: string
    tagId: string
    _count: DraftTagCountAggregateOutputType | null
    _min: DraftTagMinAggregateOutputType | null
    _max: DraftTagMaxAggregateOutputType | null
  }

  type GetDraftTagGroupByPayload<T extends DraftTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DraftTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DraftTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DraftTagGroupByOutputType[P]>
            : GetScalarType<T[P], DraftTagGroupByOutputType[P]>
        }
      >
    >


  export type DraftTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    tagId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftTag"]>

  export type DraftTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    tagId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftTag"]>

  export type DraftTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draftId?: boolean
    tagId?: boolean
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["draftTag"]>

  export type DraftTagSelectScalar = {
    draftId?: boolean
    tagId?: boolean
  }

  export type DraftTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"draftId" | "tagId", ExtArgs["result"]["draftTag"]>
  export type DraftTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DraftTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type DraftTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    draft?: boolean | DraftDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $DraftTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DraftTag"
    objects: {
      draft: Prisma.$DraftPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      draftId: string
      tagId: string
    }, ExtArgs["result"]["draftTag"]>
    composites: {}
  }

  type DraftTagGetPayload<S extends boolean | null | undefined | DraftTagDefaultArgs> = $Result.GetResult<Prisma.$DraftTagPayload, S>

  type DraftTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DraftTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DraftTagCountAggregateInputType | true
    }

  export interface DraftTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DraftTag'], meta: { name: 'DraftTag' } }
    /**
     * Find zero or one DraftTag that matches the filter.
     * @param {DraftTagFindUniqueArgs} args - Arguments to find a DraftTag
     * @example
     * // Get one DraftTag
     * const draftTag = await prisma.draftTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DraftTagFindUniqueArgs>(args: SelectSubset<T, DraftTagFindUniqueArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DraftTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DraftTagFindUniqueOrThrowArgs} args - Arguments to find a DraftTag
     * @example
     * // Get one DraftTag
     * const draftTag = await prisma.draftTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DraftTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DraftTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagFindFirstArgs} args - Arguments to find a DraftTag
     * @example
     * // Get one DraftTag
     * const draftTag = await prisma.draftTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DraftTagFindFirstArgs>(args?: SelectSubset<T, DraftTagFindFirstArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DraftTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagFindFirstOrThrowArgs} args - Arguments to find a DraftTag
     * @example
     * // Get one DraftTag
     * const draftTag = await prisma.draftTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DraftTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DraftTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DraftTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DraftTags
     * const draftTags = await prisma.draftTag.findMany()
     * 
     * // Get first 10 DraftTags
     * const draftTags = await prisma.draftTag.findMany({ take: 10 })
     * 
     * // Only select the `draftId`
     * const draftTagWithDraftIdOnly = await prisma.draftTag.findMany({ select: { draftId: true } })
     * 
     */
    findMany<T extends DraftTagFindManyArgs>(args?: SelectSubset<T, DraftTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DraftTag.
     * @param {DraftTagCreateArgs} args - Arguments to create a DraftTag.
     * @example
     * // Create one DraftTag
     * const DraftTag = await prisma.draftTag.create({
     *   data: {
     *     // ... data to create a DraftTag
     *   }
     * })
     * 
     */
    create<T extends DraftTagCreateArgs>(args: SelectSubset<T, DraftTagCreateArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DraftTags.
     * @param {DraftTagCreateManyArgs} args - Arguments to create many DraftTags.
     * @example
     * // Create many DraftTags
     * const draftTag = await prisma.draftTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DraftTagCreateManyArgs>(args?: SelectSubset<T, DraftTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DraftTags and returns the data saved in the database.
     * @param {DraftTagCreateManyAndReturnArgs} args - Arguments to create many DraftTags.
     * @example
     * // Create many DraftTags
     * const draftTag = await prisma.draftTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DraftTags and only return the `draftId`
     * const draftTagWithDraftIdOnly = await prisma.draftTag.createManyAndReturn({
     *   select: { draftId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DraftTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DraftTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DraftTag.
     * @param {DraftTagDeleteArgs} args - Arguments to delete one DraftTag.
     * @example
     * // Delete one DraftTag
     * const DraftTag = await prisma.draftTag.delete({
     *   where: {
     *     // ... filter to delete one DraftTag
     *   }
     * })
     * 
     */
    delete<T extends DraftTagDeleteArgs>(args: SelectSubset<T, DraftTagDeleteArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DraftTag.
     * @param {DraftTagUpdateArgs} args - Arguments to update one DraftTag.
     * @example
     * // Update one DraftTag
     * const draftTag = await prisma.draftTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DraftTagUpdateArgs>(args: SelectSubset<T, DraftTagUpdateArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DraftTags.
     * @param {DraftTagDeleteManyArgs} args - Arguments to filter DraftTags to delete.
     * @example
     * // Delete a few DraftTags
     * const { count } = await prisma.draftTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DraftTagDeleteManyArgs>(args?: SelectSubset<T, DraftTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DraftTags
     * const draftTag = await prisma.draftTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DraftTagUpdateManyArgs>(args: SelectSubset<T, DraftTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DraftTags and returns the data updated in the database.
     * @param {DraftTagUpdateManyAndReturnArgs} args - Arguments to update many DraftTags.
     * @example
     * // Update many DraftTags
     * const draftTag = await prisma.draftTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DraftTags and only return the `draftId`
     * const draftTagWithDraftIdOnly = await prisma.draftTag.updateManyAndReturn({
     *   select: { draftId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DraftTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DraftTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DraftTag.
     * @param {DraftTagUpsertArgs} args - Arguments to update or create a DraftTag.
     * @example
     * // Update or create a DraftTag
     * const draftTag = await prisma.draftTag.upsert({
     *   create: {
     *     // ... data to create a DraftTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DraftTag we want to update
     *   }
     * })
     */
    upsert<T extends DraftTagUpsertArgs>(args: SelectSubset<T, DraftTagUpsertArgs<ExtArgs>>): Prisma__DraftTagClient<$Result.GetResult<Prisma.$DraftTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DraftTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagCountArgs} args - Arguments to filter DraftTags to count.
     * @example
     * // Count the number of DraftTags
     * const count = await prisma.draftTag.count({
     *   where: {
     *     // ... the filter for the DraftTags we want to count
     *   }
     * })
    **/
    count<T extends DraftTagCountArgs>(
      args?: Subset<T, DraftTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DraftTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DraftTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DraftTagAggregateArgs>(args: Subset<T, DraftTagAggregateArgs>): Prisma.PrismaPromise<GetDraftTagAggregateType<T>>

    /**
     * Group by DraftTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DraftTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DraftTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DraftTagGroupByArgs['orderBy'] }
        : { orderBy?: DraftTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DraftTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDraftTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DraftTag model
   */
  readonly fields: DraftTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DraftTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DraftTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    draft<T extends DraftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DraftDefaultArgs<ExtArgs>>): Prisma__DraftClient<$Result.GetResult<Prisma.$DraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DraftTag model
   */
  interface DraftTagFieldRefs {
    readonly draftId: FieldRef<"DraftTag", 'String'>
    readonly tagId: FieldRef<"DraftTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DraftTag findUnique
   */
  export type DraftTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter, which DraftTag to fetch.
     */
    where: DraftTagWhereUniqueInput
  }

  /**
   * DraftTag findUniqueOrThrow
   */
  export type DraftTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter, which DraftTag to fetch.
     */
    where: DraftTagWhereUniqueInput
  }

  /**
   * DraftTag findFirst
   */
  export type DraftTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter, which DraftTag to fetch.
     */
    where?: DraftTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftTags to fetch.
     */
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftTags.
     */
    cursor?: DraftTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftTags.
     */
    distinct?: DraftTagScalarFieldEnum | DraftTagScalarFieldEnum[]
  }

  /**
   * DraftTag findFirstOrThrow
   */
  export type DraftTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter, which DraftTag to fetch.
     */
    where?: DraftTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftTags to fetch.
     */
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DraftTags.
     */
    cursor?: DraftTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DraftTags.
     */
    distinct?: DraftTagScalarFieldEnum | DraftTagScalarFieldEnum[]
  }

  /**
   * DraftTag findMany
   */
  export type DraftTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter, which DraftTags to fetch.
     */
    where?: DraftTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DraftTags to fetch.
     */
    orderBy?: DraftTagOrderByWithRelationInput | DraftTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DraftTags.
     */
    cursor?: DraftTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DraftTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DraftTags.
     */
    skip?: number
    distinct?: DraftTagScalarFieldEnum | DraftTagScalarFieldEnum[]
  }

  /**
   * DraftTag create
   */
  export type DraftTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DraftTag.
     */
    data: XOR<DraftTagCreateInput, DraftTagUncheckedCreateInput>
  }

  /**
   * DraftTag createMany
   */
  export type DraftTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DraftTags.
     */
    data: DraftTagCreateManyInput | DraftTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DraftTag createManyAndReturn
   */
  export type DraftTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * The data used to create many DraftTags.
     */
    data: DraftTagCreateManyInput | DraftTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftTag update
   */
  export type DraftTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DraftTag.
     */
    data: XOR<DraftTagUpdateInput, DraftTagUncheckedUpdateInput>
    /**
     * Choose, which DraftTag to update.
     */
    where: DraftTagWhereUniqueInput
  }

  /**
   * DraftTag updateMany
   */
  export type DraftTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DraftTags.
     */
    data: XOR<DraftTagUpdateManyMutationInput, DraftTagUncheckedUpdateManyInput>
    /**
     * Filter which DraftTags to update
     */
    where?: DraftTagWhereInput
    /**
     * Limit how many DraftTags to update.
     */
    limit?: number
  }

  /**
   * DraftTag updateManyAndReturn
   */
  export type DraftTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * The data used to update DraftTags.
     */
    data: XOR<DraftTagUpdateManyMutationInput, DraftTagUncheckedUpdateManyInput>
    /**
     * Filter which DraftTags to update
     */
    where?: DraftTagWhereInput
    /**
     * Limit how many DraftTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DraftTag upsert
   */
  export type DraftTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DraftTag to update in case it exists.
     */
    where: DraftTagWhereUniqueInput
    /**
     * In case the DraftTag found by the `where` argument doesn't exist, create a new DraftTag with this data.
     */
    create: XOR<DraftTagCreateInput, DraftTagUncheckedCreateInput>
    /**
     * In case the DraftTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DraftTagUpdateInput, DraftTagUncheckedUpdateInput>
  }

  /**
   * DraftTag delete
   */
  export type DraftTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
    /**
     * Filter which DraftTag to delete.
     */
    where: DraftTagWhereUniqueInput
  }

  /**
   * DraftTag deleteMany
   */
  export type DraftTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DraftTags to delete
     */
    where?: DraftTagWhereInput
    /**
     * Limit how many DraftTags to delete.
     */
    limit?: number
  }

  /**
   * DraftTag without action
   */
  export type DraftTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DraftTag
     */
    select?: DraftTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DraftTag
     */
    omit?: DraftTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DraftTagInclude<ExtArgs> | null
  }


  /**
   * Model EmailTag
   */

  export type AggregateEmailTag = {
    _count: EmailTagCountAggregateOutputType | null
    _min: EmailTagMinAggregateOutputType | null
    _max: EmailTagMaxAggregateOutputType | null
  }

  export type EmailTagMinAggregateOutputType = {
    emailId: string | null
    tagId: string | null
  }

  export type EmailTagMaxAggregateOutputType = {
    emailId: string | null
    tagId: string | null
  }

  export type EmailTagCountAggregateOutputType = {
    emailId: number
    tagId: number
    _all: number
  }


  export type EmailTagMinAggregateInputType = {
    emailId?: true
    tagId?: true
  }

  export type EmailTagMaxAggregateInputType = {
    emailId?: true
    tagId?: true
  }

  export type EmailTagCountAggregateInputType = {
    emailId?: true
    tagId?: true
    _all?: true
  }

  export type EmailTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTag to aggregate.
     */
    where?: EmailTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTags to fetch.
     */
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailTags
    **/
    _count?: true | EmailTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailTagMaxAggregateInputType
  }

  export type GetEmailTagAggregateType<T extends EmailTagAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailTag[P]>
      : GetScalarType<T[P], AggregateEmailTag[P]>
  }




  export type EmailTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailTagWhereInput
    orderBy?: EmailTagOrderByWithAggregationInput | EmailTagOrderByWithAggregationInput[]
    by: EmailTagScalarFieldEnum[] | EmailTagScalarFieldEnum
    having?: EmailTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailTagCountAggregateInputType | true
    _min?: EmailTagMinAggregateInputType
    _max?: EmailTagMaxAggregateInputType
  }

  export type EmailTagGroupByOutputType = {
    emailId: string
    tagId: string
    _count: EmailTagCountAggregateOutputType | null
    _min: EmailTagMinAggregateOutputType | null
    _max: EmailTagMaxAggregateOutputType | null
  }

  type GetEmailTagGroupByPayload<T extends EmailTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailTagGroupByOutputType[P]>
            : GetScalarType<T[P], EmailTagGroupByOutputType[P]>
        }
      >
    >


  export type EmailTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    emailId?: boolean
    tagId?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTag"]>

  export type EmailTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    emailId?: boolean
    tagId?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTag"]>

  export type EmailTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    emailId?: boolean
    tagId?: boolean
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailTag"]>

  export type EmailTagSelectScalar = {
    emailId?: boolean
    tagId?: boolean
  }

  export type EmailTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"emailId" | "tagId", ExtArgs["result"]["emailTag"]>
  export type EmailTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type EmailTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type EmailTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    email?: boolean | EmailDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $EmailTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailTag"
    objects: {
      email: Prisma.$EmailPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      emailId: string
      tagId: string
    }, ExtArgs["result"]["emailTag"]>
    composites: {}
  }

  type EmailTagGetPayload<S extends boolean | null | undefined | EmailTagDefaultArgs> = $Result.GetResult<Prisma.$EmailTagPayload, S>

  type EmailTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailTagCountAggregateInputType | true
    }

  export interface EmailTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailTag'], meta: { name: 'EmailTag' } }
    /**
     * Find zero or one EmailTag that matches the filter.
     * @param {EmailTagFindUniqueArgs} args - Arguments to find a EmailTag
     * @example
     * // Get one EmailTag
     * const emailTag = await prisma.emailTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailTagFindUniqueArgs>(args: SelectSubset<T, EmailTagFindUniqueArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailTagFindUniqueOrThrowArgs} args - Arguments to find a EmailTag
     * @example
     * // Get one EmailTag
     * const emailTag = await prisma.emailTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailTagFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagFindFirstArgs} args - Arguments to find a EmailTag
     * @example
     * // Get one EmailTag
     * const emailTag = await prisma.emailTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailTagFindFirstArgs>(args?: SelectSubset<T, EmailTagFindFirstArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagFindFirstOrThrowArgs} args - Arguments to find a EmailTag
     * @example
     * // Get one EmailTag
     * const emailTag = await prisma.emailTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailTagFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailTags
     * const emailTags = await prisma.emailTag.findMany()
     * 
     * // Get first 10 EmailTags
     * const emailTags = await prisma.emailTag.findMany({ take: 10 })
     * 
     * // Only select the `emailId`
     * const emailTagWithEmailIdOnly = await prisma.emailTag.findMany({ select: { emailId: true } })
     * 
     */
    findMany<T extends EmailTagFindManyArgs>(args?: SelectSubset<T, EmailTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailTag.
     * @param {EmailTagCreateArgs} args - Arguments to create a EmailTag.
     * @example
     * // Create one EmailTag
     * const EmailTag = await prisma.emailTag.create({
     *   data: {
     *     // ... data to create a EmailTag
     *   }
     * })
     * 
     */
    create<T extends EmailTagCreateArgs>(args: SelectSubset<T, EmailTagCreateArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailTags.
     * @param {EmailTagCreateManyArgs} args - Arguments to create many EmailTags.
     * @example
     * // Create many EmailTags
     * const emailTag = await prisma.emailTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailTagCreateManyArgs>(args?: SelectSubset<T, EmailTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailTags and returns the data saved in the database.
     * @param {EmailTagCreateManyAndReturnArgs} args - Arguments to create many EmailTags.
     * @example
     * // Create many EmailTags
     * const emailTag = await prisma.emailTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailTags and only return the `emailId`
     * const emailTagWithEmailIdOnly = await prisma.emailTag.createManyAndReturn({
     *   select: { emailId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailTagCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailTag.
     * @param {EmailTagDeleteArgs} args - Arguments to delete one EmailTag.
     * @example
     * // Delete one EmailTag
     * const EmailTag = await prisma.emailTag.delete({
     *   where: {
     *     // ... filter to delete one EmailTag
     *   }
     * })
     * 
     */
    delete<T extends EmailTagDeleteArgs>(args: SelectSubset<T, EmailTagDeleteArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailTag.
     * @param {EmailTagUpdateArgs} args - Arguments to update one EmailTag.
     * @example
     * // Update one EmailTag
     * const emailTag = await prisma.emailTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailTagUpdateArgs>(args: SelectSubset<T, EmailTagUpdateArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailTags.
     * @param {EmailTagDeleteManyArgs} args - Arguments to filter EmailTags to delete.
     * @example
     * // Delete a few EmailTags
     * const { count } = await prisma.emailTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailTagDeleteManyArgs>(args?: SelectSubset<T, EmailTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailTags
     * const emailTag = await prisma.emailTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailTagUpdateManyArgs>(args: SelectSubset<T, EmailTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailTags and returns the data updated in the database.
     * @param {EmailTagUpdateManyAndReturnArgs} args - Arguments to update many EmailTags.
     * @example
     * // Update many EmailTags
     * const emailTag = await prisma.emailTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailTags and only return the `emailId`
     * const emailTagWithEmailIdOnly = await prisma.emailTag.updateManyAndReturn({
     *   select: { emailId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailTagUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailTag.
     * @param {EmailTagUpsertArgs} args - Arguments to update or create a EmailTag.
     * @example
     * // Update or create a EmailTag
     * const emailTag = await prisma.emailTag.upsert({
     *   create: {
     *     // ... data to create a EmailTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailTag we want to update
     *   }
     * })
     */
    upsert<T extends EmailTagUpsertArgs>(args: SelectSubset<T, EmailTagUpsertArgs<ExtArgs>>): Prisma__EmailTagClient<$Result.GetResult<Prisma.$EmailTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagCountArgs} args - Arguments to filter EmailTags to count.
     * @example
     * // Count the number of EmailTags
     * const count = await prisma.emailTag.count({
     *   where: {
     *     // ... the filter for the EmailTags we want to count
     *   }
     * })
    **/
    count<T extends EmailTagCountArgs>(
      args?: Subset<T, EmailTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailTagAggregateArgs>(args: Subset<T, EmailTagAggregateArgs>): Prisma.PrismaPromise<GetEmailTagAggregateType<T>>

    /**
     * Group by EmailTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailTagGroupByArgs['orderBy'] }
        : { orderBy?: EmailTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailTag model
   */
  readonly fields: EmailTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    email<T extends EmailDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailDefaultArgs<ExtArgs>>): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailTag model
   */
  interface EmailTagFieldRefs {
    readonly emailId: FieldRef<"EmailTag", 'String'>
    readonly tagId: FieldRef<"EmailTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailTag findUnique
   */
  export type EmailTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter, which EmailTag to fetch.
     */
    where: EmailTagWhereUniqueInput
  }

  /**
   * EmailTag findUniqueOrThrow
   */
  export type EmailTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter, which EmailTag to fetch.
     */
    where: EmailTagWhereUniqueInput
  }

  /**
   * EmailTag findFirst
   */
  export type EmailTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter, which EmailTag to fetch.
     */
    where?: EmailTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTags to fetch.
     */
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTags.
     */
    cursor?: EmailTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTags.
     */
    distinct?: EmailTagScalarFieldEnum | EmailTagScalarFieldEnum[]
  }

  /**
   * EmailTag findFirstOrThrow
   */
  export type EmailTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter, which EmailTag to fetch.
     */
    where?: EmailTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTags to fetch.
     */
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailTags.
     */
    cursor?: EmailTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailTags.
     */
    distinct?: EmailTagScalarFieldEnum | EmailTagScalarFieldEnum[]
  }

  /**
   * EmailTag findMany
   */
  export type EmailTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter, which EmailTags to fetch.
     */
    where?: EmailTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailTags to fetch.
     */
    orderBy?: EmailTagOrderByWithRelationInput | EmailTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailTags.
     */
    cursor?: EmailTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailTags.
     */
    skip?: number
    distinct?: EmailTagScalarFieldEnum | EmailTagScalarFieldEnum[]
  }

  /**
   * EmailTag create
   */
  export type EmailTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailTag.
     */
    data: XOR<EmailTagCreateInput, EmailTagUncheckedCreateInput>
  }

  /**
   * EmailTag createMany
   */
  export type EmailTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailTags.
     */
    data: EmailTagCreateManyInput | EmailTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailTag createManyAndReturn
   */
  export type EmailTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * The data used to create many EmailTags.
     */
    data: EmailTagCreateManyInput | EmailTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTag update
   */
  export type EmailTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailTag.
     */
    data: XOR<EmailTagUpdateInput, EmailTagUncheckedUpdateInput>
    /**
     * Choose, which EmailTag to update.
     */
    where: EmailTagWhereUniqueInput
  }

  /**
   * EmailTag updateMany
   */
  export type EmailTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailTags.
     */
    data: XOR<EmailTagUpdateManyMutationInput, EmailTagUncheckedUpdateManyInput>
    /**
     * Filter which EmailTags to update
     */
    where?: EmailTagWhereInput
    /**
     * Limit how many EmailTags to update.
     */
    limit?: number
  }

  /**
   * EmailTag updateManyAndReturn
   */
  export type EmailTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * The data used to update EmailTags.
     */
    data: XOR<EmailTagUpdateManyMutationInput, EmailTagUncheckedUpdateManyInput>
    /**
     * Filter which EmailTags to update
     */
    where?: EmailTagWhereInput
    /**
     * Limit how many EmailTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailTag upsert
   */
  export type EmailTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailTag to update in case it exists.
     */
    where: EmailTagWhereUniqueInput
    /**
     * In case the EmailTag found by the `where` argument doesn't exist, create a new EmailTag with this data.
     */
    create: XOR<EmailTagCreateInput, EmailTagUncheckedCreateInput>
    /**
     * In case the EmailTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailTagUpdateInput, EmailTagUncheckedUpdateInput>
  }

  /**
   * EmailTag delete
   */
  export type EmailTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
    /**
     * Filter which EmailTag to delete.
     */
    where: EmailTagWhereUniqueInput
  }

  /**
   * EmailTag deleteMany
   */
  export type EmailTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailTags to delete
     */
    where?: EmailTagWhereInput
    /**
     * Limit how many EmailTags to delete.
     */
    limit?: number
  }

  /**
   * EmailTag without action
   */
  export type EmailTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailTag
     */
    select?: EmailTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailTag
     */
    omit?: EmailTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailTagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    location: 'location',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    position: 'position',
    email: 'email',
    phone: 'phone',
    linkedInUrl: 'linkedInUrl',
    location: 'location',
    companyId: 'companyId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactEventScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    eventType: 'eventType',
    createdAt: 'createdAt'
  };

  export type ContactEventScalarFieldEnum = (typeof ContactEventScalarFieldEnum)[keyof typeof ContactEventScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    body: 'body',
    messageId: 'messageId',
    contactId: 'contactId',
    isBounced: 'isBounced',
    isSpamReported: 'isSpamReported',
    senderId: 'senderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const EmailEventScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    eventType: 'eventType',
    createdAt: 'createdAt'
  };

  export type EmailEventScalarFieldEnum = (typeof EmailEventScalarFieldEnum)[keyof typeof EmailEventScalarFieldEnum]


  export const FollowUpScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    body: 'body',
    emailId: 'emailId',
    scheduledAt: 'scheduledAt',
    isBounced: 'isBounced',
    isSpamReported: 'isSpamReported',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FollowUpScalarFieldEnum = (typeof FollowUpScalarFieldEnum)[keyof typeof FollowUpScalarFieldEnum]


  export const FollowUpEventScalarFieldEnum: {
    id: 'id',
    followUpId: 'followUpId',
    eventType: 'eventType',
    createdAt: 'createdAt'
  };

  export type FollowUpEventScalarFieldEnum = (typeof FollowUpEventScalarFieldEnum)[keyof typeof FollowUpEventScalarFieldEnum]


  export const DraftScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    body: 'body',
    scheduledAt: 'scheduledAt',
    senderId: 'senderId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DraftScalarFieldEnum = (typeof DraftScalarFieldEnum)[keyof typeof DraftScalarFieldEnum]


  export const DraftContactScalarFieldEnum: {
    draftId: 'draftId',
    contactId: 'contactId'
  };

  export type DraftContactScalarFieldEnum = (typeof DraftContactScalarFieldEnum)[keyof typeof DraftContactScalarFieldEnum]


  export const LLMLogScalarFieldEnum: {
    id: 'id',
    prompt: 'prompt',
    response: 'response',
    isError: 'isError',
    createdAt: 'createdAt'
  };

  export type LLMLogScalarFieldEnum = (typeof LLMLogScalarFieldEnum)[keyof typeof LLMLogScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    platform: 'platform',
    body: 'body',
    createdAt: 'createdAt'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    emailId: 'emailId',
    type: 'type',
    isRead: 'isRead',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SenderScalarFieldEnum: {
    id: 'id',
    displayName: 'displayName',
    name: 'name',
    email: 'email',
    apiKey: 'apiKey',
    esp: 'esp',
    priority: 'priority',
    target: 'target',
    sentCount: 'sentCount',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SenderScalarFieldEnum = (typeof SenderScalarFieldEnum)[keyof typeof SenderScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    title: 'title',
    isDeleted: 'isDeleted'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const CompanyTagScalarFieldEnum: {
    companyId: 'companyId',
    tagId: 'tagId'
  };

  export type CompanyTagScalarFieldEnum = (typeof CompanyTagScalarFieldEnum)[keyof typeof CompanyTagScalarFieldEnum]


  export const ContactTagScalarFieldEnum: {
    contactId: 'contactId',
    tagId: 'tagId'
  };

  export type ContactTagScalarFieldEnum = (typeof ContactTagScalarFieldEnum)[keyof typeof ContactTagScalarFieldEnum]


  export const DraftTagScalarFieldEnum: {
    draftId: 'draftId',
    tagId: 'tagId'
  };

  export type DraftTagScalarFieldEnum = (typeof DraftTagScalarFieldEnum)[keyof typeof DraftTagScalarFieldEnum]


  export const EmailTagScalarFieldEnum: {
    emailId: 'emailId',
    tagId: 'tagId'
  };

  export type EmailTagScalarFieldEnum = (typeof EmailTagScalarFieldEnum)[keyof typeof EmailTagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ContactEventType'
   */
  export type EnumContactEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactEventType'>
    


  /**
   * Reference to a field of type 'ContactEventType[]'
   */
  export type ListEnumContactEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactEventType[]'>
    


  /**
   * Reference to a field of type 'EmailEventType'
   */
  export type EnumEmailEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailEventType'>
    


  /**
   * Reference to a field of type 'EmailEventType[]'
   */
  export type ListEnumEmailEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmailEventType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    title?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    location?: StringFilter<"Company"> | string
    isDeleted?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    companyTags?: CompanyTagListRelationFilter
    contacts?: ContactListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyTags?: CompanyTagOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    title?: StringFilter<"Company"> | string
    description?: StringNullableFilter<"Company"> | string | null
    location?: StringFilter<"Company"> | string
    isDeleted?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    companyTags?: CompanyTagListRelationFilter
    contacts?: ContactListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    title?: StringWithAggregatesFilter<"Company"> | string
    description?: StringNullableWithAggregatesFilter<"Company"> | string | null
    location?: StringWithAggregatesFilter<"Company"> | string
    isDeleted?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    position?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    linkedInUrl?: StringNullableFilter<"Contact"> | string | null
    location?: StringNullableFilter<"Contact"> | string | null
    companyId?: StringNullableFilter<"Contact"> | string | null
    isDeleted?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    contactTags?: ContactTagListRelationFilter
    events?: ContactEventListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    contactDrafts?: DraftContactListRelationFilter
    emails?: EmailListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    linkedInUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactTags?: ContactTagOrderByRelationAggregateInput
    events?: ContactEventOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
    contactDrafts?: DraftContactOrderByRelationAggregateInput
    emails?: EmailOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    position?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    linkedInUrl?: StringNullableFilter<"Contact"> | string | null
    location?: StringNullableFilter<"Contact"> | string | null
    companyId?: StringNullableFilter<"Contact"> | string | null
    isDeleted?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    contactTags?: ContactTagListRelationFilter
    events?: ContactEventListRelationFilter
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
    contactDrafts?: DraftContactListRelationFilter
    emails?: EmailListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    linkedInUrl?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    position?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringWithAggregatesFilter<"Contact"> | string
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    linkedInUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    location?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Contact"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ContactEventWhereInput = {
    AND?: ContactEventWhereInput | ContactEventWhereInput[]
    OR?: ContactEventWhereInput[]
    NOT?: ContactEventWhereInput | ContactEventWhereInput[]
    id?: StringFilter<"ContactEvent"> | string
    contactId?: StringFilter<"ContactEvent"> | string
    eventType?: EnumContactEventTypeFilter<"ContactEvent"> | $Enums.ContactEventType
    createdAt?: DateTimeFilter<"ContactEvent"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ContactEventOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
  }

  export type ContactEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactEventWhereInput | ContactEventWhereInput[]
    OR?: ContactEventWhereInput[]
    NOT?: ContactEventWhereInput | ContactEventWhereInput[]
    contactId?: StringFilter<"ContactEvent"> | string
    eventType?: EnumContactEventTypeFilter<"ContactEvent"> | $Enums.ContactEventType
    createdAt?: DateTimeFilter<"ContactEvent"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type ContactEventOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    _count?: ContactEventCountOrderByAggregateInput
    _max?: ContactEventMaxOrderByAggregateInput
    _min?: ContactEventMinOrderByAggregateInput
  }

  export type ContactEventScalarWhereWithAggregatesInput = {
    AND?: ContactEventScalarWhereWithAggregatesInput | ContactEventScalarWhereWithAggregatesInput[]
    OR?: ContactEventScalarWhereWithAggregatesInput[]
    NOT?: ContactEventScalarWhereWithAggregatesInput | ContactEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactEvent"> | string
    contactId?: StringWithAggregatesFilter<"ContactEvent"> | string
    eventType?: EnumContactEventTypeWithAggregatesFilter<"ContactEvent"> | $Enums.ContactEventType
    createdAt?: DateTimeWithAggregatesFilter<"ContactEvent"> | Date | string
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    messageId?: StringNullableFilter<"Email"> | string | null
    contactId?: StringFilter<"Email"> | string
    isBounced?: BoolFilter<"Email"> | boolean
    isSpamReported?: BoolFilter<"Email"> | boolean
    senderId?: StringFilter<"Email"> | string
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    sender?: XOR<SenderScalarRelationFilter, SenderWhereInput>
    emailTags?: EmailTagListRelationFilter
    events?: EmailEventListRelationFilter
    followUps?: FollowUpListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    messageId?: SortOrderInput | SortOrder
    contactId?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    sender?: SenderOrderByWithRelationInput
    emailTags?: EmailTagOrderByRelationAggregateInput
    events?: EmailEventOrderByRelationAggregateInput
    followUps?: FollowUpOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    messageId?: StringNullableFilter<"Email"> | string | null
    contactId?: StringFilter<"Email"> | string
    isBounced?: BoolFilter<"Email"> | boolean
    isSpamReported?: BoolFilter<"Email"> | boolean
    senderId?: StringFilter<"Email"> | string
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    sender?: XOR<SenderScalarRelationFilter, SenderWhereInput>
    emailTags?: EmailTagListRelationFilter
    events?: EmailEventListRelationFilter
    followUps?: FollowUpListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    messageId?: SortOrderInput | SortOrder
    contactId?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailCountOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Email"> | string
    subject?: StringWithAggregatesFilter<"Email"> | string
    body?: StringWithAggregatesFilter<"Email"> | string
    messageId?: StringNullableWithAggregatesFilter<"Email"> | string | null
    contactId?: StringWithAggregatesFilter<"Email"> | string
    isBounced?: BoolWithAggregatesFilter<"Email"> | boolean
    isSpamReported?: BoolWithAggregatesFilter<"Email"> | boolean
    senderId?: StringWithAggregatesFilter<"Email"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
  }

  export type EmailEventWhereInput = {
    AND?: EmailEventWhereInput | EmailEventWhereInput[]
    OR?: EmailEventWhereInput[]
    NOT?: EmailEventWhereInput | EmailEventWhereInput[]
    id?: StringFilter<"EmailEvent"> | string
    emailId?: StringFilter<"EmailEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"EmailEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type EmailEventOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type EmailEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailEventWhereInput | EmailEventWhereInput[]
    OR?: EmailEventWhereInput[]
    NOT?: EmailEventWhereInput | EmailEventWhereInput[]
    emailId?: StringFilter<"EmailEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"EmailEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id">

  export type EmailEventOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    _count?: EmailEventCountOrderByAggregateInput
    _max?: EmailEventMaxOrderByAggregateInput
    _min?: EmailEventMinOrderByAggregateInput
  }

  export type EmailEventScalarWhereWithAggregatesInput = {
    AND?: EmailEventScalarWhereWithAggregatesInput | EmailEventScalarWhereWithAggregatesInput[]
    OR?: EmailEventScalarWhereWithAggregatesInput[]
    NOT?: EmailEventScalarWhereWithAggregatesInput | EmailEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailEvent"> | string
    emailId?: StringWithAggregatesFilter<"EmailEvent"> | string
    eventType?: EnumEmailEventTypeWithAggregatesFilter<"EmailEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeWithAggregatesFilter<"EmailEvent"> | Date | string
  }

  export type FollowUpWhereInput = {
    AND?: FollowUpWhereInput | FollowUpWhereInput[]
    OR?: FollowUpWhereInput[]
    NOT?: FollowUpWhereInput | FollowUpWhereInput[]
    id?: StringFilter<"FollowUp"> | string
    subject?: StringFilter<"FollowUp"> | string
    body?: StringFilter<"FollowUp"> | string
    emailId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    isBounced?: BoolFilter<"FollowUp"> | boolean
    isSpamReported?: BoolFilter<"FollowUp"> | boolean
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUp"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
    events?: FollowUpEventListRelationFilter
  }

  export type FollowUpOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    emailId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: EmailOrderByWithRelationInput
    events?: FollowUpEventOrderByRelationAggregateInput
  }

  export type FollowUpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowUpWhereInput | FollowUpWhereInput[]
    OR?: FollowUpWhereInput[]
    NOT?: FollowUpWhereInput | FollowUpWhereInput[]
    subject?: StringFilter<"FollowUp"> | string
    body?: StringFilter<"FollowUp"> | string
    emailId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    isBounced?: BoolFilter<"FollowUp"> | boolean
    isSpamReported?: BoolFilter<"FollowUp"> | boolean
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUp"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
    events?: FollowUpEventListRelationFilter
  }, "id">

  export type FollowUpOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    emailId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FollowUpCountOrderByAggregateInput
    _max?: FollowUpMaxOrderByAggregateInput
    _min?: FollowUpMinOrderByAggregateInput
  }

  export type FollowUpScalarWhereWithAggregatesInput = {
    AND?: FollowUpScalarWhereWithAggregatesInput | FollowUpScalarWhereWithAggregatesInput[]
    OR?: FollowUpScalarWhereWithAggregatesInput[]
    NOT?: FollowUpScalarWhereWithAggregatesInput | FollowUpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowUp"> | string
    subject?: StringWithAggregatesFilter<"FollowUp"> | string
    body?: StringWithAggregatesFilter<"FollowUp"> | string
    emailId?: StringWithAggregatesFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"FollowUp"> | Date | string | null
    isBounced?: BoolWithAggregatesFilter<"FollowUp"> | boolean
    isSpamReported?: BoolWithAggregatesFilter<"FollowUp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FollowUp"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FollowUp"> | Date | string
  }

  export type FollowUpEventWhereInput = {
    AND?: FollowUpEventWhereInput | FollowUpEventWhereInput[]
    OR?: FollowUpEventWhereInput[]
    NOT?: FollowUpEventWhereInput | FollowUpEventWhereInput[]
    id?: StringFilter<"FollowUpEvent"> | string
    followUpId?: StringFilter<"FollowUpEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"FollowUpEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"FollowUpEvent"> | Date | string
    FollowUp?: XOR<FollowUpScalarRelationFilter, FollowUpWhereInput>
  }

  export type FollowUpEventOrderByWithRelationInput = {
    id?: SortOrder
    followUpId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    FollowUp?: FollowUpOrderByWithRelationInput
  }

  export type FollowUpEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowUpEventWhereInput | FollowUpEventWhereInput[]
    OR?: FollowUpEventWhereInput[]
    NOT?: FollowUpEventWhereInput | FollowUpEventWhereInput[]
    followUpId?: StringFilter<"FollowUpEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"FollowUpEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"FollowUpEvent"> | Date | string
    FollowUp?: XOR<FollowUpScalarRelationFilter, FollowUpWhereInput>
  }, "id">

  export type FollowUpEventOrderByWithAggregationInput = {
    id?: SortOrder
    followUpId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
    _count?: FollowUpEventCountOrderByAggregateInput
    _max?: FollowUpEventMaxOrderByAggregateInput
    _min?: FollowUpEventMinOrderByAggregateInput
  }

  export type FollowUpEventScalarWhereWithAggregatesInput = {
    AND?: FollowUpEventScalarWhereWithAggregatesInput | FollowUpEventScalarWhereWithAggregatesInput[]
    OR?: FollowUpEventScalarWhereWithAggregatesInput[]
    NOT?: FollowUpEventScalarWhereWithAggregatesInput | FollowUpEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowUpEvent"> | string
    followUpId?: StringWithAggregatesFilter<"FollowUpEvent"> | string
    eventType?: EnumEmailEventTypeWithAggregatesFilter<"FollowUpEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeWithAggregatesFilter<"FollowUpEvent"> | Date | string
  }

  export type DraftWhereInput = {
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    id?: StringFilter<"Draft"> | string
    subject?: StringNullableFilter<"Draft"> | string | null
    body?: StringNullableFilter<"Draft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
    senderId?: StringNullableFilter<"Draft"> | string | null
    createdAt?: DateTimeFilter<"Draft"> | Date | string
    updatedAt?: DateTimeFilter<"Draft"> | Date | string
    sender?: XOR<SenderNullableScalarRelationFilter, SenderWhereInput> | null
    draftContacts?: DraftContactListRelationFilter
    draftTags?: DraftTagListRelationFilter
  }

  export type DraftOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: SenderOrderByWithRelationInput
    draftContacts?: DraftContactOrderByRelationAggregateInput
    draftTags?: DraftTagOrderByRelationAggregateInput
  }

  export type DraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DraftWhereInput | DraftWhereInput[]
    OR?: DraftWhereInput[]
    NOT?: DraftWhereInput | DraftWhereInput[]
    subject?: StringNullableFilter<"Draft"> | string | null
    body?: StringNullableFilter<"Draft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
    senderId?: StringNullableFilter<"Draft"> | string | null
    createdAt?: DateTimeFilter<"Draft"> | Date | string
    updatedAt?: DateTimeFilter<"Draft"> | Date | string
    sender?: XOR<SenderNullableScalarRelationFilter, SenderWhereInput> | null
    draftContacts?: DraftContactListRelationFilter
    draftTags?: DraftTagListRelationFilter
  }, "id">

  export type DraftOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrderInput | SortOrder
    body?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DraftCountOrderByAggregateInput
    _max?: DraftMaxOrderByAggregateInput
    _min?: DraftMinOrderByAggregateInput
  }

  export type DraftScalarWhereWithAggregatesInput = {
    AND?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    OR?: DraftScalarWhereWithAggregatesInput[]
    NOT?: DraftScalarWhereWithAggregatesInput | DraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Draft"> | string
    subject?: StringNullableWithAggregatesFilter<"Draft"> | string | null
    body?: StringNullableWithAggregatesFilter<"Draft"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Draft"> | Date | string | null
    senderId?: StringNullableWithAggregatesFilter<"Draft"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Draft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Draft"> | Date | string
  }

  export type DraftContactWhereInput = {
    AND?: DraftContactWhereInput | DraftContactWhereInput[]
    OR?: DraftContactWhereInput[]
    NOT?: DraftContactWhereInput | DraftContactWhereInput[]
    draftId?: StringFilter<"DraftContact"> | string
    contactId?: StringFilter<"DraftContact"> | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type DraftContactOrderByWithRelationInput = {
    draftId?: SortOrder
    contactId?: SortOrder
    draft?: DraftOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type DraftContactWhereUniqueInput = Prisma.AtLeast<{
    draftId_contactId?: DraftContactDraftIdContactIdCompoundUniqueInput
    AND?: DraftContactWhereInput | DraftContactWhereInput[]
    OR?: DraftContactWhereInput[]
    NOT?: DraftContactWhereInput | DraftContactWhereInput[]
    draftId?: StringFilter<"DraftContact"> | string
    contactId?: StringFilter<"DraftContact"> | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "draftId_contactId">

  export type DraftContactOrderByWithAggregationInput = {
    draftId?: SortOrder
    contactId?: SortOrder
    _count?: DraftContactCountOrderByAggregateInput
    _max?: DraftContactMaxOrderByAggregateInput
    _min?: DraftContactMinOrderByAggregateInput
  }

  export type DraftContactScalarWhereWithAggregatesInput = {
    AND?: DraftContactScalarWhereWithAggregatesInput | DraftContactScalarWhereWithAggregatesInput[]
    OR?: DraftContactScalarWhereWithAggregatesInput[]
    NOT?: DraftContactScalarWhereWithAggregatesInput | DraftContactScalarWhereWithAggregatesInput[]
    draftId?: StringWithAggregatesFilter<"DraftContact"> | string
    contactId?: StringWithAggregatesFilter<"DraftContact"> | string
  }

  export type LLMLogWhereInput = {
    AND?: LLMLogWhereInput | LLMLogWhereInput[]
    OR?: LLMLogWhereInput[]
    NOT?: LLMLogWhereInput | LLMLogWhereInput[]
    id?: StringFilter<"LLMLog"> | string
    prompt?: StringFilter<"LLMLog"> | string
    response?: StringNullableFilter<"LLMLog"> | string | null
    isError?: BoolFilter<"LLMLog"> | boolean
    createdAt?: DateTimeFilter<"LLMLog"> | Date | string
  }

  export type LLMLogOrderByWithRelationInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrderInput | SortOrder
    isError?: SortOrder
    createdAt?: SortOrder
  }

  export type LLMLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LLMLogWhereInput | LLMLogWhereInput[]
    OR?: LLMLogWhereInput[]
    NOT?: LLMLogWhereInput | LLMLogWhereInput[]
    prompt?: StringFilter<"LLMLog"> | string
    response?: StringNullableFilter<"LLMLog"> | string | null
    isError?: BoolFilter<"LLMLog"> | boolean
    createdAt?: DateTimeFilter<"LLMLog"> | Date | string
  }, "id">

  export type LLMLogOrderByWithAggregationInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrderInput | SortOrder
    isError?: SortOrder
    createdAt?: SortOrder
    _count?: LLMLogCountOrderByAggregateInput
    _max?: LLMLogMaxOrderByAggregateInput
    _min?: LLMLogMinOrderByAggregateInput
  }

  export type LLMLogScalarWhereWithAggregatesInput = {
    AND?: LLMLogScalarWhereWithAggregatesInput | LLMLogScalarWhereWithAggregatesInput[]
    OR?: LLMLogScalarWhereWithAggregatesInput[]
    NOT?: LLMLogScalarWhereWithAggregatesInput | LLMLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LLMLog"> | string
    prompt?: StringWithAggregatesFilter<"LLMLog"> | string
    response?: StringNullableWithAggregatesFilter<"LLMLog"> | string | null
    isError?: BoolWithAggregatesFilter<"LLMLog"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LLMLog"> | Date | string
  }

  export type WebhookLogWhereInput = {
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    id?: StringFilter<"WebhookLog"> | string
    platform?: StringFilter<"WebhookLog"> | string
    body?: StringNullableFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }

  export type WebhookLogOrderByWithRelationInput = {
    id?: SortOrder
    platform?: SortOrder
    body?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookLogWhereInput | WebhookLogWhereInput[]
    OR?: WebhookLogWhereInput[]
    NOT?: WebhookLogWhereInput | WebhookLogWhereInput[]
    platform?: StringFilter<"WebhookLog"> | string
    body?: StringNullableFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeFilter<"WebhookLog"> | Date | string
  }, "id">

  export type WebhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    platform?: SortOrder
    body?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WebhookLogCountOrderByAggregateInput
    _max?: WebhookLogMaxOrderByAggregateInput
    _min?: WebhookLogMinOrderByAggregateInput
  }

  export type WebhookLogScalarWhereWithAggregatesInput = {
    AND?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    OR?: WebhookLogScalarWhereWithAggregatesInput[]
    NOT?: WebhookLogScalarWhereWithAggregatesInput | WebhookLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookLog"> | string
    platform?: StringWithAggregatesFilter<"WebhookLog"> | string
    body?: StringNullableWithAggregatesFilter<"WebhookLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    emailId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    emailId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    email?: EmailOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    emailId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    emailId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    emailId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SenderWhereInput = {
    AND?: SenderWhereInput | SenderWhereInput[]
    OR?: SenderWhereInput[]
    NOT?: SenderWhereInput | SenderWhereInput[]
    id?: StringFilter<"Sender"> | string
    displayName?: StringFilter<"Sender"> | string
    name?: StringFilter<"Sender"> | string
    email?: StringFilter<"Sender"> | string
    apiKey?: StringFilter<"Sender"> | string
    esp?: StringFilter<"Sender"> | string
    priority?: IntFilter<"Sender"> | number
    target?: IntFilter<"Sender"> | number
    sentCount?: IntFilter<"Sender"> | number
    isDeleted?: BoolFilter<"Sender"> | boolean
    createdAt?: DateTimeFilter<"Sender"> | Date | string
    updatedAt?: DateTimeFilter<"Sender"> | Date | string
    drafts?: DraftListRelationFilter
    emails?: EmailListRelationFilter
  }

  export type SenderOrderByWithRelationInput = {
    id?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    apiKey?: SortOrder
    esp?: SortOrder
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    drafts?: DraftOrderByRelationAggregateInput
    emails?: EmailOrderByRelationAggregateInput
  }

  export type SenderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email_esp?: SenderEmailEspCompoundUniqueInput
    AND?: SenderWhereInput | SenderWhereInput[]
    OR?: SenderWhereInput[]
    NOT?: SenderWhereInput | SenderWhereInput[]
    displayName?: StringFilter<"Sender"> | string
    name?: StringFilter<"Sender"> | string
    email?: StringFilter<"Sender"> | string
    apiKey?: StringFilter<"Sender"> | string
    esp?: StringFilter<"Sender"> | string
    priority?: IntFilter<"Sender"> | number
    target?: IntFilter<"Sender"> | number
    sentCount?: IntFilter<"Sender"> | number
    isDeleted?: BoolFilter<"Sender"> | boolean
    createdAt?: DateTimeFilter<"Sender"> | Date | string
    updatedAt?: DateTimeFilter<"Sender"> | Date | string
    drafts?: DraftListRelationFilter
    emails?: EmailListRelationFilter
  }, "id" | "email_esp">

  export type SenderOrderByWithAggregationInput = {
    id?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    apiKey?: SortOrder
    esp?: SortOrder
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SenderCountOrderByAggregateInput
    _avg?: SenderAvgOrderByAggregateInput
    _max?: SenderMaxOrderByAggregateInput
    _min?: SenderMinOrderByAggregateInput
    _sum?: SenderSumOrderByAggregateInput
  }

  export type SenderScalarWhereWithAggregatesInput = {
    AND?: SenderScalarWhereWithAggregatesInput | SenderScalarWhereWithAggregatesInput[]
    OR?: SenderScalarWhereWithAggregatesInput[]
    NOT?: SenderScalarWhereWithAggregatesInput | SenderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sender"> | string
    displayName?: StringWithAggregatesFilter<"Sender"> | string
    name?: StringWithAggregatesFilter<"Sender"> | string
    email?: StringWithAggregatesFilter<"Sender"> | string
    apiKey?: StringWithAggregatesFilter<"Sender"> | string
    esp?: StringWithAggregatesFilter<"Sender"> | string
    priority?: IntWithAggregatesFilter<"Sender"> | number
    target?: IntWithAggregatesFilter<"Sender"> | number
    sentCount?: IntWithAggregatesFilter<"Sender"> | number
    isDeleted?: BoolWithAggregatesFilter<"Sender"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Sender"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sender"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    title?: StringFilter<"Tag"> | string
    isDeleted?: BoolFilter<"Tag"> | boolean
    tagCompanies?: CompanyTagListRelationFilter
    tagContacts?: ContactTagListRelationFilter
    DraftTag?: DraftTagListRelationFilter
    EmailTag?: EmailTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    isDeleted?: SortOrder
    tagCompanies?: CompanyTagOrderByRelationAggregateInput
    tagContacts?: ContactTagOrderByRelationAggregateInput
    DraftTag?: DraftTagOrderByRelationAggregateInput
    EmailTag?: EmailTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    title?: StringFilter<"Tag"> | string
    isDeleted?: BoolFilter<"Tag"> | boolean
    tagCompanies?: CompanyTagListRelationFilter
    tagContacts?: ContactTagListRelationFilter
    DraftTag?: DraftTagListRelationFilter
    EmailTag?: EmailTagListRelationFilter
  }, "id">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    isDeleted?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    title?: StringWithAggregatesFilter<"Tag"> | string
    isDeleted?: BoolWithAggregatesFilter<"Tag"> | boolean
  }

  export type CompanyTagWhereInput = {
    AND?: CompanyTagWhereInput | CompanyTagWhereInput[]
    OR?: CompanyTagWhereInput[]
    NOT?: CompanyTagWhereInput | CompanyTagWhereInput[]
    companyId?: StringFilter<"CompanyTag"> | string
    tagId?: StringFilter<"CompanyTag"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type CompanyTagOrderByWithRelationInput = {
    companyId?: SortOrder
    tagId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type CompanyTagWhereUniqueInput = Prisma.AtLeast<{
    companyId_tagId?: CompanyTagCompanyIdTagIdCompoundUniqueInput
    AND?: CompanyTagWhereInput | CompanyTagWhereInput[]
    OR?: CompanyTagWhereInput[]
    NOT?: CompanyTagWhereInput | CompanyTagWhereInput[]
    companyId?: StringFilter<"CompanyTag"> | string
    tagId?: StringFilter<"CompanyTag"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "companyId_tagId">

  export type CompanyTagOrderByWithAggregationInput = {
    companyId?: SortOrder
    tagId?: SortOrder
    _count?: CompanyTagCountOrderByAggregateInput
    _max?: CompanyTagMaxOrderByAggregateInput
    _min?: CompanyTagMinOrderByAggregateInput
  }

  export type CompanyTagScalarWhereWithAggregatesInput = {
    AND?: CompanyTagScalarWhereWithAggregatesInput | CompanyTagScalarWhereWithAggregatesInput[]
    OR?: CompanyTagScalarWhereWithAggregatesInput[]
    NOT?: CompanyTagScalarWhereWithAggregatesInput | CompanyTagScalarWhereWithAggregatesInput[]
    companyId?: StringWithAggregatesFilter<"CompanyTag"> | string
    tagId?: StringWithAggregatesFilter<"CompanyTag"> | string
  }

  export type ContactTagWhereInput = {
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ContactTagOrderByWithRelationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ContactTagWhereUniqueInput = Prisma.AtLeast<{
    contactId_tagId?: ContactTagContactIdTagIdCompoundUniqueInput
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "contactId_tagId">

  export type ContactTagOrderByWithAggregationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    _count?: ContactTagCountOrderByAggregateInput
    _max?: ContactTagMaxOrderByAggregateInput
    _min?: ContactTagMinOrderByAggregateInput
  }

  export type ContactTagScalarWhereWithAggregatesInput = {
    AND?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    OR?: ContactTagScalarWhereWithAggregatesInput[]
    NOT?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"ContactTag"> | string
    tagId?: StringWithAggregatesFilter<"ContactTag"> | string
  }

  export type DraftTagWhereInput = {
    AND?: DraftTagWhereInput | DraftTagWhereInput[]
    OR?: DraftTagWhereInput[]
    NOT?: DraftTagWhereInput | DraftTagWhereInput[]
    draftId?: StringFilter<"DraftTag"> | string
    tagId?: StringFilter<"DraftTag"> | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type DraftTagOrderByWithRelationInput = {
    draftId?: SortOrder
    tagId?: SortOrder
    draft?: DraftOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type DraftTagWhereUniqueInput = Prisma.AtLeast<{
    draftId_tagId?: DraftTagDraftIdTagIdCompoundUniqueInput
    AND?: DraftTagWhereInput | DraftTagWhereInput[]
    OR?: DraftTagWhereInput[]
    NOT?: DraftTagWhereInput | DraftTagWhereInput[]
    draftId?: StringFilter<"DraftTag"> | string
    tagId?: StringFilter<"DraftTag"> | string
    draft?: XOR<DraftScalarRelationFilter, DraftWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "draftId_tagId">

  export type DraftTagOrderByWithAggregationInput = {
    draftId?: SortOrder
    tagId?: SortOrder
    _count?: DraftTagCountOrderByAggregateInput
    _max?: DraftTagMaxOrderByAggregateInput
    _min?: DraftTagMinOrderByAggregateInput
  }

  export type DraftTagScalarWhereWithAggregatesInput = {
    AND?: DraftTagScalarWhereWithAggregatesInput | DraftTagScalarWhereWithAggregatesInput[]
    OR?: DraftTagScalarWhereWithAggregatesInput[]
    NOT?: DraftTagScalarWhereWithAggregatesInput | DraftTagScalarWhereWithAggregatesInput[]
    draftId?: StringWithAggregatesFilter<"DraftTag"> | string
    tagId?: StringWithAggregatesFilter<"DraftTag"> | string
  }

  export type EmailTagWhereInput = {
    AND?: EmailTagWhereInput | EmailTagWhereInput[]
    OR?: EmailTagWhereInput[]
    NOT?: EmailTagWhereInput | EmailTagWhereInput[]
    emailId?: StringFilter<"EmailTag"> | string
    tagId?: StringFilter<"EmailTag"> | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type EmailTagOrderByWithRelationInput = {
    emailId?: SortOrder
    tagId?: SortOrder
    email?: EmailOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type EmailTagWhereUniqueInput = Prisma.AtLeast<{
    emailId_tagId?: EmailTagEmailIdTagIdCompoundUniqueInput
    AND?: EmailTagWhereInput | EmailTagWhereInput[]
    OR?: EmailTagWhereInput[]
    NOT?: EmailTagWhereInput | EmailTagWhereInput[]
    emailId?: StringFilter<"EmailTag"> | string
    tagId?: StringFilter<"EmailTag"> | string
    email?: XOR<EmailScalarRelationFilter, EmailWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "emailId_tagId">

  export type EmailTagOrderByWithAggregationInput = {
    emailId?: SortOrder
    tagId?: SortOrder
    _count?: EmailTagCountOrderByAggregateInput
    _max?: EmailTagMaxOrderByAggregateInput
    _min?: EmailTagMinOrderByAggregateInput
  }

  export type EmailTagScalarWhereWithAggregatesInput = {
    AND?: EmailTagScalarWhereWithAggregatesInput | EmailTagScalarWhereWithAggregatesInput[]
    OR?: EmailTagScalarWhereWithAggregatesInput[]
    NOT?: EmailTagScalarWhereWithAggregatesInput | EmailTagScalarWhereWithAggregatesInput[]
    emailId?: StringWithAggregatesFilter<"EmailTag"> | string
    tagId?: StringWithAggregatesFilter<"EmailTag"> | string
  }

  export type CompanyCreateInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyTags?: CompanyTagCreateNestedManyWithoutCompanyInput
    contacts?: ContactCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyTags?: CompanyTagUncheckedCreateNestedManyWithoutCompanyInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyTags?: CompanyTagUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyTags?: CompanyTagUncheckedUpdateManyWithoutCompanyNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagCreateNestedManyWithoutContactInput
    events?: ContactEventCreateNestedManyWithoutContactInput
    company?: CompanyCreateNestedOneWithoutContactsInput
    contactDrafts?: DraftContactCreateNestedManyWithoutContactInput
    emails?: EmailCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
    events?: ContactEventUncheckedCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactUncheckedCreateNestedManyWithoutContactInput
    emails?: EmailUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUpdateManyWithoutContactNestedInput
    events?: ContactEventUpdateManyWithoutContactNestedInput
    company?: CompanyUpdateOneWithoutContactsNestedInput
    contactDrafts?: DraftContactUpdateManyWithoutContactNestedInput
    emails?: EmailUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
    events?: ContactEventUncheckedUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUncheckedUpdateManyWithoutContactNestedInput
    emails?: EmailUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEventCreateInput = {
    id?: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
    contact: ContactCreateNestedOneWithoutEventsInput
  }

  export type ContactEventUncheckedCreateInput = {
    id?: string
    contactId: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
  }

  export type ContactEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEventsNestedInput
  }

  export type ContactEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEventCreateManyInput = {
    id?: string
    contactId: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
  }

  export type ContactEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailCreateInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    sender: SenderCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailCreateManyInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventCreateInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
    email: EmailCreateNestedOneWithoutEventsInput
  }

  export type EmailEventUncheckedCreateInput = {
    id?: string
    emailId: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type EmailEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EmailEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventCreateManyInput = {
    id?: string
    emailId: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type EmailEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpCreateInput = {
    id?: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email: EmailCreateNestedOneWithoutFollowUpsInput
    events?: FollowUpEventCreateNestedManyWithoutFollowUpInput
  }

  export type FollowUpUncheckedCreateInput = {
    id?: string
    subject: string
    body: string
    emailId: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: FollowUpEventUncheckedCreateNestedManyWithoutFollowUpInput
  }

  export type FollowUpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutFollowUpsNestedInput
    events?: FollowUpEventUpdateManyWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: FollowUpEventUncheckedUpdateManyWithoutFollowUpNestedInput
  }

  export type FollowUpCreateManyInput = {
    id?: string
    subject: string
    body: string
    emailId: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventCreateInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
    FollowUp: FollowUpCreateNestedOneWithoutEventsInput
  }

  export type FollowUpEventUncheckedCreateInput = {
    id?: string
    followUpId: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    FollowUp?: FollowUpUpdateOneRequiredWithoutEventsNestedInput
  }

  export type FollowUpEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followUpId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventCreateManyInput = {
    id?: string
    followUpId: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followUpId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftCreateInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender?: SenderCreateNestedOneWithoutDraftsInput
    draftContacts?: DraftContactCreateNestedManyWithoutDraftInput
    draftTags?: DraftTagCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    senderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftContacts?: DraftContactUncheckedCreateNestedManyWithoutDraftInput
    draftTags?: DraftTagUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: SenderUpdateOneWithoutDraftsNestedInput
    draftContacts?: DraftContactUpdateManyWithoutDraftNestedInput
    draftTags?: DraftTagUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContacts?: DraftContactUncheckedUpdateManyWithoutDraftNestedInput
    draftTags?: DraftTagUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type DraftCreateManyInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    senderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftContactCreateInput = {
    draft: DraftCreateNestedOneWithoutDraftContactsInput
    contact: ContactCreateNestedOneWithoutContactDraftsInput
  }

  export type DraftContactUncheckedCreateInput = {
    draftId: string
    contactId: string
  }

  export type DraftContactUpdateInput = {
    draft?: DraftUpdateOneRequiredWithoutDraftContactsNestedInput
    contact?: ContactUpdateOneRequiredWithoutContactDraftsNestedInput
  }

  export type DraftContactUncheckedUpdateInput = {
    draftId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftContactCreateManyInput = {
    draftId: string
    contactId: string
  }

  export type DraftContactUpdateManyMutationInput = {

  }

  export type DraftContactUncheckedUpdateManyInput = {
    draftId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type LLMLogCreateInput = {
    id?: string
    prompt: string
    response?: string | null
    isError?: boolean
    createdAt?: Date | string
  }

  export type LLMLogUncheckedCreateInput = {
    id?: string
    prompt: string
    response?: string | null
    isError?: boolean
    createdAt?: Date | string
  }

  export type LLMLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isError?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LLMLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isError?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LLMLogCreateManyInput = {
    id?: string
    prompt: string
    response?: string | null
    isError?: boolean
    createdAt?: Date | string
  }

  export type LLMLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isError?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LLMLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isError?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateInput = {
    id?: string
    platform: string
    body?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUncheckedCreateInput = {
    id?: string
    platform: string
    body?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogCreateManyInput = {
    id?: string
    platform: string
    body?: string | null
    createdAt?: Date | string
  }

  export type WebhookLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    email: EmailCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    emailId: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    emailId: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderCreateInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    drafts?: DraftCreateNestedManyWithoutSenderInput
    emails?: EmailCreateNestedManyWithoutSenderInput
  }

  export type SenderUncheckedCreateInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    drafts?: DraftUncheckedCreateNestedManyWithoutSenderInput
    emails?: EmailUncheckedCreateNestedManyWithoutSenderInput
  }

  export type SenderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drafts?: DraftUpdateManyWithoutSenderNestedInput
    emails?: EmailUpdateManyWithoutSenderNestedInput
  }

  export type SenderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drafts?: DraftUncheckedUpdateManyWithoutSenderNestedInput
    emails?: EmailUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type SenderCreateManyInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SenderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagUncheckedCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagUncheckedCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUncheckedUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUncheckedUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    title: string
    isDeleted?: boolean
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CompanyTagCreateInput = {
    company: CompanyCreateNestedOneWithoutCompanyTagsInput
    tag: TagCreateNestedOneWithoutTagCompaniesInput
  }

  export type CompanyTagUncheckedCreateInput = {
    companyId: string
    tagId: string
  }

  export type CompanyTagUpdateInput = {
    company?: CompanyUpdateOneRequiredWithoutCompanyTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTagCompaniesNestedInput
  }

  export type CompanyTagUncheckedUpdateInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyTagCreateManyInput = {
    companyId: string
    tagId: string
  }

  export type CompanyTagUpdateManyMutationInput = {

  }

  export type CompanyTagUncheckedUpdateManyInput = {
    companyId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateInput = {
    contact: ContactCreateNestedOneWithoutContactTagsInput
    tag: TagCreateNestedOneWithoutTagContactsInput
  }

  export type ContactTagUncheckedCreateInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateInput = {
    contact?: ContactUpdateOneRequiredWithoutContactTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutTagContactsNestedInput
  }

  export type ContactTagUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateManyInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateManyMutationInput = {

  }

  export type ContactTagUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagCreateInput = {
    draft: DraftCreateNestedOneWithoutDraftTagsInput
    tag: TagCreateNestedOneWithoutDraftTagInput
  }

  export type DraftTagUncheckedCreateInput = {
    draftId: string
    tagId: string
  }

  export type DraftTagUpdateInput = {
    draft?: DraftUpdateOneRequiredWithoutDraftTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutDraftTagNestedInput
  }

  export type DraftTagUncheckedUpdateInput = {
    draftId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagCreateManyInput = {
    draftId: string
    tagId: string
  }

  export type DraftTagUpdateManyMutationInput = {

  }

  export type DraftTagUncheckedUpdateManyInput = {
    draftId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTagCreateInput = {
    email: EmailCreateNestedOneWithoutEmailTagsInput
    tag: TagCreateNestedOneWithoutEmailTagInput
  }

  export type EmailTagUncheckedCreateInput = {
    emailId: string
    tagId: string
  }

  export type EmailTagUpdateInput = {
    email?: EmailUpdateOneRequiredWithoutEmailTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutEmailTagNestedInput
  }

  export type EmailTagUncheckedUpdateInput = {
    emailId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTagCreateManyInput = {
    emailId: string
    tagId: string
  }

  export type EmailTagUpdateManyMutationInput = {

  }

  export type EmailTagUncheckedUpdateManyInput = {
    emailId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CompanyTagListRelationFilter = {
    every?: CompanyTagWhereInput
    some?: CompanyTagWhereInput
    none?: CompanyTagWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanyTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ContactTagListRelationFilter = {
    every?: ContactTagWhereInput
    some?: ContactTagWhereInput
    none?: ContactTagWhereInput
  }

  export type ContactEventListRelationFilter = {
    every?: ContactEventWhereInput
    some?: ContactEventWhereInput
    none?: ContactEventWhereInput
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type DraftContactListRelationFilter = {
    every?: DraftContactWhereInput
    some?: DraftContactWhereInput
    none?: DraftContactWhereInput
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type ContactTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DraftContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedInUrl?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedInUrl?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    linkedInUrl?: SortOrder
    location?: SortOrder
    companyId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactEventType | EnumContactEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactEventTypeFilter<$PrismaModel> | $Enums.ContactEventType
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactEventCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactEventMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactEventMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumContactEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactEventType | EnumContactEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactEventTypeFilter<$PrismaModel>
    _max?: NestedEnumContactEventTypeFilter<$PrismaModel>
  }

  export type SenderScalarRelationFilter = {
    is?: SenderWhereInput
    isNot?: SenderWhereInput
  }

  export type EmailTagListRelationFilter = {
    every?: EmailTagWhereInput
    some?: EmailTagWhereInput
    none?: EmailTagWhereInput
  }

  export type EmailEventListRelationFilter = {
    every?: EmailEventWhereInput
    some?: EmailEventWhereInput
    none?: EmailEventWhereInput
  }

  export type FollowUpListRelationFilter = {
    every?: FollowUpWhereInput
    some?: FollowUpWhereInput
    none?: FollowUpWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type EmailTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowUpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    messageId?: SortOrder
    contactId?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    messageId?: SortOrder
    contactId?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    messageId?: SortOrder
    contactId?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmailEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailEventType | EnumEmailEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailEventTypeFilter<$PrismaModel> | $Enums.EmailEventType
  }

  export type EmailScalarRelationFilter = {
    is?: EmailWhereInput
    isNot?: EmailWhereInput
  }

  export type EmailEventCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailEventMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EmailEventMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEmailEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailEventType | EnumEmailEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailEventTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FollowUpEventListRelationFilter = {
    every?: FollowUpEventWhereInput
    some?: FollowUpEventWhereInput
    none?: FollowUpEventWhereInput
  }

  export type FollowUpEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowUpCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    emailId?: SortOrder
    scheduledAt?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowUpMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    emailId?: SortOrder
    scheduledAt?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FollowUpMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    emailId?: SortOrder
    scheduledAt?: SortOrder
    isBounced?: SortOrder
    isSpamReported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FollowUpScalarRelationFilter = {
    is?: FollowUpWhereInput
    isNot?: FollowUpWhereInput
  }

  export type FollowUpEventCountOrderByAggregateInput = {
    id?: SortOrder
    followUpId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowUpEventMaxOrderByAggregateInput = {
    id?: SortOrder
    followUpId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowUpEventMinOrderByAggregateInput = {
    id?: SortOrder
    followUpId?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type SenderNullableScalarRelationFilter = {
    is?: SenderWhereInput | null
    isNot?: SenderWhereInput | null
  }

  export type DraftTagListRelationFilter = {
    every?: DraftTagWhereInput
    some?: DraftTagWhereInput
    none?: DraftTagWhereInput
  }

  export type DraftTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DraftCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    scheduledAt?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DraftScalarRelationFilter = {
    is?: DraftWhereInput
    isNot?: DraftWhereInput
  }

  export type DraftContactDraftIdContactIdCompoundUniqueInput = {
    draftId: string
    contactId: string
  }

  export type DraftContactCountOrderByAggregateInput = {
    draftId?: SortOrder
    contactId?: SortOrder
  }

  export type DraftContactMaxOrderByAggregateInput = {
    draftId?: SortOrder
    contactId?: SortOrder
  }

  export type DraftContactMinOrderByAggregateInput = {
    draftId?: SortOrder
    contactId?: SortOrder
  }

  export type LLMLogCountOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    isError?: SortOrder
    createdAt?: SortOrder
  }

  export type LLMLogMaxOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    isError?: SortOrder
    createdAt?: SortOrder
  }

  export type LLMLogMinOrderByAggregateInput = {
    id?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    isError?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    platform?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    emailId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DraftListRelationFilter = {
    every?: DraftWhereInput
    some?: DraftWhereInput
    none?: DraftWhereInput
  }

  export type DraftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SenderEmailEspCompoundUniqueInput = {
    email: string
    esp: string
  }

  export type SenderCountOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    apiKey?: SortOrder
    esp?: SortOrder
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderAvgOrderByAggregateInput = {
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
  }

  export type SenderMaxOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    apiKey?: SortOrder
    esp?: SortOrder
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderMinOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    email?: SortOrder
    apiKey?: SortOrder
    esp?: SortOrder
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SenderSumOrderByAggregateInput = {
    priority?: SortOrder
    target?: SortOrder
    sentCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isDeleted?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isDeleted?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    isDeleted?: SortOrder
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type CompanyTagCompanyIdTagIdCompoundUniqueInput = {
    companyId: string
    tagId: string
  }

  export type CompanyTagCountOrderByAggregateInput = {
    companyId?: SortOrder
    tagId?: SortOrder
  }

  export type CompanyTagMaxOrderByAggregateInput = {
    companyId?: SortOrder
    tagId?: SortOrder
  }

  export type CompanyTagMinOrderByAggregateInput = {
    companyId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagContactIdTagIdCompoundUniqueInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagCountOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMaxOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMinOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type DraftTagDraftIdTagIdCompoundUniqueInput = {
    draftId: string
    tagId: string
  }

  export type DraftTagCountOrderByAggregateInput = {
    draftId?: SortOrder
    tagId?: SortOrder
  }

  export type DraftTagMaxOrderByAggregateInput = {
    draftId?: SortOrder
    tagId?: SortOrder
  }

  export type DraftTagMinOrderByAggregateInput = {
    draftId?: SortOrder
    tagId?: SortOrder
  }

  export type EmailTagEmailIdTagIdCompoundUniqueInput = {
    emailId: string
    tagId: string
  }

  export type EmailTagCountOrderByAggregateInput = {
    emailId?: SortOrder
    tagId?: SortOrder
  }

  export type EmailTagMaxOrderByAggregateInput = {
    emailId?: SortOrder
    tagId?: SortOrder
  }

  export type EmailTagMinOrderByAggregateInput = {
    emailId?: SortOrder
    tagId?: SortOrder
  }

  export type CompanyTagCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput> | CompanyTagCreateWithoutCompanyInput[] | CompanyTagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutCompanyInput | CompanyTagCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyTagCreateManyCompanyInputEnvelope
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type CompanyTagUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput> | CompanyTagCreateWithoutCompanyInput[] | CompanyTagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutCompanyInput | CompanyTagCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyTagCreateManyCompanyInputEnvelope
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CompanyTagUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput> | CompanyTagCreateWithoutCompanyInput[] | CompanyTagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutCompanyInput | CompanyTagCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyTagUpsertWithWhereUniqueWithoutCompanyInput | CompanyTagUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyTagCreateManyCompanyInputEnvelope
    set?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    disconnect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    delete?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    update?: CompanyTagUpdateWithWhereUniqueWithoutCompanyInput | CompanyTagUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyTagUpdateManyWithWhereWithoutCompanyInput | CompanyTagUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type CompanyTagUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput> | CompanyTagCreateWithoutCompanyInput[] | CompanyTagUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutCompanyInput | CompanyTagCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyTagUpsertWithWhereUniqueWithoutCompanyInput | CompanyTagUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyTagCreateManyCompanyInputEnvelope
    set?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    disconnect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    delete?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    update?: CompanyTagUpdateWithWhereUniqueWithoutCompanyInput | CompanyTagUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyTagUpdateManyWithWhereWithoutCompanyInput | CompanyTagUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput> | ContactCreateWithoutCompanyInput[] | ContactUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCompanyInput | ContactCreateOrConnectWithoutCompanyInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCompanyInput | ContactUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ContactCreateManyCompanyInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCompanyInput | ContactUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCompanyInput | ContactUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ContactTagCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type ContactEventCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput> | ContactEventCreateWithoutContactInput[] | ContactEventUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEventCreateOrConnectWithoutContactInput | ContactEventCreateOrConnectWithoutContactInput[]
    createMany?: ContactEventCreateManyContactInputEnvelope
    connect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutContactsInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DraftContactCreateNestedManyWithoutContactInput = {
    create?: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput> | DraftContactCreateWithoutContactInput[] | DraftContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutContactInput | DraftContactCreateOrConnectWithoutContactInput[]
    createMany?: DraftContactCreateManyContactInputEnvelope
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
  }

  export type EmailCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput> | EmailCreateWithoutContactInput[] | EmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactInput | EmailCreateOrConnectWithoutContactInput[]
    createMany?: EmailCreateManyContactInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type ContactEventUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput> | ContactEventCreateWithoutContactInput[] | ContactEventUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEventCreateOrConnectWithoutContactInput | ContactEventCreateOrConnectWithoutContactInput[]
    createMany?: ContactEventCreateManyContactInputEnvelope
    connect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
  }

  export type DraftContactUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput> | DraftContactCreateWithoutContactInput[] | DraftContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutContactInput | DraftContactCreateOrConnectWithoutContactInput[]
    createMany?: DraftContactCreateManyContactInputEnvelope
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput> | EmailCreateWithoutContactInput[] | EmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactInput | EmailCreateOrConnectWithoutContactInput[]
    createMany?: EmailCreateManyContactInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type ContactTagUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ContactEventUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput> | ContactEventCreateWithoutContactInput[] | ContactEventUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEventCreateOrConnectWithoutContactInput | ContactEventCreateOrConnectWithoutContactInput[]
    upsert?: ContactEventUpsertWithWhereUniqueWithoutContactInput | ContactEventUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactEventCreateManyContactInputEnvelope
    set?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    disconnect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    delete?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    connect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    update?: ContactEventUpdateWithWhereUniqueWithoutContactInput | ContactEventUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactEventUpdateManyWithWhereWithoutContactInput | ContactEventUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactEventScalarWhereInput | ContactEventScalarWhereInput[]
  }

  export type CompanyUpdateOneWithoutContactsNestedInput = {
    create?: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutContactsInput
    upsert?: CompanyUpsertWithoutContactsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutContactsInput, CompanyUpdateWithoutContactsInput>, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type DraftContactUpdateManyWithoutContactNestedInput = {
    create?: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput> | DraftContactCreateWithoutContactInput[] | DraftContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutContactInput | DraftContactCreateOrConnectWithoutContactInput[]
    upsert?: DraftContactUpsertWithWhereUniqueWithoutContactInput | DraftContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DraftContactCreateManyContactInputEnvelope
    set?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    disconnect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    delete?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    update?: DraftContactUpdateWithWhereUniqueWithoutContactInput | DraftContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DraftContactUpdateManyWithWhereWithoutContactInput | DraftContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
  }

  export type EmailUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput> | EmailCreateWithoutContactInput[] | EmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactInput | EmailCreateOrConnectWithoutContactInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutContactInput | EmailUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailCreateManyContactInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutContactInput | EmailUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutContactInput | EmailUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ContactEventUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput> | ContactEventCreateWithoutContactInput[] | ContactEventUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactEventCreateOrConnectWithoutContactInput | ContactEventCreateOrConnectWithoutContactInput[]
    upsert?: ContactEventUpsertWithWhereUniqueWithoutContactInput | ContactEventUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactEventCreateManyContactInputEnvelope
    set?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    disconnect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    delete?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    connect?: ContactEventWhereUniqueInput | ContactEventWhereUniqueInput[]
    update?: ContactEventUpdateWithWhereUniqueWithoutContactInput | ContactEventUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactEventUpdateManyWithWhereWithoutContactInput | ContactEventUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactEventScalarWhereInput | ContactEventScalarWhereInput[]
  }

  export type DraftContactUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput> | DraftContactCreateWithoutContactInput[] | DraftContactUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutContactInput | DraftContactCreateOrConnectWithoutContactInput[]
    upsert?: DraftContactUpsertWithWhereUniqueWithoutContactInput | DraftContactUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DraftContactCreateManyContactInputEnvelope
    set?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    disconnect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    delete?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    update?: DraftContactUpdateWithWhereUniqueWithoutContactInput | DraftContactUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DraftContactUpdateManyWithWhereWithoutContactInput | DraftContactUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput> | EmailCreateWithoutContactInput[] | EmailUncheckedCreateWithoutContactInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactInput | EmailCreateOrConnectWithoutContactInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutContactInput | EmailUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: EmailCreateManyContactInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutContactInput | EmailUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutContactInput | EmailUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutEventsInput = {
    create?: XOR<ContactCreateWithoutEventsInput, ContactUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEventsInput
    connect?: ContactWhereUniqueInput
  }

  export type EnumContactEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactEventType
  }

  export type ContactUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<ContactCreateWithoutEventsInput, ContactUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEventsInput
    upsert?: ContactUpsertWithoutEventsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEventsInput, ContactUpdateWithoutEventsInput>, ContactUncheckedUpdateWithoutEventsInput>
  }

  export type ContactCreateNestedOneWithoutEmailsInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput
    connect?: ContactWhereUniqueInput
  }

  export type SenderCreateNestedOneWithoutEmailsInput = {
    create?: XOR<SenderCreateWithoutEmailsInput, SenderUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: SenderCreateOrConnectWithoutEmailsInput
    connect?: SenderWhereUniqueInput
  }

  export type EmailTagCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput> | EmailTagCreateWithoutEmailInput[] | EmailTagUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutEmailInput | EmailTagCreateOrConnectWithoutEmailInput[]
    createMany?: EmailTagCreateManyEmailInputEnvelope
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
  }

  export type EmailEventCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput> | EmailEventCreateWithoutEmailInput[] | EmailEventUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutEmailInput | EmailEventCreateOrConnectWithoutEmailInput[]
    createMany?: EmailEventCreateManyEmailInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type FollowUpCreateNestedManyWithoutEmailInput = {
    create?: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput> | FollowUpCreateWithoutEmailInput[] | FollowUpUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEmailInput | FollowUpCreateOrConnectWithoutEmailInput[]
    createMany?: FollowUpCreateManyEmailInputEnvelope
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutEmailInput = {
    create?: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput> | NotificationCreateWithoutEmailInput[] | NotificationUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmailInput | NotificationCreateOrConnectWithoutEmailInput[]
    createMany?: NotificationCreateManyEmailInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EmailTagUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput> | EmailTagCreateWithoutEmailInput[] | EmailTagUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutEmailInput | EmailTagCreateOrConnectWithoutEmailInput[]
    createMany?: EmailTagCreateManyEmailInputEnvelope
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
  }

  export type EmailEventUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput> | EmailEventCreateWithoutEmailInput[] | EmailEventUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutEmailInput | EmailEventCreateOrConnectWithoutEmailInput[]
    createMany?: EmailEventCreateManyEmailInputEnvelope
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
  }

  export type FollowUpUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput> | FollowUpCreateWithoutEmailInput[] | FollowUpUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEmailInput | FollowUpCreateOrConnectWithoutEmailInput[]
    createMany?: FollowUpCreateManyEmailInputEnvelope
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutEmailInput = {
    create?: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput> | NotificationCreateWithoutEmailInput[] | NotificationUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmailInput | NotificationCreateOrConnectWithoutEmailInput[]
    createMany?: NotificationCreateManyEmailInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ContactUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput
    upsert?: ContactUpsertWithoutEmailsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutEmailsInput, ContactUpdateWithoutEmailsInput>, ContactUncheckedUpdateWithoutEmailsInput>
  }

  export type SenderUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<SenderCreateWithoutEmailsInput, SenderUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: SenderCreateOrConnectWithoutEmailsInput
    upsert?: SenderUpsertWithoutEmailsInput
    connect?: SenderWhereUniqueInput
    update?: XOR<XOR<SenderUpdateToOneWithWhereWithoutEmailsInput, SenderUpdateWithoutEmailsInput>, SenderUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailTagUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput> | EmailTagCreateWithoutEmailInput[] | EmailTagUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutEmailInput | EmailTagCreateOrConnectWithoutEmailInput[]
    upsert?: EmailTagUpsertWithWhereUniqueWithoutEmailInput | EmailTagUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailTagCreateManyEmailInputEnvelope
    set?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    disconnect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    delete?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    update?: EmailTagUpdateWithWhereUniqueWithoutEmailInput | EmailTagUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailTagUpdateManyWithWhereWithoutEmailInput | EmailTagUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
  }

  export type EmailEventUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput> | EmailEventCreateWithoutEmailInput[] | EmailEventUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutEmailInput | EmailEventCreateOrConnectWithoutEmailInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutEmailInput | EmailEventUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailEventCreateManyEmailInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutEmailInput | EmailEventUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutEmailInput | EmailEventUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type FollowUpUpdateManyWithoutEmailNestedInput = {
    create?: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput> | FollowUpCreateWithoutEmailInput[] | FollowUpUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEmailInput | FollowUpCreateOrConnectWithoutEmailInput[]
    upsert?: FollowUpUpsertWithWhereUniqueWithoutEmailInput | FollowUpUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: FollowUpCreateManyEmailInputEnvelope
    set?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    disconnect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    delete?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    update?: FollowUpUpdateWithWhereUniqueWithoutEmailInput | FollowUpUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: FollowUpUpdateManyWithWhereWithoutEmailInput | FollowUpUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutEmailNestedInput = {
    create?: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput> | NotificationCreateWithoutEmailInput[] | NotificationUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmailInput | NotificationCreateOrConnectWithoutEmailInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEmailInput | NotificationUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: NotificationCreateManyEmailInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEmailInput | NotificationUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEmailInput | NotificationUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmailTagUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput> | EmailTagCreateWithoutEmailInput[] | EmailTagUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutEmailInput | EmailTagCreateOrConnectWithoutEmailInput[]
    upsert?: EmailTagUpsertWithWhereUniqueWithoutEmailInput | EmailTagUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailTagCreateManyEmailInputEnvelope
    set?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    disconnect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    delete?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    update?: EmailTagUpdateWithWhereUniqueWithoutEmailInput | EmailTagUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailTagUpdateManyWithWhereWithoutEmailInput | EmailTagUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
  }

  export type EmailEventUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput> | EmailEventCreateWithoutEmailInput[] | EmailEventUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: EmailEventCreateOrConnectWithoutEmailInput | EmailEventCreateOrConnectWithoutEmailInput[]
    upsert?: EmailEventUpsertWithWhereUniqueWithoutEmailInput | EmailEventUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: EmailEventCreateManyEmailInputEnvelope
    set?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    disconnect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    delete?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    connect?: EmailEventWhereUniqueInput | EmailEventWhereUniqueInput[]
    update?: EmailEventUpdateWithWhereUniqueWithoutEmailInput | EmailEventUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: EmailEventUpdateManyWithWhereWithoutEmailInput | EmailEventUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
  }

  export type FollowUpUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput> | FollowUpCreateWithoutEmailInput[] | FollowUpUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEmailInput | FollowUpCreateOrConnectWithoutEmailInput[]
    upsert?: FollowUpUpsertWithWhereUniqueWithoutEmailInput | FollowUpUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: FollowUpCreateManyEmailInputEnvelope
    set?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    disconnect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    delete?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    update?: FollowUpUpdateWithWhereUniqueWithoutEmailInput | FollowUpUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: FollowUpUpdateManyWithWhereWithoutEmailInput | FollowUpUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutEmailNestedInput = {
    create?: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput> | NotificationCreateWithoutEmailInput[] | NotificationUncheckedCreateWithoutEmailInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmailInput | NotificationCreateOrConnectWithoutEmailInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEmailInput | NotificationUpsertWithWhereUniqueWithoutEmailInput[]
    createMany?: NotificationCreateManyEmailInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEmailInput | NotificationUpdateWithWhereUniqueWithoutEmailInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEmailInput | NotificationUpdateManyWithWhereWithoutEmailInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type EmailCreateNestedOneWithoutEventsInput = {
    create?: XOR<EmailCreateWithoutEventsInput, EmailUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEventsInput
    connect?: EmailWhereUniqueInput
  }

  export type EnumEmailEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmailEventType
  }

  export type EmailUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<EmailCreateWithoutEventsInput, EmailUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEventsInput
    upsert?: EmailUpsertWithoutEventsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutEventsInput, EmailUpdateWithoutEventsInput>, EmailUncheckedUpdateWithoutEventsInput>
  }

  export type EmailCreateNestedOneWithoutFollowUpsInput = {
    create?: XOR<EmailCreateWithoutFollowUpsInput, EmailUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutFollowUpsInput
    connect?: EmailWhereUniqueInput
  }

  export type FollowUpEventCreateNestedManyWithoutFollowUpInput = {
    create?: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput> | FollowUpEventCreateWithoutFollowUpInput[] | FollowUpEventUncheckedCreateWithoutFollowUpInput[]
    connectOrCreate?: FollowUpEventCreateOrConnectWithoutFollowUpInput | FollowUpEventCreateOrConnectWithoutFollowUpInput[]
    createMany?: FollowUpEventCreateManyFollowUpInputEnvelope
    connect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
  }

  export type FollowUpEventUncheckedCreateNestedManyWithoutFollowUpInput = {
    create?: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput> | FollowUpEventCreateWithoutFollowUpInput[] | FollowUpEventUncheckedCreateWithoutFollowUpInput[]
    connectOrCreate?: FollowUpEventCreateOrConnectWithoutFollowUpInput | FollowUpEventCreateOrConnectWithoutFollowUpInput[]
    createMany?: FollowUpEventCreateManyFollowUpInputEnvelope
    connect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EmailUpdateOneRequiredWithoutFollowUpsNestedInput = {
    create?: XOR<EmailCreateWithoutFollowUpsInput, EmailUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutFollowUpsInput
    upsert?: EmailUpsertWithoutFollowUpsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutFollowUpsInput, EmailUpdateWithoutFollowUpsInput>, EmailUncheckedUpdateWithoutFollowUpsInput>
  }

  export type FollowUpEventUpdateManyWithoutFollowUpNestedInput = {
    create?: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput> | FollowUpEventCreateWithoutFollowUpInput[] | FollowUpEventUncheckedCreateWithoutFollowUpInput[]
    connectOrCreate?: FollowUpEventCreateOrConnectWithoutFollowUpInput | FollowUpEventCreateOrConnectWithoutFollowUpInput[]
    upsert?: FollowUpEventUpsertWithWhereUniqueWithoutFollowUpInput | FollowUpEventUpsertWithWhereUniqueWithoutFollowUpInput[]
    createMany?: FollowUpEventCreateManyFollowUpInputEnvelope
    set?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    disconnect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    delete?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    connect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    update?: FollowUpEventUpdateWithWhereUniqueWithoutFollowUpInput | FollowUpEventUpdateWithWhereUniqueWithoutFollowUpInput[]
    updateMany?: FollowUpEventUpdateManyWithWhereWithoutFollowUpInput | FollowUpEventUpdateManyWithWhereWithoutFollowUpInput[]
    deleteMany?: FollowUpEventScalarWhereInput | FollowUpEventScalarWhereInput[]
  }

  export type FollowUpEventUncheckedUpdateManyWithoutFollowUpNestedInput = {
    create?: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput> | FollowUpEventCreateWithoutFollowUpInput[] | FollowUpEventUncheckedCreateWithoutFollowUpInput[]
    connectOrCreate?: FollowUpEventCreateOrConnectWithoutFollowUpInput | FollowUpEventCreateOrConnectWithoutFollowUpInput[]
    upsert?: FollowUpEventUpsertWithWhereUniqueWithoutFollowUpInput | FollowUpEventUpsertWithWhereUniqueWithoutFollowUpInput[]
    createMany?: FollowUpEventCreateManyFollowUpInputEnvelope
    set?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    disconnect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    delete?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    connect?: FollowUpEventWhereUniqueInput | FollowUpEventWhereUniqueInput[]
    update?: FollowUpEventUpdateWithWhereUniqueWithoutFollowUpInput | FollowUpEventUpdateWithWhereUniqueWithoutFollowUpInput[]
    updateMany?: FollowUpEventUpdateManyWithWhereWithoutFollowUpInput | FollowUpEventUpdateManyWithWhereWithoutFollowUpInput[]
    deleteMany?: FollowUpEventScalarWhereInput | FollowUpEventScalarWhereInput[]
  }

  export type FollowUpCreateNestedOneWithoutEventsInput = {
    create?: XOR<FollowUpCreateWithoutEventsInput, FollowUpUncheckedCreateWithoutEventsInput>
    connectOrCreate?: FollowUpCreateOrConnectWithoutEventsInput
    connect?: FollowUpWhereUniqueInput
  }

  export type FollowUpUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<FollowUpCreateWithoutEventsInput, FollowUpUncheckedCreateWithoutEventsInput>
    connectOrCreate?: FollowUpCreateOrConnectWithoutEventsInput
    upsert?: FollowUpUpsertWithoutEventsInput
    connect?: FollowUpWhereUniqueInput
    update?: XOR<XOR<FollowUpUpdateToOneWithWhereWithoutEventsInput, FollowUpUpdateWithoutEventsInput>, FollowUpUncheckedUpdateWithoutEventsInput>
  }

  export type SenderCreateNestedOneWithoutDraftsInput = {
    create?: XOR<SenderCreateWithoutDraftsInput, SenderUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: SenderCreateOrConnectWithoutDraftsInput
    connect?: SenderWhereUniqueInput
  }

  export type DraftContactCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput> | DraftContactCreateWithoutDraftInput[] | DraftContactUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutDraftInput | DraftContactCreateOrConnectWithoutDraftInput[]
    createMany?: DraftContactCreateManyDraftInputEnvelope
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
  }

  export type DraftTagCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput> | DraftTagCreateWithoutDraftInput[] | DraftTagUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutDraftInput | DraftTagCreateOrConnectWithoutDraftInput[]
    createMany?: DraftTagCreateManyDraftInputEnvelope
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
  }

  export type DraftContactUncheckedCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput> | DraftContactCreateWithoutDraftInput[] | DraftContactUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutDraftInput | DraftContactCreateOrConnectWithoutDraftInput[]
    createMany?: DraftContactCreateManyDraftInputEnvelope
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
  }

  export type DraftTagUncheckedCreateNestedManyWithoutDraftInput = {
    create?: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput> | DraftTagCreateWithoutDraftInput[] | DraftTagUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutDraftInput | DraftTagCreateOrConnectWithoutDraftInput[]
    createMany?: DraftTagCreateManyDraftInputEnvelope
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
  }

  export type SenderUpdateOneWithoutDraftsNestedInput = {
    create?: XOR<SenderCreateWithoutDraftsInput, SenderUncheckedCreateWithoutDraftsInput>
    connectOrCreate?: SenderCreateOrConnectWithoutDraftsInput
    upsert?: SenderUpsertWithoutDraftsInput
    disconnect?: SenderWhereInput | boolean
    delete?: SenderWhereInput | boolean
    connect?: SenderWhereUniqueInput
    update?: XOR<XOR<SenderUpdateToOneWithWhereWithoutDraftsInput, SenderUpdateWithoutDraftsInput>, SenderUncheckedUpdateWithoutDraftsInput>
  }

  export type DraftContactUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput> | DraftContactCreateWithoutDraftInput[] | DraftContactUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutDraftInput | DraftContactCreateOrConnectWithoutDraftInput[]
    upsert?: DraftContactUpsertWithWhereUniqueWithoutDraftInput | DraftContactUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftContactCreateManyDraftInputEnvelope
    set?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    disconnect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    delete?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    update?: DraftContactUpdateWithWhereUniqueWithoutDraftInput | DraftContactUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftContactUpdateManyWithWhereWithoutDraftInput | DraftContactUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
  }

  export type DraftTagUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput> | DraftTagCreateWithoutDraftInput[] | DraftTagUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutDraftInput | DraftTagCreateOrConnectWithoutDraftInput[]
    upsert?: DraftTagUpsertWithWhereUniqueWithoutDraftInput | DraftTagUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftTagCreateManyDraftInputEnvelope
    set?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    disconnect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    delete?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    update?: DraftTagUpdateWithWhereUniqueWithoutDraftInput | DraftTagUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftTagUpdateManyWithWhereWithoutDraftInput | DraftTagUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
  }

  export type DraftContactUncheckedUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput> | DraftContactCreateWithoutDraftInput[] | DraftContactUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftContactCreateOrConnectWithoutDraftInput | DraftContactCreateOrConnectWithoutDraftInput[]
    upsert?: DraftContactUpsertWithWhereUniqueWithoutDraftInput | DraftContactUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftContactCreateManyDraftInputEnvelope
    set?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    disconnect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    delete?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    connect?: DraftContactWhereUniqueInput | DraftContactWhereUniqueInput[]
    update?: DraftContactUpdateWithWhereUniqueWithoutDraftInput | DraftContactUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftContactUpdateManyWithWhereWithoutDraftInput | DraftContactUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
  }

  export type DraftTagUncheckedUpdateManyWithoutDraftNestedInput = {
    create?: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput> | DraftTagCreateWithoutDraftInput[] | DraftTagUncheckedCreateWithoutDraftInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutDraftInput | DraftTagCreateOrConnectWithoutDraftInput[]
    upsert?: DraftTagUpsertWithWhereUniqueWithoutDraftInput | DraftTagUpsertWithWhereUniqueWithoutDraftInput[]
    createMany?: DraftTagCreateManyDraftInputEnvelope
    set?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    disconnect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    delete?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    update?: DraftTagUpdateWithWhereUniqueWithoutDraftInput | DraftTagUpdateWithWhereUniqueWithoutDraftInput[]
    updateMany?: DraftTagUpdateManyWithWhereWithoutDraftInput | DraftTagUpdateManyWithWhereWithoutDraftInput[]
    deleteMany?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
  }

  export type DraftCreateNestedOneWithoutDraftContactsInput = {
    create?: XOR<DraftCreateWithoutDraftContactsInput, DraftUncheckedCreateWithoutDraftContactsInput>
    connectOrCreate?: DraftCreateOrConnectWithoutDraftContactsInput
    connect?: DraftWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutContactDraftsInput = {
    create?: XOR<ContactCreateWithoutContactDraftsInput, ContactUncheckedCreateWithoutContactDraftsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactDraftsInput
    connect?: ContactWhereUniqueInput
  }

  export type DraftUpdateOneRequiredWithoutDraftContactsNestedInput = {
    create?: XOR<DraftCreateWithoutDraftContactsInput, DraftUncheckedCreateWithoutDraftContactsInput>
    connectOrCreate?: DraftCreateOrConnectWithoutDraftContactsInput
    upsert?: DraftUpsertWithoutDraftContactsInput
    connect?: DraftWhereUniqueInput
    update?: XOR<XOR<DraftUpdateToOneWithWhereWithoutDraftContactsInput, DraftUpdateWithoutDraftContactsInput>, DraftUncheckedUpdateWithoutDraftContactsInput>
  }

  export type ContactUpdateOneRequiredWithoutContactDraftsNestedInput = {
    create?: XOR<ContactCreateWithoutContactDraftsInput, ContactUncheckedCreateWithoutContactDraftsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactDraftsInput
    upsert?: ContactUpsertWithoutContactDraftsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactDraftsInput, ContactUpdateWithoutContactDraftsInput>, ContactUncheckedUpdateWithoutContactDraftsInput>
  }

  export type EmailCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<EmailCreateWithoutNotificationsInput, EmailUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutNotificationsInput
    connect?: EmailWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EmailUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<EmailCreateWithoutNotificationsInput, EmailUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutNotificationsInput
    upsert?: EmailUpsertWithoutNotificationsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutNotificationsInput, EmailUpdateWithoutNotificationsInput>, EmailUncheckedUpdateWithoutNotificationsInput>
  }

  export type DraftCreateNestedManyWithoutSenderInput = {
    create?: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput> | DraftCreateWithoutSenderInput[] | DraftUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutSenderInput | DraftCreateOrConnectWithoutSenderInput[]
    createMany?: DraftCreateManySenderInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type EmailCreateNestedManyWithoutSenderInput = {
    create?: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput> | EmailCreateWithoutSenderInput[] | EmailUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutSenderInput | EmailCreateOrConnectWithoutSenderInput[]
    createMany?: EmailCreateManySenderInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type DraftUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput> | DraftCreateWithoutSenderInput[] | DraftUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutSenderInput | DraftCreateOrConnectWithoutSenderInput[]
    createMany?: DraftCreateManySenderInputEnvelope
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput> | EmailCreateWithoutSenderInput[] | EmailUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutSenderInput | EmailCreateOrConnectWithoutSenderInput[]
    createMany?: EmailCreateManySenderInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DraftUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput> | DraftCreateWithoutSenderInput[] | DraftUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutSenderInput | DraftCreateOrConnectWithoutSenderInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutSenderInput | DraftUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DraftCreateManySenderInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutSenderInput | DraftUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutSenderInput | DraftUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type EmailUpdateManyWithoutSenderNestedInput = {
    create?: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput> | EmailCreateWithoutSenderInput[] | EmailUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutSenderInput | EmailCreateOrConnectWithoutSenderInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutSenderInput | EmailUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: EmailCreateManySenderInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutSenderInput | EmailUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutSenderInput | EmailUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type DraftUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput> | DraftCreateWithoutSenderInput[] | DraftUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: DraftCreateOrConnectWithoutSenderInput | DraftCreateOrConnectWithoutSenderInput[]
    upsert?: DraftUpsertWithWhereUniqueWithoutSenderInput | DraftUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: DraftCreateManySenderInputEnvelope
    set?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    disconnect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    delete?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    connect?: DraftWhereUniqueInput | DraftWhereUniqueInput[]
    update?: DraftUpdateWithWhereUniqueWithoutSenderInput | DraftUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: DraftUpdateManyWithWhereWithoutSenderInput | DraftUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: DraftScalarWhereInput | DraftScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput> | EmailCreateWithoutSenderInput[] | EmailUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutSenderInput | EmailCreateOrConnectWithoutSenderInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutSenderInput | EmailUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: EmailCreateManySenderInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutSenderInput | EmailUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutSenderInput | EmailUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type CompanyTagCreateNestedManyWithoutTagInput = {
    create?: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput> | CompanyTagCreateWithoutTagInput[] | CompanyTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutTagInput | CompanyTagCreateOrConnectWithoutTagInput[]
    createMany?: CompanyTagCreateManyTagInputEnvelope
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
  }

  export type ContactTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type DraftTagCreateNestedManyWithoutTagInput = {
    create?: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput> | DraftTagCreateWithoutTagInput[] | DraftTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutTagInput | DraftTagCreateOrConnectWithoutTagInput[]
    createMany?: DraftTagCreateManyTagInputEnvelope
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
  }

  export type EmailTagCreateNestedManyWithoutTagInput = {
    create?: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput> | EmailTagCreateWithoutTagInput[] | EmailTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutTagInput | EmailTagCreateOrConnectWithoutTagInput[]
    createMany?: EmailTagCreateManyTagInputEnvelope
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
  }

  export type CompanyTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput> | CompanyTagCreateWithoutTagInput[] | CompanyTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutTagInput | CompanyTagCreateOrConnectWithoutTagInput[]
    createMany?: CompanyTagCreateManyTagInputEnvelope
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type DraftTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput> | DraftTagCreateWithoutTagInput[] | DraftTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutTagInput | DraftTagCreateOrConnectWithoutTagInput[]
    createMany?: DraftTagCreateManyTagInputEnvelope
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
  }

  export type EmailTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput> | EmailTagCreateWithoutTagInput[] | EmailTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutTagInput | EmailTagCreateOrConnectWithoutTagInput[]
    createMany?: EmailTagCreateManyTagInputEnvelope
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
  }

  export type CompanyTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput> | CompanyTagCreateWithoutTagInput[] | CompanyTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutTagInput | CompanyTagCreateOrConnectWithoutTagInput[]
    upsert?: CompanyTagUpsertWithWhereUniqueWithoutTagInput | CompanyTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CompanyTagCreateManyTagInputEnvelope
    set?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    disconnect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    delete?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    update?: CompanyTagUpdateWithWhereUniqueWithoutTagInput | CompanyTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CompanyTagUpdateManyWithWhereWithoutTagInput | CompanyTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
  }

  export type ContactTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type DraftTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput> | DraftTagCreateWithoutTagInput[] | DraftTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutTagInput | DraftTagCreateOrConnectWithoutTagInput[]
    upsert?: DraftTagUpsertWithWhereUniqueWithoutTagInput | DraftTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DraftTagCreateManyTagInputEnvelope
    set?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    disconnect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    delete?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    update?: DraftTagUpdateWithWhereUniqueWithoutTagInput | DraftTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DraftTagUpdateManyWithWhereWithoutTagInput | DraftTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
  }

  export type EmailTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput> | EmailTagCreateWithoutTagInput[] | EmailTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutTagInput | EmailTagCreateOrConnectWithoutTagInput[]
    upsert?: EmailTagUpsertWithWhereUniqueWithoutTagInput | EmailTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: EmailTagCreateManyTagInputEnvelope
    set?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    disconnect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    delete?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    update?: EmailTagUpdateWithWhereUniqueWithoutTagInput | EmailTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: EmailTagUpdateManyWithWhereWithoutTagInput | EmailTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
  }

  export type CompanyTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput> | CompanyTagCreateWithoutTagInput[] | CompanyTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: CompanyTagCreateOrConnectWithoutTagInput | CompanyTagCreateOrConnectWithoutTagInput[]
    upsert?: CompanyTagUpsertWithWhereUniqueWithoutTagInput | CompanyTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: CompanyTagCreateManyTagInputEnvelope
    set?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    disconnect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    delete?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    connect?: CompanyTagWhereUniqueInput | CompanyTagWhereUniqueInput[]
    update?: CompanyTagUpdateWithWhereUniqueWithoutTagInput | CompanyTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: CompanyTagUpdateManyWithWhereWithoutTagInput | CompanyTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type DraftTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput> | DraftTagCreateWithoutTagInput[] | DraftTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: DraftTagCreateOrConnectWithoutTagInput | DraftTagCreateOrConnectWithoutTagInput[]
    upsert?: DraftTagUpsertWithWhereUniqueWithoutTagInput | DraftTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: DraftTagCreateManyTagInputEnvelope
    set?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    disconnect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    delete?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    connect?: DraftTagWhereUniqueInput | DraftTagWhereUniqueInput[]
    update?: DraftTagUpdateWithWhereUniqueWithoutTagInput | DraftTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: DraftTagUpdateManyWithWhereWithoutTagInput | DraftTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
  }

  export type EmailTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput> | EmailTagCreateWithoutTagInput[] | EmailTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: EmailTagCreateOrConnectWithoutTagInput | EmailTagCreateOrConnectWithoutTagInput[]
    upsert?: EmailTagUpsertWithWhereUniqueWithoutTagInput | EmailTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: EmailTagCreateManyTagInputEnvelope
    set?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    disconnect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    delete?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    connect?: EmailTagWhereUniqueInput | EmailTagWhereUniqueInput[]
    update?: EmailTagUpdateWithWhereUniqueWithoutTagInput | EmailTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: EmailTagUpdateManyWithWhereWithoutTagInput | EmailTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutCompanyTagsInput = {
    create?: XOR<CompanyCreateWithoutCompanyTagsInput, CompanyUncheckedCreateWithoutCompanyTagsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyTagsInput
    connect?: CompanyWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTagCompaniesInput = {
    create?: XOR<TagCreateWithoutTagCompaniesInput, TagUncheckedCreateWithoutTagCompaniesInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagCompaniesInput
    connect?: TagWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutCompanyTagsNestedInput = {
    create?: XOR<CompanyCreateWithoutCompanyTagsInput, CompanyUncheckedCreateWithoutCompanyTagsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutCompanyTagsInput
    upsert?: CompanyUpsertWithoutCompanyTagsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutCompanyTagsInput, CompanyUpdateWithoutCompanyTagsInput>, CompanyUncheckedUpdateWithoutCompanyTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTagCompaniesNestedInput = {
    create?: XOR<TagCreateWithoutTagCompaniesInput, TagUncheckedCreateWithoutTagCompaniesInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagCompaniesInput
    upsert?: TagUpsertWithoutTagCompaniesInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTagCompaniesInput, TagUpdateWithoutTagCompaniesInput>, TagUncheckedUpdateWithoutTagCompaniesInput>
  }

  export type ContactCreateNestedOneWithoutContactTagsInput = {
    create?: XOR<ContactCreateWithoutContactTagsInput, ContactUncheckedCreateWithoutContactTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactTagsInput
    connect?: ContactWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutTagContactsInput = {
    create?: XOR<TagCreateWithoutTagContactsInput, TagUncheckedCreateWithoutTagContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagContactsInput
    connect?: TagWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutContactTagsNestedInput = {
    create?: XOR<ContactCreateWithoutContactTagsInput, ContactUncheckedCreateWithoutContactTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactTagsInput
    upsert?: ContactUpsertWithoutContactTagsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactTagsInput, ContactUpdateWithoutContactTagsInput>, ContactUncheckedUpdateWithoutContactTagsInput>
  }

  export type TagUpdateOneRequiredWithoutTagContactsNestedInput = {
    create?: XOR<TagCreateWithoutTagContactsInput, TagUncheckedCreateWithoutTagContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutTagContactsInput
    upsert?: TagUpsertWithoutTagContactsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutTagContactsInput, TagUpdateWithoutTagContactsInput>, TagUncheckedUpdateWithoutTagContactsInput>
  }

  export type DraftCreateNestedOneWithoutDraftTagsInput = {
    create?: XOR<DraftCreateWithoutDraftTagsInput, DraftUncheckedCreateWithoutDraftTagsInput>
    connectOrCreate?: DraftCreateOrConnectWithoutDraftTagsInput
    connect?: DraftWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutDraftTagInput = {
    create?: XOR<TagCreateWithoutDraftTagInput, TagUncheckedCreateWithoutDraftTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutDraftTagInput
    connect?: TagWhereUniqueInput
  }

  export type DraftUpdateOneRequiredWithoutDraftTagsNestedInput = {
    create?: XOR<DraftCreateWithoutDraftTagsInput, DraftUncheckedCreateWithoutDraftTagsInput>
    connectOrCreate?: DraftCreateOrConnectWithoutDraftTagsInput
    upsert?: DraftUpsertWithoutDraftTagsInput
    connect?: DraftWhereUniqueInput
    update?: XOR<XOR<DraftUpdateToOneWithWhereWithoutDraftTagsInput, DraftUpdateWithoutDraftTagsInput>, DraftUncheckedUpdateWithoutDraftTagsInput>
  }

  export type TagUpdateOneRequiredWithoutDraftTagNestedInput = {
    create?: XOR<TagCreateWithoutDraftTagInput, TagUncheckedCreateWithoutDraftTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutDraftTagInput
    upsert?: TagUpsertWithoutDraftTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutDraftTagInput, TagUpdateWithoutDraftTagInput>, TagUncheckedUpdateWithoutDraftTagInput>
  }

  export type EmailCreateNestedOneWithoutEmailTagsInput = {
    create?: XOR<EmailCreateWithoutEmailTagsInput, EmailUncheckedCreateWithoutEmailTagsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailTagsInput
    connect?: EmailWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutEmailTagInput = {
    create?: XOR<TagCreateWithoutEmailTagInput, TagUncheckedCreateWithoutEmailTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutEmailTagInput
    connect?: TagWhereUniqueInput
  }

  export type EmailUpdateOneRequiredWithoutEmailTagsNestedInput = {
    create?: XOR<EmailCreateWithoutEmailTagsInput, EmailUncheckedCreateWithoutEmailTagsInput>
    connectOrCreate?: EmailCreateOrConnectWithoutEmailTagsInput
    upsert?: EmailUpsertWithoutEmailTagsInput
    connect?: EmailWhereUniqueInput
    update?: XOR<XOR<EmailUpdateToOneWithWhereWithoutEmailTagsInput, EmailUpdateWithoutEmailTagsInput>, EmailUncheckedUpdateWithoutEmailTagsInput>
  }

  export type TagUpdateOneRequiredWithoutEmailTagNestedInput = {
    create?: XOR<TagCreateWithoutEmailTagInput, TagUncheckedCreateWithoutEmailTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutEmailTagInput
    upsert?: TagUpsertWithoutEmailTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutEmailTagInput, TagUpdateWithoutEmailTagInput>, TagUncheckedUpdateWithoutEmailTagInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumContactEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactEventType | EnumContactEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactEventTypeFilter<$PrismaModel> | $Enums.ContactEventType
  }

  export type NestedEnumContactEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactEventType | EnumContactEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactEventType[] | ListEnumContactEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactEventTypeFilter<$PrismaModel>
    _max?: NestedEnumContactEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEmailEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailEventType | EnumEmailEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailEventTypeFilter<$PrismaModel> | $Enums.EmailEventType
  }

  export type NestedEnumEmailEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmailEventType | EnumEmailEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmailEventType[] | ListEnumEmailEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmailEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmailEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmailEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEmailEventTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CompanyTagCreateWithoutCompanyInput = {
    tag: TagCreateNestedOneWithoutTagCompaniesInput
  }

  export type CompanyTagUncheckedCreateWithoutCompanyInput = {
    tagId: string
  }

  export type CompanyTagCreateOrConnectWithoutCompanyInput = {
    where: CompanyTagWhereUniqueInput
    create: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyTagCreateManyCompanyInputEnvelope = {
    data: CompanyTagCreateManyCompanyInput | CompanyTagCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutCompanyInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagCreateNestedManyWithoutContactInput
    events?: ContactEventCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactCreateNestedManyWithoutContactInput
    emails?: EmailCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
    events?: ContactEventUncheckedCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactUncheckedCreateNestedManyWithoutContactInput
    emails?: EmailUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactCreateManyCompanyInputEnvelope = {
    data: ContactCreateManyCompanyInput | ContactCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type CompanyTagUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyTagWhereUniqueInput
    update: XOR<CompanyTagUpdateWithoutCompanyInput, CompanyTagUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyTagCreateWithoutCompanyInput, CompanyTagUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyTagUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyTagWhereUniqueInput
    data: XOR<CompanyTagUpdateWithoutCompanyInput, CompanyTagUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyTagUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyTagScalarWhereInput
    data: XOR<CompanyTagUpdateManyMutationInput, CompanyTagUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyTagScalarWhereInput = {
    AND?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
    OR?: CompanyTagScalarWhereInput[]
    NOT?: CompanyTagScalarWhereInput | CompanyTagScalarWhereInput[]
    companyId?: StringFilter<"CompanyTag"> | string
    tagId?: StringFilter<"CompanyTag"> | string
  }

  export type ContactUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
    create: XOR<ContactCreateWithoutCompanyInput, ContactUncheckedCreateWithoutCompanyInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCompanyInput, ContactUncheckedUpdateWithoutCompanyInput>
  }

  export type ContactUpdateManyWithWhereWithoutCompanyInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    position?: StringFilter<"Contact"> | string
    email?: StringFilter<"Contact"> | string
    phone?: StringNullableFilter<"Contact"> | string | null
    linkedInUrl?: StringNullableFilter<"Contact"> | string | null
    location?: StringNullableFilter<"Contact"> | string | null
    companyId?: StringNullableFilter<"Contact"> | string | null
    isDeleted?: BoolFilter<"Contact"> | boolean
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type ContactTagCreateWithoutContactInput = {
    tag: TagCreateNestedOneWithoutTagContactsInput
  }

  export type ContactTagUncheckedCreateWithoutContactInput = {
    tagId: string
  }

  export type ContactTagCreateOrConnectWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagCreateManyContactInputEnvelope = {
    data: ContactTagCreateManyContactInput | ContactTagCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactEventCreateWithoutContactInput = {
    id?: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
  }

  export type ContactEventUncheckedCreateWithoutContactInput = {
    id?: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
  }

  export type ContactEventCreateOrConnectWithoutContactInput = {
    where: ContactEventWhereUniqueInput
    create: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput>
  }

  export type ContactEventCreateManyContactInputEnvelope = {
    data: ContactEventCreateManyContactInput | ContactEventCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutContactsInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyTags?: CompanyTagCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutContactsInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyTags?: CompanyTagUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutContactsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
  }

  export type DraftContactCreateWithoutContactInput = {
    draft: DraftCreateNestedOneWithoutDraftContactsInput
  }

  export type DraftContactUncheckedCreateWithoutContactInput = {
    draftId: string
  }

  export type DraftContactCreateOrConnectWithoutContactInput = {
    where: DraftContactWhereUniqueInput
    create: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput>
  }

  export type DraftContactCreateManyContactInputEnvelope = {
    data: DraftContactCreateManyContactInput | DraftContactCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EmailCreateWithoutContactInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: SenderCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutContactInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutContactInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput>
  }

  export type EmailCreateManyContactInputEnvelope = {
    data: EmailCreateManyContactInput | EmailCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutContactInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactTagScalarWhereInput = {
    AND?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    OR?: ContactTagScalarWhereInput[]
    NOT?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
  }

  export type ContactEventUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactEventWhereUniqueInput
    update: XOR<ContactEventUpdateWithoutContactInput, ContactEventUncheckedUpdateWithoutContactInput>
    create: XOR<ContactEventCreateWithoutContactInput, ContactEventUncheckedCreateWithoutContactInput>
  }

  export type ContactEventUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactEventWhereUniqueInput
    data: XOR<ContactEventUpdateWithoutContactInput, ContactEventUncheckedUpdateWithoutContactInput>
  }

  export type ContactEventUpdateManyWithWhereWithoutContactInput = {
    where: ContactEventScalarWhereInput
    data: XOR<ContactEventUpdateManyMutationInput, ContactEventUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactEventScalarWhereInput = {
    AND?: ContactEventScalarWhereInput | ContactEventScalarWhereInput[]
    OR?: ContactEventScalarWhereInput[]
    NOT?: ContactEventScalarWhereInput | ContactEventScalarWhereInput[]
    id?: StringFilter<"ContactEvent"> | string
    contactId?: StringFilter<"ContactEvent"> | string
    eventType?: EnumContactEventTypeFilter<"ContactEvent"> | $Enums.ContactEventType
    createdAt?: DateTimeFilter<"ContactEvent"> | Date | string
  }

  export type CompanyUpsertWithoutContactsInput = {
    update: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
    create: XOR<CompanyCreateWithoutContactsInput, CompanyUncheckedCreateWithoutContactsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutContactsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutContactsInput, CompanyUncheckedUpdateWithoutContactsInput>
  }

  export type CompanyUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyTags?: CompanyTagUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyTags?: CompanyTagUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DraftContactUpsertWithWhereUniqueWithoutContactInput = {
    where: DraftContactWhereUniqueInput
    update: XOR<DraftContactUpdateWithoutContactInput, DraftContactUncheckedUpdateWithoutContactInput>
    create: XOR<DraftContactCreateWithoutContactInput, DraftContactUncheckedCreateWithoutContactInput>
  }

  export type DraftContactUpdateWithWhereUniqueWithoutContactInput = {
    where: DraftContactWhereUniqueInput
    data: XOR<DraftContactUpdateWithoutContactInput, DraftContactUncheckedUpdateWithoutContactInput>
  }

  export type DraftContactUpdateManyWithWhereWithoutContactInput = {
    where: DraftContactScalarWhereInput
    data: XOR<DraftContactUpdateManyMutationInput, DraftContactUncheckedUpdateManyWithoutContactInput>
  }

  export type DraftContactScalarWhereInput = {
    AND?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
    OR?: DraftContactScalarWhereInput[]
    NOT?: DraftContactScalarWhereInput | DraftContactScalarWhereInput[]
    draftId?: StringFilter<"DraftContact"> | string
    contactId?: StringFilter<"DraftContact"> | string
  }

  export type EmailUpsertWithWhereUniqueWithoutContactInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutContactInput, EmailUncheckedUpdateWithoutContactInput>
    create: XOR<EmailCreateWithoutContactInput, EmailUncheckedCreateWithoutContactInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutContactInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutContactInput, EmailUncheckedUpdateWithoutContactInput>
  }

  export type EmailUpdateManyWithWhereWithoutContactInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutContactInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    id?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    body?: StringFilter<"Email"> | string
    messageId?: StringNullableFilter<"Email"> | string | null
    contactId?: StringFilter<"Email"> | string
    isBounced?: BoolFilter<"Email"> | boolean
    isSpamReported?: BoolFilter<"Email"> | boolean
    senderId?: StringFilter<"Email"> | string
    createdAt?: DateTimeFilter<"Email"> | Date | string
    updatedAt?: DateTimeFilter<"Email"> | Date | string
  }

  export type ContactCreateWithoutEventsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagCreateNestedManyWithoutContactInput
    company?: CompanyCreateNestedOneWithoutContactsInput
    contactDrafts?: DraftContactCreateNestedManyWithoutContactInput
    emails?: EmailCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactUncheckedCreateNestedManyWithoutContactInput
    emails?: EmailUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutEventsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEventsInput, ContactUncheckedCreateWithoutEventsInput>
  }

  export type ContactUpsertWithoutEventsInput = {
    update: XOR<ContactUpdateWithoutEventsInput, ContactUncheckedUpdateWithoutEventsInput>
    create: XOR<ContactCreateWithoutEventsInput, ContactUncheckedCreateWithoutEventsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEventsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEventsInput, ContactUncheckedUpdateWithoutEventsInput>
  }

  export type ContactUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUpdateManyWithoutContactNestedInput
    company?: CompanyUpdateOneWithoutContactsNestedInput
    contactDrafts?: DraftContactUpdateManyWithoutContactNestedInput
    emails?: EmailUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUncheckedUpdateManyWithoutContactNestedInput
    emails?: EmailUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateWithoutEmailsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagCreateNestedManyWithoutContactInput
    events?: ContactEventCreateNestedManyWithoutContactInput
    company?: CompanyCreateNestedOneWithoutContactsInput
    contactDrafts?: DraftContactCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutEmailsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
    events?: ContactEventUncheckedCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutEmailsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
  }

  export type SenderCreateWithoutEmailsInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    drafts?: DraftCreateNestedManyWithoutSenderInput
  }

  export type SenderUncheckedCreateWithoutEmailsInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    drafts?: DraftUncheckedCreateNestedManyWithoutSenderInput
  }

  export type SenderCreateOrConnectWithoutEmailsInput = {
    where: SenderWhereUniqueInput
    create: XOR<SenderCreateWithoutEmailsInput, SenderUncheckedCreateWithoutEmailsInput>
  }

  export type EmailTagCreateWithoutEmailInput = {
    tag: TagCreateNestedOneWithoutEmailTagInput
  }

  export type EmailTagUncheckedCreateWithoutEmailInput = {
    tagId: string
  }

  export type EmailTagCreateOrConnectWithoutEmailInput = {
    where: EmailTagWhereUniqueInput
    create: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput>
  }

  export type EmailTagCreateManyEmailInputEnvelope = {
    data: EmailTagCreateManyEmailInput | EmailTagCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type EmailEventCreateWithoutEmailInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type EmailEventUncheckedCreateWithoutEmailInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type EmailEventCreateOrConnectWithoutEmailInput = {
    where: EmailEventWhereUniqueInput
    create: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput>
  }

  export type EmailEventCreateManyEmailInputEnvelope = {
    data: EmailEventCreateManyEmailInput | EmailEventCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type FollowUpCreateWithoutEmailInput = {
    id?: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: FollowUpEventCreateNestedManyWithoutFollowUpInput
  }

  export type FollowUpUncheckedCreateWithoutEmailInput = {
    id?: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: FollowUpEventUncheckedCreateNestedManyWithoutFollowUpInput
  }

  export type FollowUpCreateOrConnectWithoutEmailInput = {
    where: FollowUpWhereUniqueInput
    create: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput>
  }

  export type FollowUpCreateManyEmailInputEnvelope = {
    data: FollowUpCreateManyEmailInput | FollowUpCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutEmailInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutEmailInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutEmailInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput>
  }

  export type NotificationCreateManyEmailInputEnvelope = {
    data: NotificationCreateManyEmailInput | NotificationCreateManyEmailInput[]
    skipDuplicates?: boolean
  }

  export type ContactUpsertWithoutEmailsInput = {
    update: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutEmailsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
  }

  export type ContactUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUpdateManyWithoutContactNestedInput
    events?: ContactEventUpdateManyWithoutContactNestedInput
    company?: CompanyUpdateOneWithoutContactsNestedInput
    contactDrafts?: DraftContactUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
    events?: ContactEventUncheckedUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUncheckedUpdateManyWithoutContactNestedInput
  }

  export type SenderUpsertWithoutEmailsInput = {
    update: XOR<SenderUpdateWithoutEmailsInput, SenderUncheckedUpdateWithoutEmailsInput>
    create: XOR<SenderCreateWithoutEmailsInput, SenderUncheckedCreateWithoutEmailsInput>
    where?: SenderWhereInput
  }

  export type SenderUpdateToOneWithWhereWithoutEmailsInput = {
    where?: SenderWhereInput
    data: XOR<SenderUpdateWithoutEmailsInput, SenderUncheckedUpdateWithoutEmailsInput>
  }

  export type SenderUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drafts?: DraftUpdateManyWithoutSenderNestedInput
  }

  export type SenderUncheckedUpdateWithoutEmailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drafts?: DraftUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type EmailTagUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailTagWhereUniqueInput
    update: XOR<EmailTagUpdateWithoutEmailInput, EmailTagUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailTagCreateWithoutEmailInput, EmailTagUncheckedCreateWithoutEmailInput>
  }

  export type EmailTagUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailTagWhereUniqueInput
    data: XOR<EmailTagUpdateWithoutEmailInput, EmailTagUncheckedUpdateWithoutEmailInput>
  }

  export type EmailTagUpdateManyWithWhereWithoutEmailInput = {
    where: EmailTagScalarWhereInput
    data: XOR<EmailTagUpdateManyMutationInput, EmailTagUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailTagScalarWhereInput = {
    AND?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
    OR?: EmailTagScalarWhereInput[]
    NOT?: EmailTagScalarWhereInput | EmailTagScalarWhereInput[]
    emailId?: StringFilter<"EmailTag"> | string
    tagId?: StringFilter<"EmailTag"> | string
  }

  export type EmailEventUpsertWithWhereUniqueWithoutEmailInput = {
    where: EmailEventWhereUniqueInput
    update: XOR<EmailEventUpdateWithoutEmailInput, EmailEventUncheckedUpdateWithoutEmailInput>
    create: XOR<EmailEventCreateWithoutEmailInput, EmailEventUncheckedCreateWithoutEmailInput>
  }

  export type EmailEventUpdateWithWhereUniqueWithoutEmailInput = {
    where: EmailEventWhereUniqueInput
    data: XOR<EmailEventUpdateWithoutEmailInput, EmailEventUncheckedUpdateWithoutEmailInput>
  }

  export type EmailEventUpdateManyWithWhereWithoutEmailInput = {
    where: EmailEventScalarWhereInput
    data: XOR<EmailEventUpdateManyMutationInput, EmailEventUncheckedUpdateManyWithoutEmailInput>
  }

  export type EmailEventScalarWhereInput = {
    AND?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
    OR?: EmailEventScalarWhereInput[]
    NOT?: EmailEventScalarWhereInput | EmailEventScalarWhereInput[]
    id?: StringFilter<"EmailEvent"> | string
    emailId?: StringFilter<"EmailEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"EmailEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"EmailEvent"> | Date | string
  }

  export type FollowUpUpsertWithWhereUniqueWithoutEmailInput = {
    where: FollowUpWhereUniqueInput
    update: XOR<FollowUpUpdateWithoutEmailInput, FollowUpUncheckedUpdateWithoutEmailInput>
    create: XOR<FollowUpCreateWithoutEmailInput, FollowUpUncheckedCreateWithoutEmailInput>
  }

  export type FollowUpUpdateWithWhereUniqueWithoutEmailInput = {
    where: FollowUpWhereUniqueInput
    data: XOR<FollowUpUpdateWithoutEmailInput, FollowUpUncheckedUpdateWithoutEmailInput>
  }

  export type FollowUpUpdateManyWithWhereWithoutEmailInput = {
    where: FollowUpScalarWhereInput
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyWithoutEmailInput>
  }

  export type FollowUpScalarWhereInput = {
    AND?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
    OR?: FollowUpScalarWhereInput[]
    NOT?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
    id?: StringFilter<"FollowUp"> | string
    subject?: StringFilter<"FollowUp"> | string
    body?: StringFilter<"FollowUp"> | string
    emailId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    isBounced?: BoolFilter<"FollowUp"> | boolean
    isSpamReported?: BoolFilter<"FollowUp"> | boolean
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    updatedAt?: DateTimeFilter<"FollowUp"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutEmailInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutEmailInput, NotificationUncheckedUpdateWithoutEmailInput>
    create: XOR<NotificationCreateWithoutEmailInput, NotificationUncheckedCreateWithoutEmailInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutEmailInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutEmailInput, NotificationUncheckedUpdateWithoutEmailInput>
  }

  export type NotificationUpdateManyWithWhereWithoutEmailInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutEmailInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    emailId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type EmailCreateWithoutEventsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    sender: SenderCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutEventsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutEventsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEventsInput, EmailUncheckedCreateWithoutEventsInput>
  }

  export type EmailUpsertWithoutEventsInput = {
    update: XOR<EmailUpdateWithoutEventsInput, EmailUncheckedUpdateWithoutEventsInput>
    create: XOR<EmailCreateWithoutEventsInput, EmailUncheckedCreateWithoutEventsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutEventsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutEventsInput, EmailUncheckedUpdateWithoutEventsInput>
  }

  export type EmailUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailCreateWithoutFollowUpsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    sender: SenderCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutFollowUpsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutFollowUpsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutFollowUpsInput, EmailUncheckedCreateWithoutFollowUpsInput>
  }

  export type FollowUpEventCreateWithoutFollowUpInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpEventUncheckedCreateWithoutFollowUpInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpEventCreateOrConnectWithoutFollowUpInput = {
    where: FollowUpEventWhereUniqueInput
    create: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput>
  }

  export type FollowUpEventCreateManyFollowUpInputEnvelope = {
    data: FollowUpEventCreateManyFollowUpInput | FollowUpEventCreateManyFollowUpInput[]
    skipDuplicates?: boolean
  }

  export type EmailUpsertWithoutFollowUpsInput = {
    update: XOR<EmailUpdateWithoutFollowUpsInput, EmailUncheckedUpdateWithoutFollowUpsInput>
    create: XOR<EmailCreateWithoutFollowUpsInput, EmailUncheckedCreateWithoutFollowUpsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutFollowUpsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutFollowUpsInput, EmailUncheckedUpdateWithoutFollowUpsInput>
  }

  export type EmailUpdateWithoutFollowUpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutFollowUpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type FollowUpEventUpsertWithWhereUniqueWithoutFollowUpInput = {
    where: FollowUpEventWhereUniqueInput
    update: XOR<FollowUpEventUpdateWithoutFollowUpInput, FollowUpEventUncheckedUpdateWithoutFollowUpInput>
    create: XOR<FollowUpEventCreateWithoutFollowUpInput, FollowUpEventUncheckedCreateWithoutFollowUpInput>
  }

  export type FollowUpEventUpdateWithWhereUniqueWithoutFollowUpInput = {
    where: FollowUpEventWhereUniqueInput
    data: XOR<FollowUpEventUpdateWithoutFollowUpInput, FollowUpEventUncheckedUpdateWithoutFollowUpInput>
  }

  export type FollowUpEventUpdateManyWithWhereWithoutFollowUpInput = {
    where: FollowUpEventScalarWhereInput
    data: XOR<FollowUpEventUpdateManyMutationInput, FollowUpEventUncheckedUpdateManyWithoutFollowUpInput>
  }

  export type FollowUpEventScalarWhereInput = {
    AND?: FollowUpEventScalarWhereInput | FollowUpEventScalarWhereInput[]
    OR?: FollowUpEventScalarWhereInput[]
    NOT?: FollowUpEventScalarWhereInput | FollowUpEventScalarWhereInput[]
    id?: StringFilter<"FollowUpEvent"> | string
    followUpId?: StringFilter<"FollowUpEvent"> | string
    eventType?: EnumEmailEventTypeFilter<"FollowUpEvent"> | $Enums.EmailEventType
    createdAt?: DateTimeFilter<"FollowUpEvent"> | Date | string
  }

  export type FollowUpCreateWithoutEventsInput = {
    id?: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    email: EmailCreateNestedOneWithoutFollowUpsInput
  }

  export type FollowUpUncheckedCreateWithoutEventsInput = {
    id?: string
    subject: string
    body: string
    emailId: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowUpCreateOrConnectWithoutEventsInput = {
    where: FollowUpWhereUniqueInput
    create: XOR<FollowUpCreateWithoutEventsInput, FollowUpUncheckedCreateWithoutEventsInput>
  }

  export type FollowUpUpsertWithoutEventsInput = {
    update: XOR<FollowUpUpdateWithoutEventsInput, FollowUpUncheckedUpdateWithoutEventsInput>
    create: XOR<FollowUpCreateWithoutEventsInput, FollowUpUncheckedCreateWithoutEventsInput>
    where?: FollowUpWhereInput
  }

  export type FollowUpUpdateToOneWithWhereWithoutEventsInput = {
    where?: FollowUpWhereInput
    data: XOR<FollowUpUpdateWithoutEventsInput, FollowUpUncheckedUpdateWithoutEventsInput>
  }

  export type FollowUpUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: EmailUpdateOneRequiredWithoutFollowUpsNestedInput
  }

  export type FollowUpUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    emailId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SenderCreateWithoutDraftsInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutSenderInput
  }

  export type SenderUncheckedCreateWithoutDraftsInput = {
    id?: string
    displayName: string
    name: string
    email: string
    apiKey: string
    esp: string
    priority?: number
    target: number
    sentCount?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailUncheckedCreateNestedManyWithoutSenderInput
  }

  export type SenderCreateOrConnectWithoutDraftsInput = {
    where: SenderWhereUniqueInput
    create: XOR<SenderCreateWithoutDraftsInput, SenderUncheckedCreateWithoutDraftsInput>
  }

  export type DraftContactCreateWithoutDraftInput = {
    contact: ContactCreateNestedOneWithoutContactDraftsInput
  }

  export type DraftContactUncheckedCreateWithoutDraftInput = {
    contactId: string
  }

  export type DraftContactCreateOrConnectWithoutDraftInput = {
    where: DraftContactWhereUniqueInput
    create: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput>
  }

  export type DraftContactCreateManyDraftInputEnvelope = {
    data: DraftContactCreateManyDraftInput | DraftContactCreateManyDraftInput[]
    skipDuplicates?: boolean
  }

  export type DraftTagCreateWithoutDraftInput = {
    tag: TagCreateNestedOneWithoutDraftTagInput
  }

  export type DraftTagUncheckedCreateWithoutDraftInput = {
    tagId: string
  }

  export type DraftTagCreateOrConnectWithoutDraftInput = {
    where: DraftTagWhereUniqueInput
    create: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput>
  }

  export type DraftTagCreateManyDraftInputEnvelope = {
    data: DraftTagCreateManyDraftInput | DraftTagCreateManyDraftInput[]
    skipDuplicates?: boolean
  }

  export type SenderUpsertWithoutDraftsInput = {
    update: XOR<SenderUpdateWithoutDraftsInput, SenderUncheckedUpdateWithoutDraftsInput>
    create: XOR<SenderCreateWithoutDraftsInput, SenderUncheckedCreateWithoutDraftsInput>
    where?: SenderWhereInput
  }

  export type SenderUpdateToOneWithWhereWithoutDraftsInput = {
    where?: SenderWhereInput
    data: XOR<SenderUpdateWithoutDraftsInput, SenderUncheckedUpdateWithoutDraftsInput>
  }

  export type SenderUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutSenderNestedInput
  }

  export type SenderUncheckedUpdateWithoutDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    apiKey?: StringFieldUpdateOperationsInput | string
    esp?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    target?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type DraftContactUpsertWithWhereUniqueWithoutDraftInput = {
    where: DraftContactWhereUniqueInput
    update: XOR<DraftContactUpdateWithoutDraftInput, DraftContactUncheckedUpdateWithoutDraftInput>
    create: XOR<DraftContactCreateWithoutDraftInput, DraftContactUncheckedCreateWithoutDraftInput>
  }

  export type DraftContactUpdateWithWhereUniqueWithoutDraftInput = {
    where: DraftContactWhereUniqueInput
    data: XOR<DraftContactUpdateWithoutDraftInput, DraftContactUncheckedUpdateWithoutDraftInput>
  }

  export type DraftContactUpdateManyWithWhereWithoutDraftInput = {
    where: DraftContactScalarWhereInput
    data: XOR<DraftContactUpdateManyMutationInput, DraftContactUncheckedUpdateManyWithoutDraftInput>
  }

  export type DraftTagUpsertWithWhereUniqueWithoutDraftInput = {
    where: DraftTagWhereUniqueInput
    update: XOR<DraftTagUpdateWithoutDraftInput, DraftTagUncheckedUpdateWithoutDraftInput>
    create: XOR<DraftTagCreateWithoutDraftInput, DraftTagUncheckedCreateWithoutDraftInput>
  }

  export type DraftTagUpdateWithWhereUniqueWithoutDraftInput = {
    where: DraftTagWhereUniqueInput
    data: XOR<DraftTagUpdateWithoutDraftInput, DraftTagUncheckedUpdateWithoutDraftInput>
  }

  export type DraftTagUpdateManyWithWhereWithoutDraftInput = {
    where: DraftTagScalarWhereInput
    data: XOR<DraftTagUpdateManyMutationInput, DraftTagUncheckedUpdateManyWithoutDraftInput>
  }

  export type DraftTagScalarWhereInput = {
    AND?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
    OR?: DraftTagScalarWhereInput[]
    NOT?: DraftTagScalarWhereInput | DraftTagScalarWhereInput[]
    draftId?: StringFilter<"DraftTag"> | string
    tagId?: StringFilter<"DraftTag"> | string
  }

  export type DraftCreateWithoutDraftContactsInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender?: SenderCreateNestedOneWithoutDraftsInput
    draftTags?: DraftTagCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateWithoutDraftContactsInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    senderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftTags?: DraftTagUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftCreateOrConnectWithoutDraftContactsInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutDraftContactsInput, DraftUncheckedCreateWithoutDraftContactsInput>
  }

  export type ContactCreateWithoutContactDraftsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagCreateNestedManyWithoutContactInput
    events?: ContactEventCreateNestedManyWithoutContactInput
    company?: CompanyCreateNestedOneWithoutContactsInput
    emails?: EmailCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutContactDraftsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
    events?: ContactEventUncheckedCreateNestedManyWithoutContactInput
    emails?: EmailUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutContactDraftsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactDraftsInput, ContactUncheckedCreateWithoutContactDraftsInput>
  }

  export type DraftUpsertWithoutDraftContactsInput = {
    update: XOR<DraftUpdateWithoutDraftContactsInput, DraftUncheckedUpdateWithoutDraftContactsInput>
    create: XOR<DraftCreateWithoutDraftContactsInput, DraftUncheckedCreateWithoutDraftContactsInput>
    where?: DraftWhereInput
  }

  export type DraftUpdateToOneWithWhereWithoutDraftContactsInput = {
    where?: DraftWhereInput
    data: XOR<DraftUpdateWithoutDraftContactsInput, DraftUncheckedUpdateWithoutDraftContactsInput>
  }

  export type DraftUpdateWithoutDraftContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: SenderUpdateOneWithoutDraftsNestedInput
    draftTags?: DraftTagUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateWithoutDraftContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftTags?: DraftTagUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type ContactUpsertWithoutContactDraftsInput = {
    update: XOR<ContactUpdateWithoutContactDraftsInput, ContactUncheckedUpdateWithoutContactDraftsInput>
    create: XOR<ContactCreateWithoutContactDraftsInput, ContactUncheckedCreateWithoutContactDraftsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactDraftsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactDraftsInput, ContactUncheckedUpdateWithoutContactDraftsInput>
  }

  export type ContactUpdateWithoutContactDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUpdateManyWithoutContactNestedInput
    events?: ContactEventUpdateManyWithoutContactNestedInput
    company?: CompanyUpdateOneWithoutContactsNestedInput
    emails?: EmailUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactDraftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
    events?: ContactEventUncheckedUpdateManyWithoutContactNestedInput
    emails?: EmailUncheckedUpdateManyWithoutContactNestedInput
  }

  export type EmailCreateWithoutNotificationsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    sender: SenderCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutNotificationsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutNotificationsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutNotificationsInput, EmailUncheckedCreateWithoutNotificationsInput>
  }

  export type EmailUpsertWithoutNotificationsInput = {
    update: XOR<EmailUpdateWithoutNotificationsInput, EmailUncheckedUpdateWithoutNotificationsInput>
    create: XOR<EmailCreateWithoutNotificationsInput, EmailUncheckedCreateWithoutNotificationsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutNotificationsInput, EmailUncheckedUpdateWithoutNotificationsInput>
  }

  export type EmailUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type DraftCreateWithoutSenderInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftContacts?: DraftContactCreateNestedManyWithoutDraftInput
    draftTags?: DraftTagCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateWithoutSenderInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftContacts?: DraftContactUncheckedCreateNestedManyWithoutDraftInput
    draftTags?: DraftTagUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftCreateOrConnectWithoutSenderInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput>
  }

  export type DraftCreateManySenderInputEnvelope = {
    data: DraftCreateManySenderInput | DraftCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type EmailCreateWithoutSenderInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    emailTags?: EmailTagCreateNestedManyWithoutEmailInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutSenderInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emailTags?: EmailTagUncheckedCreateNestedManyWithoutEmailInput
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutSenderInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput>
  }

  export type EmailCreateManySenderInputEnvelope = {
    data: EmailCreateManySenderInput | EmailCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type DraftUpsertWithWhereUniqueWithoutSenderInput = {
    where: DraftWhereUniqueInput
    update: XOR<DraftUpdateWithoutSenderInput, DraftUncheckedUpdateWithoutSenderInput>
    create: XOR<DraftCreateWithoutSenderInput, DraftUncheckedCreateWithoutSenderInput>
  }

  export type DraftUpdateWithWhereUniqueWithoutSenderInput = {
    where: DraftWhereUniqueInput
    data: XOR<DraftUpdateWithoutSenderInput, DraftUncheckedUpdateWithoutSenderInput>
  }

  export type DraftUpdateManyWithWhereWithoutSenderInput = {
    where: DraftScalarWhereInput
    data: XOR<DraftUpdateManyMutationInput, DraftUncheckedUpdateManyWithoutSenderInput>
  }

  export type DraftScalarWhereInput = {
    AND?: DraftScalarWhereInput | DraftScalarWhereInput[]
    OR?: DraftScalarWhereInput[]
    NOT?: DraftScalarWhereInput | DraftScalarWhereInput[]
    id?: StringFilter<"Draft"> | string
    subject?: StringNullableFilter<"Draft"> | string | null
    body?: StringNullableFilter<"Draft"> | string | null
    scheduledAt?: DateTimeNullableFilter<"Draft"> | Date | string | null
    senderId?: StringNullableFilter<"Draft"> | string | null
    createdAt?: DateTimeFilter<"Draft"> | Date | string
    updatedAt?: DateTimeFilter<"Draft"> | Date | string
  }

  export type EmailUpsertWithWhereUniqueWithoutSenderInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutSenderInput, EmailUncheckedUpdateWithoutSenderInput>
    create: XOR<EmailCreateWithoutSenderInput, EmailUncheckedCreateWithoutSenderInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutSenderInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutSenderInput, EmailUncheckedUpdateWithoutSenderInput>
  }

  export type EmailUpdateManyWithWhereWithoutSenderInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutSenderInput>
  }

  export type CompanyTagCreateWithoutTagInput = {
    company: CompanyCreateNestedOneWithoutCompanyTagsInput
  }

  export type CompanyTagUncheckedCreateWithoutTagInput = {
    companyId: string
  }

  export type CompanyTagCreateOrConnectWithoutTagInput = {
    where: CompanyTagWhereUniqueInput
    create: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput>
  }

  export type CompanyTagCreateManyTagInputEnvelope = {
    data: CompanyTagCreateManyTagInput | CompanyTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagCreateWithoutTagInput = {
    contact: ContactCreateNestedOneWithoutContactTagsInput
  }

  export type ContactTagUncheckedCreateWithoutTagInput = {
    contactId: string
  }

  export type ContactTagCreateOrConnectWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagCreateManyTagInputEnvelope = {
    data: ContactTagCreateManyTagInput | ContactTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type DraftTagCreateWithoutTagInput = {
    draft: DraftCreateNestedOneWithoutDraftTagsInput
  }

  export type DraftTagUncheckedCreateWithoutTagInput = {
    draftId: string
  }

  export type DraftTagCreateOrConnectWithoutTagInput = {
    where: DraftTagWhereUniqueInput
    create: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput>
  }

  export type DraftTagCreateManyTagInputEnvelope = {
    data: DraftTagCreateManyTagInput | DraftTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type EmailTagCreateWithoutTagInput = {
    email: EmailCreateNestedOneWithoutEmailTagsInput
  }

  export type EmailTagUncheckedCreateWithoutTagInput = {
    emailId: string
  }

  export type EmailTagCreateOrConnectWithoutTagInput = {
    where: EmailTagWhereUniqueInput
    create: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput>
  }

  export type EmailTagCreateManyTagInputEnvelope = {
    data: EmailTagCreateManyTagInput | EmailTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type CompanyTagUpsertWithWhereUniqueWithoutTagInput = {
    where: CompanyTagWhereUniqueInput
    update: XOR<CompanyTagUpdateWithoutTagInput, CompanyTagUncheckedUpdateWithoutTagInput>
    create: XOR<CompanyTagCreateWithoutTagInput, CompanyTagUncheckedCreateWithoutTagInput>
  }

  export type CompanyTagUpdateWithWhereUniqueWithoutTagInput = {
    where: CompanyTagWhereUniqueInput
    data: XOR<CompanyTagUpdateWithoutTagInput, CompanyTagUncheckedUpdateWithoutTagInput>
  }

  export type CompanyTagUpdateManyWithWhereWithoutTagInput = {
    where: CompanyTagScalarWhereInput
    data: XOR<CompanyTagUpdateManyMutationInput, CompanyTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ContactTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutTagInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutTagInput>
  }

  export type DraftTagUpsertWithWhereUniqueWithoutTagInput = {
    where: DraftTagWhereUniqueInput
    update: XOR<DraftTagUpdateWithoutTagInput, DraftTagUncheckedUpdateWithoutTagInput>
    create: XOR<DraftTagCreateWithoutTagInput, DraftTagUncheckedCreateWithoutTagInput>
  }

  export type DraftTagUpdateWithWhereUniqueWithoutTagInput = {
    where: DraftTagWhereUniqueInput
    data: XOR<DraftTagUpdateWithoutTagInput, DraftTagUncheckedUpdateWithoutTagInput>
  }

  export type DraftTagUpdateManyWithWhereWithoutTagInput = {
    where: DraftTagScalarWhereInput
    data: XOR<DraftTagUpdateManyMutationInput, DraftTagUncheckedUpdateManyWithoutTagInput>
  }

  export type EmailTagUpsertWithWhereUniqueWithoutTagInput = {
    where: EmailTagWhereUniqueInput
    update: XOR<EmailTagUpdateWithoutTagInput, EmailTagUncheckedUpdateWithoutTagInput>
    create: XOR<EmailTagCreateWithoutTagInput, EmailTagUncheckedCreateWithoutTagInput>
  }

  export type EmailTagUpdateWithWhereUniqueWithoutTagInput = {
    where: EmailTagWhereUniqueInput
    data: XOR<EmailTagUpdateWithoutTagInput, EmailTagUncheckedUpdateWithoutTagInput>
  }

  export type EmailTagUpdateManyWithWhereWithoutTagInput = {
    where: EmailTagScalarWhereInput
    data: XOR<EmailTagUpdateManyMutationInput, EmailTagUncheckedUpdateManyWithoutTagInput>
  }

  export type CompanyCreateWithoutCompanyTagsInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCompanyTagsInput = {
    id?: string
    title: string
    description?: string | null
    location: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCompanyTagsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCompanyTagsInput, CompanyUncheckedCreateWithoutCompanyTagsInput>
  }

  export type TagCreateWithoutTagCompaniesInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagContacts?: ContactTagCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTagCompaniesInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagContacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagUncheckedCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTagCompaniesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTagCompaniesInput, TagUncheckedCreateWithoutTagCompaniesInput>
  }

  export type CompanyUpsertWithoutCompanyTagsInput = {
    update: XOR<CompanyUpdateWithoutCompanyTagsInput, CompanyUncheckedUpdateWithoutCompanyTagsInput>
    create: XOR<CompanyCreateWithoutCompanyTagsInput, CompanyUncheckedCreateWithoutCompanyTagsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutCompanyTagsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutCompanyTagsInput, CompanyUncheckedUpdateWithoutCompanyTagsInput>
  }

  export type CompanyUpdateWithoutCompanyTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCompanyTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type TagUpsertWithoutTagCompaniesInput = {
    update: XOR<TagUpdateWithoutTagCompaniesInput, TagUncheckedUpdateWithoutTagCompaniesInput>
    create: XOR<TagCreateWithoutTagCompaniesInput, TagUncheckedCreateWithoutTagCompaniesInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTagCompaniesInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTagCompaniesInput, TagUncheckedUpdateWithoutTagCompaniesInput>
  }

  export type TagUpdateWithoutTagCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagContacts?: ContactTagUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTagCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagContacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUncheckedUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type ContactCreateWithoutContactTagsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ContactEventCreateNestedManyWithoutContactInput
    company?: CompanyCreateNestedOneWithoutContactsInput
    contactDrafts?: DraftContactCreateNestedManyWithoutContactInput
    emails?: EmailCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutContactTagsInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    companyId?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: ContactEventUncheckedCreateNestedManyWithoutContactInput
    contactDrafts?: DraftContactUncheckedCreateNestedManyWithoutContactInput
    emails?: EmailUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutContactTagsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactTagsInput, ContactUncheckedCreateWithoutContactTagsInput>
  }

  export type TagCreateWithoutTagContactsInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTagContactsInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagUncheckedCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagUncheckedCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTagContactsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTagContactsInput, TagUncheckedCreateWithoutTagContactsInput>
  }

  export type ContactUpsertWithoutContactTagsInput = {
    update: XOR<ContactUpdateWithoutContactTagsInput, ContactUncheckedUpdateWithoutContactTagsInput>
    create: XOR<ContactCreateWithoutContactTagsInput, ContactUncheckedCreateWithoutContactTagsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactTagsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactTagsInput, ContactUncheckedUpdateWithoutContactTagsInput>
  }

  export type ContactUpdateWithoutContactTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ContactEventUpdateManyWithoutContactNestedInput
    company?: CompanyUpdateOneWithoutContactsNestedInput
    contactDrafts?: DraftContactUpdateManyWithoutContactNestedInput
    emails?: EmailUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: ContactEventUncheckedUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUncheckedUpdateManyWithoutContactNestedInput
    emails?: EmailUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TagUpsertWithoutTagContactsInput = {
    update: XOR<TagUpdateWithoutTagContactsInput, TagUncheckedUpdateWithoutTagContactsInput>
    create: XOR<TagCreateWithoutTagContactsInput, TagUncheckedCreateWithoutTagContactsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutTagContactsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutTagContactsInput, TagUncheckedUpdateWithoutTagContactsInput>
  }

  export type TagUpdateWithoutTagContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTagContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUncheckedUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUncheckedUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type DraftCreateWithoutDraftTagsInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender?: SenderCreateNestedOneWithoutDraftsInput
    draftContacts?: DraftContactCreateNestedManyWithoutDraftInput
  }

  export type DraftUncheckedCreateWithoutDraftTagsInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    senderId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    draftContacts?: DraftContactUncheckedCreateNestedManyWithoutDraftInput
  }

  export type DraftCreateOrConnectWithoutDraftTagsInput = {
    where: DraftWhereUniqueInput
    create: XOR<DraftCreateWithoutDraftTagsInput, DraftUncheckedCreateWithoutDraftTagsInput>
  }

  export type TagCreateWithoutDraftTagInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutDraftTagInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagUncheckedCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    EmailTag?: EmailTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutDraftTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutDraftTagInput, TagUncheckedCreateWithoutDraftTagInput>
  }

  export type DraftUpsertWithoutDraftTagsInput = {
    update: XOR<DraftUpdateWithoutDraftTagsInput, DraftUncheckedUpdateWithoutDraftTagsInput>
    create: XOR<DraftCreateWithoutDraftTagsInput, DraftUncheckedCreateWithoutDraftTagsInput>
    where?: DraftWhereInput
  }

  export type DraftUpdateToOneWithWhereWithoutDraftTagsInput = {
    where?: DraftWhereInput
    data: XOR<DraftUpdateWithoutDraftTagsInput, DraftUncheckedUpdateWithoutDraftTagsInput>
  }

  export type DraftUpdateWithoutDraftTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: SenderUpdateOneWithoutDraftsNestedInput
    draftContacts?: DraftContactUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateWithoutDraftTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContacts?: DraftContactUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type TagUpsertWithoutDraftTagInput = {
    update: XOR<TagUpdateWithoutDraftTagInput, TagUncheckedUpdateWithoutDraftTagInput>
    create: XOR<TagCreateWithoutDraftTagInput, TagUncheckedCreateWithoutDraftTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutDraftTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutDraftTagInput, TagUncheckedUpdateWithoutDraftTagInput>
  }

  export type TagUpdateWithoutDraftTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutDraftTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUncheckedUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    EmailTag?: EmailTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type EmailCreateWithoutEmailTagsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutEmailsInput
    sender: SenderCreateNestedOneWithoutEmailsInput
    events?: EmailEventCreateNestedManyWithoutEmailInput
    followUps?: FollowUpCreateNestedManyWithoutEmailInput
    notifications?: NotificationCreateNestedManyWithoutEmailInput
  }

  export type EmailUncheckedCreateWithoutEmailTagsInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EmailEventUncheckedCreateNestedManyWithoutEmailInput
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEmailInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutEmailInput
  }

  export type EmailCreateOrConnectWithoutEmailTagsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailTagsInput, EmailUncheckedCreateWithoutEmailTagsInput>
  }

  export type TagCreateWithoutEmailTagInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutEmailTagInput = {
    id?: string
    title: string
    isDeleted?: boolean
    tagCompanies?: CompanyTagUncheckedCreateNestedManyWithoutTagInput
    tagContacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    DraftTag?: DraftTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutEmailTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutEmailTagInput, TagUncheckedCreateWithoutEmailTagInput>
  }

  export type EmailUpsertWithoutEmailTagsInput = {
    update: XOR<EmailUpdateWithoutEmailTagsInput, EmailUncheckedUpdateWithoutEmailTagsInput>
    create: XOR<EmailCreateWithoutEmailTagsInput, EmailUncheckedCreateWithoutEmailTagsInput>
    where?: EmailWhereInput
  }

  export type EmailUpdateToOneWithWhereWithoutEmailTagsInput = {
    where?: EmailWhereInput
    data: XOR<EmailUpdateWithoutEmailTagsInput, EmailUncheckedUpdateWithoutEmailTagsInput>
  }

  export type EmailUpdateWithoutEmailTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutEmailTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type TagUpsertWithoutEmailTagInput = {
    update: XOR<TagUpdateWithoutEmailTagInput, TagUncheckedUpdateWithoutEmailTagInput>
    create: XOR<TagCreateWithoutEmailTagInput, TagUncheckedCreateWithoutEmailTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutEmailTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutEmailTagInput, TagUncheckedUpdateWithoutEmailTagInput>
  }

  export type TagUpdateWithoutEmailTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutEmailTagInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    tagCompanies?: CompanyTagUncheckedUpdateManyWithoutTagNestedInput
    tagContacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    DraftTag?: DraftTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CompanyTagCreateManyCompanyInput = {
    tagId: string
  }

  export type ContactCreateManyCompanyInput = {
    id?: string
    name: string
    position: string
    email: string
    phone?: string | null
    linkedInUrl?: string | null
    location?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyTagUpdateWithoutCompanyInput = {
    tag?: TagUpdateOneRequiredWithoutTagCompaniesNestedInput
  }

  export type CompanyTagUncheckedUpdateWithoutCompanyInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyTagUncheckedUpdateManyWithoutCompanyInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUpdateManyWithoutContactNestedInput
    events?: ContactEventUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUpdateManyWithoutContactNestedInput
    emails?: EmailUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
    events?: ContactEventUncheckedUpdateManyWithoutContactNestedInput
    contactDrafts?: DraftContactUncheckedUpdateManyWithoutContactNestedInput
    emails?: EmailUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    linkedInUrl?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTagCreateManyContactInput = {
    tagId: string
  }

  export type ContactEventCreateManyContactInput = {
    id?: string
    eventType: $Enums.ContactEventType
    createdAt?: Date | string
  }

  export type DraftContactCreateManyContactInput = {
    draftId: string
  }

  export type EmailCreateManyContactInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    isBounced?: boolean
    isSpamReported?: boolean
    senderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTagUpdateWithoutContactInput = {
    tag?: TagUpdateOneRequiredWithoutTagContactsNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactEventUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEventUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactEventUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumContactEventTypeFieldUpdateOperationsInput | $Enums.ContactEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftContactUpdateWithoutContactInput = {
    draft?: DraftUpdateOneRequiredWithoutDraftContactsNestedInput
  }

  export type DraftContactUncheckedUpdateWithoutContactInput = {
    draftId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftContactUncheckedUpdateManyWithoutContactInput = {
    draftId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: SenderUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    senderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailTagCreateManyEmailInput = {
    tagId: string
  }

  export type EmailEventCreateManyEmailInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpCreateManyEmailInput = {
    id?: string
    subject: string
    body: string
    scheduledAt?: Date | string | null
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyEmailInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
  }

  export type EmailTagUpdateWithoutEmailInput = {
    tag?: TagUpdateOneRequiredWithoutEmailTagNestedInput
  }

  export type EmailTagUncheckedUpdateWithoutEmailInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTagUncheckedUpdateManyWithoutEmailInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailEventUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailEventUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: FollowUpEventUpdateManyWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: FollowUpEventUncheckedUpdateManyWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutEmailInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventCreateManyFollowUpInput = {
    id?: string
    eventType: $Enums.EmailEventType
    createdAt?: Date | string
  }

  export type FollowUpEventUpdateWithoutFollowUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventUncheckedUpdateWithoutFollowUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpEventUncheckedUpdateManyWithoutFollowUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEmailEventTypeFieldUpdateOperationsInput | $Enums.EmailEventType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DraftContactCreateManyDraftInput = {
    contactId: string
  }

  export type DraftTagCreateManyDraftInput = {
    tagId: string
  }

  export type DraftContactUpdateWithoutDraftInput = {
    contact?: ContactUpdateOneRequiredWithoutContactDraftsNestedInput
  }

  export type DraftContactUncheckedUpdateWithoutDraftInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftContactUncheckedUpdateManyWithoutDraftInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagUpdateWithoutDraftInput = {
    tag?: TagUpdateOneRequiredWithoutDraftTagNestedInput
  }

  export type DraftTagUncheckedUpdateWithoutDraftInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagUncheckedUpdateManyWithoutDraftInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftCreateManySenderInput = {
    id?: string
    subject?: string | null
    body?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailCreateManySenderInput = {
    id?: string
    subject: string
    body: string
    messageId?: string | null
    contactId: string
    isBounced?: boolean
    isSpamReported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DraftUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContacts?: DraftContactUpdateManyWithoutDraftNestedInput
    draftTags?: DraftTagUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContacts?: DraftContactUncheckedUpdateManyWithoutDraftNestedInput
    draftTags?: DraftTagUncheckedUpdateManyWithoutDraftNestedInput
  }

  export type DraftUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutEmailsNestedInput
    emailTags?: EmailTagUpdateManyWithoutEmailNestedInput
    events?: EmailEventUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailTags?: EmailTagUncheckedUpdateManyWithoutEmailNestedInput
    events?: EmailEventUncheckedUpdateManyWithoutEmailNestedInput
    followUps?: FollowUpUncheckedUpdateManyWithoutEmailNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutEmailNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: StringFieldUpdateOperationsInput | string
    isBounced?: BoolFieldUpdateOperationsInput | boolean
    isSpamReported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyTagCreateManyTagInput = {
    companyId: string
  }

  export type ContactTagCreateManyTagInput = {
    contactId: string
  }

  export type DraftTagCreateManyTagInput = {
    draftId: string
  }

  export type EmailTagCreateManyTagInput = {
    emailId: string
  }

  export type CompanyTagUpdateWithoutTagInput = {
    company?: CompanyUpdateOneRequiredWithoutCompanyTagsNestedInput
  }

  export type CompanyTagUncheckedUpdateWithoutTagInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyTagUncheckedUpdateManyWithoutTagInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUpdateWithoutTagInput = {
    contact?: ContactUpdateOneRequiredWithoutContactTagsNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagUpdateWithoutTagInput = {
    draft?: DraftUpdateOneRequiredWithoutDraftTagsNestedInput
  }

  export type DraftTagUncheckedUpdateWithoutTagInput = {
    draftId?: StringFieldUpdateOperationsInput | string
  }

  export type DraftTagUncheckedUpdateManyWithoutTagInput = {
    draftId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTagUpdateWithoutTagInput = {
    email?: EmailUpdateOneRequiredWithoutEmailTagsNestedInput
  }

  export type EmailTagUncheckedUpdateWithoutTagInput = {
    emailId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailTagUncheckedUpdateManyWithoutTagInput = {
    emailId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}